{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CrSFML # API Tutorials","title":"CrSFML"},{"location":"index.html#crsfml","text":"API Tutorials","title":"CrSFML"},{"location":"api/index.html","text":"System module Clock FileInputStream InputStream MemoryInputStream Mutex NonCopyable Thread Time Vector2 Vector2f Vector2i Vector2u Vector3 Vector3f Window module Clipboard Context ContextSettings Attribute Cursor Type Event Closed GainedFocus JoystickButtonEvent JoystickButtonPressed JoystickButtonReleased JoystickConnected JoystickConnectEvent JoystickDisconnected JoystickMoved JoystickMoveEvent KeyEvent KeyPressed KeyReleased LostFocus MouseButtonEvent MouseButtonPressed MouseButtonReleased MouseEntered MouseLeft MouseMoved MouseMoveEvent MouseWheelEvent MouseWheelMoved MouseWheelScrolled MouseWheelScrollEvent Resized SensorChanged SensorEvent SizeEvent TextEntered TextEvent TouchBegan TouchEnded TouchEvent TouchMoved GlResource Joystick Axis Identification Keyboard Key Mouse Button Wheel Sensor Type Style Touch VideoMode Window WindowHandle Graphics module BlendMode Equation Factor CircleShape Color ConvexShape Drawable FloatRect Font Info Glyph Image IntRect PrimitiveType Rect RectangleShape RenderStates RenderTarget RenderTexture RenderWindow Shader CurrentTextureType Type Shape Sprite Text Style Texture CoordinateType Transform Transformable Vertex VertexArray VertexBuffer Usage View Audio module AlResource Listener Music Span TimeSpan Sound SoundBuffer SoundBufferRecorder SoundRecorder SoundSource Status SoundStream Network module Ftp DirectoryResponse ListingResponse Response Status TransferMode Http Request Method Response Status IpAddress Packet Socket Status Type SocketSelector TcpListener TcpSocket UdpSocket InitError","title":"Index"},{"location":"tutorials/index.html","text":"CrSFML Tutorials # Tutorials for CrSFML based on the official Tutorials for SFML . # Read the tutorials Source on GitHub To contribute, edit the Markdown source files and make a pull request. Run mkdocs serve (requires pip install -r requirements.txt ) and open the link the browser to see the rendered result live. Contents # System module Handling time Threads User data streams Window module Opening and managing an SFML window Events explained Keyboard, mouse and joysticks Using OpenGL in an SFML window Graphics module Drawing 2D stuff Sprites and textures Text and fonts Shapes Designing your own entities with vertex arrays Position, rotation, scale: transforming entities Adding special effects with shaders Controlling the 2D camera with views Audio module Playing sounds and music Recording audio Custom audio streams Spatialization: Sounds in 3D Network module Communication using sockets Using packets Web requests with HTTP File transfers with FTP","title":"Index"},{"location":"tutorials/index.html#crsfml-tutorials","text":"","title":"CrSFML Tutorials"},{"location":"tutorials/index.html#tutorials-for-crsfml-based-on-the-official-tutorials-for-sfml","text":"Read the tutorials Source on GitHub To contribute, edit the Markdown source files and make a pull request. Run mkdocs serve (requires pip install -r requirements.txt ) and open the link the browser to see the rendered result live.","title":"Tutorials for CrSFML based on the official Tutorials for SFML."},{"location":"tutorials/index.html#contents","text":"System module Handling time Threads User data streams Window module Opening and managing an SFML window Events explained Keyboard, mouse and joysticks Using OpenGL in an SFML window Graphics module Drawing 2D stuff Sprites and textures Text and fonts Shapes Designing your own entities with vertex arrays Position, rotation, scale: transforming entities Adding special effects with shaders Controlling the 2D camera with views Audio module Playing sounds and music Recording audio Custom audio streams Spatialization: Sounds in 3D Network module Communication using sockets Using packets Web requests with HTTP File transfers with FTP","title":"Contents"},{"location":"api/audio.html","text":"Top-level # module SF # Extended modules # SF Constants # SFML_VERSION # VERSION #","title":"Audio module"},{"location":"api/audio.html#top-level","text":"","title":"Top-level"},{"location":"api/audio.html#SF","text":"","title":"SF"},{"location":"api/audio.html#extended-modules","text":"SF","title":"Extended modules"},{"location":"api/audio.html#constants","text":"","title":"Constants"},{"location":"api/audio.html#SF::SFML_VERSION","text":"","title":"SFML_VERSION"},{"location":"api/audio.html#SF::VERSION","text":"","title":"VERSION"},{"location":"api/graphics.html","text":"Top-level # module SF # Extended modules # SF Constants # SFML_VERSION # VERSION # Methods # #color ( * args , ** kwargs ) # Shorthand for Color.new [ View source ] #float_rect ( left : Number , top : Number , width : Number , height : Number ) # Shorthand for FloatRect.new Converts arguments to Float32 [ View source ] #int_rect ( left : Int , top : Int , width : Int , height : Int ) # Shorthand for IntRect.new Converts arguments to Int32 [ View source ]","title":"Graphics module"},{"location":"api/graphics.html#top-level","text":"","title":"Top-level"},{"location":"api/graphics.html#SF","text":"","title":"SF"},{"location":"api/graphics.html#extended-modules","text":"SF","title":"Extended modules"},{"location":"api/graphics.html#constants","text":"","title":"Constants"},{"location":"api/graphics.html#SF::SFML_VERSION","text":"","title":"SFML_VERSION"},{"location":"api/graphics.html#SF::VERSION","text":"","title":"VERSION"},{"location":"api/graphics.html#methods","text":"","title":"Methods"},{"location":"api/graphics.html#SF#color(*args,**kwargs)","text":"Shorthand for Color.new [ View source ]","title":"#color"},{"location":"api/graphics.html#SF#float_rect(left,top,width,height)","text":"Shorthand for FloatRect.new Converts arguments to Float32 [ View source ]","title":"#float_rect"},{"location":"api/graphics.html#SF#int_rect(left,top,width,height)","text":"Shorthand for IntRect.new Converts arguments to Int32 [ View source ]","title":"#int_rect"},{"location":"api/network.html","text":"Top-level # module SF # Extended modules # SF Constants # SFML_VERSION # VERSION #","title":"Network module"},{"location":"api/network.html#top-level","text":"","title":"Top-level"},{"location":"api/network.html#SF","text":"","title":"SF"},{"location":"api/network.html#extended-modules","text":"SF","title":"Extended modules"},{"location":"api/network.html#constants","text":"","title":"Constants"},{"location":"api/network.html#SF::SFML_VERSION","text":"","title":"SFML_VERSION"},{"location":"api/network.html#SF::VERSION","text":"","title":"VERSION"},{"location":"api/system.html","text":"Top-level # module SF # Extended modules # SF Constants # SFML_VERSION # VERSION # Methods # #microseconds ( amount : Int ) : Time # Construct a time value from a number of microseconds amount - Number of microseconds Returns: Time value constructed from the amount of microseconds See also: seconds , milliseconds [ View source ] #milliseconds ( amount : Int ) : Time # Construct a time value from a number of milliseconds amount - Number of milliseconds Returns: Time value constructed from the amount of milliseconds See also: seconds , microseconds [ View source ] #seconds ( amount : Number ) : Time # Construct a time value from a number of seconds amount - Number of seconds Returns: Time value constructed from the amount of seconds See also: milliseconds , microseconds [ View source ] #sleep ( duration : Time ) # Make the current thread sleep for a given duration SF.sleep is the best way to block a program or one of its threads, as it doesn't consume any CPU power. duration - Time to sleep [ View source ] #vector2 ( x , y ) # Shorthand for Vector2.new If arguments are mixed between Int32 and Float , they are converted to match Vector2f [ View source ] #vector2f ( x : Number , y : Number ) # Shorthand for Vector2f.new Converts arguments to Float32 [ View source ] #vector2i ( x : Int , y : Int ) # Shorthand for Vector2i.new Converts arguments to Int32 [ View source ] #vector3 ( x , y , z ) # Shorthand for Vector3.new [ View source ] #vector3f ( x : Number , y : Number , z : Number ) # Shorthand for Vector3f.new Converts arguments to Float32 [ View source ]","title":"System module"},{"location":"api/system.html#top-level","text":"","title":"Top-level"},{"location":"api/system.html#SF","text":"","title":"SF"},{"location":"api/system.html#extended-modules","text":"SF","title":"Extended modules"},{"location":"api/system.html#constants","text":"","title":"Constants"},{"location":"api/system.html#SF::SFML_VERSION","text":"","title":"SFML_VERSION"},{"location":"api/system.html#SF::VERSION","text":"","title":"VERSION"},{"location":"api/system.html#methods","text":"","title":"Methods"},{"location":"api/system.html#SF#microseconds(amount)","text":"Construct a time value from a number of microseconds amount - Number of microseconds Returns: Time value constructed from the amount of microseconds See also: seconds , milliseconds [ View source ]","title":"#microseconds"},{"location":"api/system.html#SF#milliseconds(amount)","text":"Construct a time value from a number of milliseconds amount - Number of milliseconds Returns: Time value constructed from the amount of milliseconds See also: seconds , microseconds [ View source ]","title":"#milliseconds"},{"location":"api/system.html#SF#seconds(amount)","text":"Construct a time value from a number of seconds amount - Number of seconds Returns: Time value constructed from the amount of seconds See also: milliseconds , microseconds [ View source ]","title":"#seconds"},{"location":"api/system.html#SF#sleep(duration)","text":"Make the current thread sleep for a given duration SF.sleep is the best way to block a program or one of its threads, as it doesn't consume any CPU power. duration - Time to sleep [ View source ]","title":"#sleep"},{"location":"api/system.html#SF#vector2(x,y)","text":"Shorthand for Vector2.new If arguments are mixed between Int32 and Float , they are converted to match Vector2f [ View source ]","title":"#vector2"},{"location":"api/system.html#SF#vector2f(x,y)","text":"Shorthand for Vector2f.new Converts arguments to Float32 [ View source ]","title":"#vector2f"},{"location":"api/system.html#SF#vector2i(x,y)","text":"Shorthand for Vector2i.new Converts arguments to Int32 [ View source ]","title":"#vector2i"},{"location":"api/system.html#SF#vector3(x,y,z)","text":"Shorthand for Vector3.new [ View source ]","title":"#vector3"},{"location":"api/system.html#SF#vector3f(x,y,z)","text":"Shorthand for Vector3f.new Converts arguments to Float32 [ View source ]","title":"#vector3f"},{"location":"api/window.html","text":"Top-level # module SF # Extended modules # SF Constants # SFML_VERSION # VERSION #","title":"Window module"},{"location":"api/window.html#top-level","text":"","title":"Top-level"},{"location":"api/window.html#SF","text":"","title":"SF"},{"location":"api/window.html#extended-modules","text":"SF","title":"Extended modules"},{"location":"api/window.html#constants","text":"","title":"Constants"},{"location":"api/window.html#SF::SFML_VERSION","text":"","title":"SFML_VERSION"},{"location":"api/window.html#SF::VERSION","text":"","title":"VERSION"},{"location":"api/SF/AlResource.html","text":"module SF::AlResource # Empty module that indicates the class requires an OpenAL context Direct including types # SF::SoundBuffer SF::SoundRecorder SF::SoundSource","title":"AlResource"},{"location":"api/SF/AlResource.html#SF::AlResource","text":"Empty module that indicates the class requires an OpenAL context","title":"AlResource"},{"location":"api/SF/AlResource.html#direct-including-types","text":"SF::SoundBuffer SF::SoundRecorder SF::SoundSource","title":"Direct including types"},{"location":"api/SF/BlendMode.html","text":"struct SF::BlendMode inherits Struct # Blending modes for drawing SF::BlendMode is a struct that represents a blend mode. A blend mode determines how the colors of an object you draw are mixed with the colors that are already in the buffer. The struct is composed of 6 components, each of which has its own public member variable: Color Source Factor ( color_src_factor ) Color Destination Factor ( color_dst_factor ) Color Blend Equation ( color_equation ) Alpha Source Factor ( alpha_src_factor ) Alpha Destination Factor ( alpha_dst_factor ) Alpha Blend Equation ( alpha_equation ) The source factor specifies how the pixel you are drawing contributes to the final color. The destination factor specifies how the pixel already drawn in the buffer contributes to the final color. The color channels RGB (red, green, blue; simply referred to as color) and A (alpha; the transparency) can be treated separately. This separation can be useful for specific blend modes, but most often you won't need it and will simply treat the color as a single unit. The blend factors and equations correspond to their OpenGL equivalents. In general, the color of the resulting pixel is calculated according to the following formula ( src is the color of the source pixel, dst the color of the destination pixel, the other variables correspond to the public members, with the equations being + or - operators): dst . rgb = color_src_factor * src . rgb ( color_equation ) color_dst_factor * dst . rgb dst . a = alpha_src_factor * src . a ( alpha_equation ) alpha_dst_factor * dst . a All factors and colors are represented as floating point numbers between 0 and 1. Where necessary, the result is clamped to fit in that range. The most common blending modes are defined as constants in the SF module: SF::BlendAlpha , SF::BlendAdd , SF::BlendMultiply , SF::BlendNone . In SFML, a blend mode can be specified every time you draw a SF::Drawable object to a render target. It is part of the SF::RenderStates compound that is passed to the member function SF::RenderTarget.draw() . See also: SF::RenderStates , SF::RenderTarget Constants # BlendAdd # Add source to dest BlendAlpha # Blend source and dest according to dest alpha BlendMultiply # Multiply source and dest BlendNone # Overwrite dest with source Class methods # .new ( color_source_factor : BlendMode :: Factor , color_destination_factor : BlendMode :: Factor , color_blend_equation : BlendMode :: Equation , alpha_source_factor : BlendMode :: Factor , alpha_destination_factor : BlendMode :: Factor , alpha_blend_equation : BlendMode :: Equation ) # Construct the blend mode given the factors and equation. color_source_factor - Specifies how to compute the source factor for the color channels. color_destination_factor - Specifies how to compute the destination factor for the color channels. color_blend_equation - Specifies how to combine the source and destination colors. alpha_source_factor - Specifies how to compute the source factor. alpha_destination_factor - Specifies how to compute the destination factor. alpha_blend_equation - Specifies how to combine the source and destination alphas. [ View source ] .new ( source_factor : BlendMode :: Factor , destination_factor : BlendMode :: Factor , blend_equation : BlendMode :: Equation = Add ) # Construct the blend mode given the factors and equation. This constructor uses the same factors and equation for both color and alpha components. It also defaults to the Add equation. source_factor - Specifies how to compute the source factor for the color and alpha channels. destination_factor - Specifies how to compute the destination factor for the color and alpha channels. blend_equation - Specifies how to combine the source and destination colors and alpha. [ View source ] .new # Default constructor Constructs a blending mode that does alpha blending. [ View source ] Methods # #!= ( right : BlendMode ) : Bool # Overload of the != operator left - Left operand right - Right operand Returns: True if blending modes are different, false if they are equal [ View source ] #== ( right : BlendMode ) : Bool # Overload of the == operator left - Left operand right - Right operand Returns: True if blending modes are equal, false if they are different [ View source ] #alpha_dst_factor : BlendMode :: Factor # Destination blending factor for the alpha channel [ View source ] #alpha_dst_factor= ( alpha_dst_factor : BlendMode :: Factor ) # [ View source ] #alpha_equation : BlendMode :: Equation # Blending equation for the alpha channel [ View source ] #alpha_equation= ( alpha_equation : BlendMode :: Equation ) # [ View source ] #alpha_src_factor : BlendMode :: Factor # Source blending factor for the alpha channel [ View source ] #alpha_src_factor= ( alpha_src_factor : BlendMode :: Factor ) # [ View source ] #color_dst_factor : BlendMode :: Factor # Destination blending factor for the color channels [ View source ] #color_dst_factor= ( color_dst_factor : BlendMode :: Factor ) # [ View source ] #color_equation : BlendMode :: Equation # Blending equation for the color channels [ View source ] #color_equation= ( color_equation : BlendMode :: Equation ) # [ View source ] #color_src_factor : BlendMode :: Factor # Source blending factor for the color channels [ View source ] #color_src_factor= ( color_src_factor : BlendMode :: Factor ) # [ View source ] #dup : BlendMode # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"BlendMode"},{"location":"api/SF/BlendMode.html#SF::BlendMode","text":"Blending modes for drawing SF::BlendMode is a struct that represents a blend mode. A blend mode determines how the colors of an object you draw are mixed with the colors that are already in the buffer. The struct is composed of 6 components, each of which has its own public member variable: Color Source Factor ( color_src_factor ) Color Destination Factor ( color_dst_factor ) Color Blend Equation ( color_equation ) Alpha Source Factor ( alpha_src_factor ) Alpha Destination Factor ( alpha_dst_factor ) Alpha Blend Equation ( alpha_equation ) The source factor specifies how the pixel you are drawing contributes to the final color. The destination factor specifies how the pixel already drawn in the buffer contributes to the final color. The color channels RGB (red, green, blue; simply referred to as color) and A (alpha; the transparency) can be treated separately. This separation can be useful for specific blend modes, but most often you won't need it and will simply treat the color as a single unit. The blend factors and equations correspond to their OpenGL equivalents. In general, the color of the resulting pixel is calculated according to the following formula ( src is the color of the source pixel, dst the color of the destination pixel, the other variables correspond to the public members, with the equations being + or - operators): dst . rgb = color_src_factor * src . rgb ( color_equation ) color_dst_factor * dst . rgb dst . a = alpha_src_factor * src . a ( alpha_equation ) alpha_dst_factor * dst . a All factors and colors are represented as floating point numbers between 0 and 1. Where necessary, the result is clamped to fit in that range. The most common blending modes are defined as constants in the SF module: SF::BlendAlpha , SF::BlendAdd , SF::BlendMultiply , SF::BlendNone . In SFML, a blend mode can be specified every time you draw a SF::Drawable object to a render target. It is part of the SF::RenderStates compound that is passed to the member function SF::RenderTarget.draw() . See also: SF::RenderStates , SF::RenderTarget","title":"BlendMode"},{"location":"api/SF/BlendMode.html#constants","text":"","title":"Constants"},{"location":"api/SF/BlendMode.html#SF::BlendMode::BlendAdd","text":"Add source to dest","title":"BlendAdd"},{"location":"api/SF/BlendMode.html#SF::BlendMode::BlendAlpha","text":"Blend source and dest according to dest alpha","title":"BlendAlpha"},{"location":"api/SF/BlendMode.html#SF::BlendMode::BlendMultiply","text":"Multiply source and dest","title":"BlendMultiply"},{"location":"api/SF/BlendMode.html#SF::BlendMode::BlendNone","text":"Overwrite dest with source","title":"BlendNone"},{"location":"api/SF/BlendMode.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/BlendMode.html#SF::BlendMode.new(color_source_factor,color_destination_factor,color_blend_equation,alpha_source_factor,alpha_destination_factor,alpha_blend_equation)","text":"Construct the blend mode given the factors and equation. color_source_factor - Specifies how to compute the source factor for the color channels. color_destination_factor - Specifies how to compute the destination factor for the color channels. color_blend_equation - Specifies how to combine the source and destination colors. alpha_source_factor - Specifies how to compute the source factor. alpha_destination_factor - Specifies how to compute the destination factor. alpha_blend_equation - Specifies how to combine the source and destination alphas. [ View source ]","title":".new"},{"location":"api/SF/BlendMode.html#methods","text":"","title":"Methods"},{"location":"api/SF/BlendMode.html#SF::BlendMode#!=(right)","text":"Overload of the != operator left - Left operand right - Right operand Returns: True if blending modes are different, false if they are equal [ View source ]","title":"#!="},{"location":"api/SF/BlendMode.html#SF::BlendMode#==(right)","text":"Overload of the == operator left - Left operand right - Right operand Returns: True if blending modes are equal, false if they are different [ View source ]","title":"#=="},{"location":"api/SF/BlendMode.html#SF::BlendMode#alpha_dst_factor()","text":"Destination blending factor for the alpha channel [ View source ]","title":"#alpha_dst_factor"},{"location":"api/SF/BlendMode.html#SF::BlendMode#alpha_dst_factor=(alpha_dst_factor)","text":"[ View source ]","title":"#alpha_dst_factor="},{"location":"api/SF/BlendMode.html#SF::BlendMode#alpha_equation()","text":"Blending equation for the alpha channel [ View source ]","title":"#alpha_equation"},{"location":"api/SF/BlendMode.html#SF::BlendMode#alpha_equation=(alpha_equation)","text":"[ View source ]","title":"#alpha_equation="},{"location":"api/SF/BlendMode.html#SF::BlendMode#alpha_src_factor()","text":"Source blending factor for the alpha channel [ View source ]","title":"#alpha_src_factor"},{"location":"api/SF/BlendMode.html#SF::BlendMode#alpha_src_factor=(alpha_src_factor)","text":"[ View source ]","title":"#alpha_src_factor="},{"location":"api/SF/BlendMode.html#SF::BlendMode#color_dst_factor()","text":"Destination blending factor for the color channels [ View source ]","title":"#color_dst_factor"},{"location":"api/SF/BlendMode.html#SF::BlendMode#color_dst_factor=(color_dst_factor)","text":"[ View source ]","title":"#color_dst_factor="},{"location":"api/SF/BlendMode.html#SF::BlendMode#color_equation()","text":"Blending equation for the color channels [ View source ]","title":"#color_equation"},{"location":"api/SF/BlendMode.html#SF::BlendMode#color_equation=(color_equation)","text":"[ View source ]","title":"#color_equation="},{"location":"api/SF/BlendMode.html#SF::BlendMode#color_src_factor()","text":"Source blending factor for the color channels [ View source ]","title":"#color_src_factor"},{"location":"api/SF/BlendMode.html#SF::BlendMode#color_src_factor=(color_src_factor)","text":"[ View source ]","title":"#color_src_factor="},{"location":"api/SF/BlendMode.html#SF::BlendMode#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/CircleShape.html","text":"class SF::CircleShape inherits SF::Shape # Specialized shape representing a circle This class inherits all the functions of SF::Transformable (position, rotation, scale, bounds, ...) as well as the functions of SF::Shape (outline, color, texture, ...). Usage example: circle = SF :: CircleShape . new circle . radius = 150 circle . outline_color = SF :: Color :: Red circle . outline_thickness = 5 circle . position = { 10 , 20 } ... window . draw circle Since the graphics card can't draw perfect circles, we have to fake them with multiple triangles connected to each other. The \"points count\" property of SF::CircleShape defines how many of these triangles to use, and therefore defines the quality of the circle. The number of points can also be used for another purpose; with small numbers you can create any regular polygon shape: equilateral triangle, square, pentagon, hexagon, ... See also: SF::Shape , SF::RectangleShape , SF::ConvexShape Class methods # .new ( radius : Number = 0 , point_count : Int = 30 ) # Default constructor radius - Radius of the circle point_count - Number of points composing the circle [ View source ] Methods # #dup : CircleShape # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Virtual destructor [ View source ] #get_point ( index : Int ) : Vector2f # Get a point of the circle The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0 ... point_count Returns: index-th point of the shape [ View source ] #point_count : Int32 # Get the number of points of the circle Returns: Number of points of the circle See also: point_count= [ View source ] #point_count= ( count : Int ) # Set the number of points of the circle count - New number of points of the circle See also: point_count [ View source ] #radius : Float32 # Get the radius of the circle Returns: Radius of the circle See also: radius= [ View source ] #radius= ( radius : Number ) # Set the radius of the circle radius - New radius of the circle See also: radius [ View source ]","title":"CircleShape"},{"location":"api/SF/CircleShape.html#SF::CircleShape","text":"Specialized shape representing a circle This class inherits all the functions of SF::Transformable (position, rotation, scale, bounds, ...) as well as the functions of SF::Shape (outline, color, texture, ...). Usage example: circle = SF :: CircleShape . new circle . radius = 150 circle . outline_color = SF :: Color :: Red circle . outline_thickness = 5 circle . position = { 10 , 20 } ... window . draw circle Since the graphics card can't draw perfect circles, we have to fake them with multiple triangles connected to each other. The \"points count\" property of SF::CircleShape defines how many of these triangles to use, and therefore defines the quality of the circle. The number of points can also be used for another purpose; with small numbers you can create any regular polygon shape: equilateral triangle, square, pentagon, hexagon, ... See also: SF::Shape , SF::RectangleShape , SF::ConvexShape","title":"CircleShape"},{"location":"api/SF/CircleShape.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/CircleShape.html#SF::CircleShape.new(radius,point_count)","text":"Default constructor radius - Radius of the circle point_count - Number of points composing the circle [ View source ]","title":".new"},{"location":"api/SF/CircleShape.html#methods","text":"","title":"Methods"},{"location":"api/SF/CircleShape.html#SF::CircleShape#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/CircleShape.html#SF::CircleShape#finalize()","text":"Virtual destructor [ View source ]","title":"#finalize"},{"location":"api/SF/CircleShape.html#SF::CircleShape#get_point(index)","text":"Get a point of the circle The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0 ... point_count Returns: index-th point of the shape [ View source ]","title":"#get_point"},{"location":"api/SF/CircleShape.html#SF::CircleShape#point_count()","text":"Get the number of points of the circle Returns: Number of points of the circle See also: point_count= [ View source ]","title":"#point_count"},{"location":"api/SF/CircleShape.html#SF::CircleShape#point_count=(count)","text":"Set the number of points of the circle count - New number of points of the circle See also: point_count [ View source ]","title":"#point_count="},{"location":"api/SF/CircleShape.html#SF::CircleShape#radius()","text":"Get the radius of the circle Returns: Radius of the circle See also: radius= [ View source ]","title":"#radius"},{"location":"api/SF/CircleShape.html#SF::CircleShape#radius=(radius)","text":"Set the radius of the circle radius - New radius of the circle See also: radius [ View source ]","title":"#radius="},{"location":"api/SF/Clipboard.html","text":"module SF::Clipboard # Give access to the system clipboard SF::Clipboard provides an interface for getting and setting the contents of the system clipboard. It is important to note that due to limitations on some operating systems, setting the clipboard contents is only guaranteed to work if there is currently an open window for which events are being handled. Usage example: // get the clipboard content as a string sf :: String string = sf :: Clipboard :: getString (); // or use it in the event loop sf :: Event event ; while ( window . pollEvent ( event )) { if ( event . type == sf :: Event :: Closed ) window . close (); if ( event . type == sf :: Event :: KeyPressed ) { // Using Ctrl + V to paste a string into SFML if ( event . key . control && event . key . code == sf :: Keyboard :: V ) string = sf :: Clipboard :: getString (); // Using Ctrl + C to copy a string out of SFML if ( event . key . control && event . key . code == sf :: Keyboard :: C ) sf :: Clipboard :: setString ( \"Hello World!\" ); } } See also: SF::String , SF::Event Class methods # .string : String # Get the content of the clipboard as string data This function returns the content of the clipboard as a string. If the clipboard does not contain string it returns an empty SF::String object. Returns: Clipboard contents as SF::String object [ View source ] .string= ( text : String ) # Set the content of the clipboard as string data This function sets the content of the clipboard as a string. Warning: Due to limitations on some operating systems, setting the clipboard contents is only guaranteed to work if there is currently an open window for which events are being handled. text - SF::String containing the data to be sent to the clipboard [ View source ]","title":"Clipboard"},{"location":"api/SF/Clipboard.html#SF::Clipboard","text":"Give access to the system clipboard SF::Clipboard provides an interface for getting and setting the contents of the system clipboard. It is important to note that due to limitations on some operating systems, setting the clipboard contents is only guaranteed to work if there is currently an open window for which events are being handled. Usage example: // get the clipboard content as a string sf :: String string = sf :: Clipboard :: getString (); // or use it in the event loop sf :: Event event ; while ( window . pollEvent ( event )) { if ( event . type == sf :: Event :: Closed ) window . close (); if ( event . type == sf :: Event :: KeyPressed ) { // Using Ctrl + V to paste a string into SFML if ( event . key . control && event . key . code == sf :: Keyboard :: V ) string = sf :: Clipboard :: getString (); // Using Ctrl + C to copy a string out of SFML if ( event . key . control && event . key . code == sf :: Keyboard :: C ) sf :: Clipboard :: setString ( \"Hello World!\" ); } } See also: SF::String , SF::Event","title":"Clipboard"},{"location":"api/SF/Clipboard.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Clipboard.html#SF::Clipboard.string()","text":"Get the content of the clipboard as string data This function returns the content of the clipboard as a string. If the clipboard does not contain string it returns an empty SF::String object. Returns: Clipboard contents as SF::String object [ View source ]","title":".string"},{"location":"api/SF/Clipboard.html#SF::Clipboard.string=(text)","text":"Set the content of the clipboard as string data This function sets the content of the clipboard as a string. Warning: Due to limitations on some operating systems, setting the clipboard contents is only guaranteed to work if there is currently an open window for which events are being handled. text - SF::String containing the data to be sent to the clipboard [ View source ]","title":".string="},{"location":"api/SF/Clock.html","text":"class SF::Clock inherits Reference # Utility class that measures the elapsed time SF::Clock is a lightweight class for measuring time. Its provides the most precise time that the underlying OS can achieve (generally microseconds or nanoseconds). It also ensures monotonicity, which means that the returned time can never go backward, even if the system time is changed. Usage example: clock = SF :: Clock . new ... time1 = clock . elapsed_time ... time2 = clock . restart () The SF::Time value returned by the clock can then be converted to a number of seconds, milliseconds or even microseconds. See also: SF::Time Class methods # .new # Default constructor The clock starts automatically after being constructed. [ View source ] Methods # #dup : Clock # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #elapsed_time : Time # Get the elapsed time This function returns the time elapsed since the last call to restart() (or the construction of the instance if restart() has not been called). Returns: Time elapsed [ View source ] #finalize # [ View source ] #restart : Time # Restart the clock This function puts the time counter back to zero. It also returns the time elapsed since the clock was started. Returns: Time elapsed [ View source ]","title":"Clock"},{"location":"api/SF/Clock.html#SF::Clock","text":"Utility class that measures the elapsed time SF::Clock is a lightweight class for measuring time. Its provides the most precise time that the underlying OS can achieve (generally microseconds or nanoseconds). It also ensures monotonicity, which means that the returned time can never go backward, even if the system time is changed. Usage example: clock = SF :: Clock . new ... time1 = clock . elapsed_time ... time2 = clock . restart () The SF::Time value returned by the clock can then be converted to a number of seconds, milliseconds or even microseconds. See also: SF::Time","title":"Clock"},{"location":"api/SF/Clock.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Clock.html#SF::Clock.new()","text":"Default constructor The clock starts automatically after being constructed. [ View source ]","title":".new"},{"location":"api/SF/Clock.html#methods","text":"","title":"Methods"},{"location":"api/SF/Clock.html#SF::Clock#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Clock.html#SF::Clock#elapsed_time()","text":"Get the elapsed time This function returns the time elapsed since the last call to restart() (or the construction of the instance if restart() has not been called). Returns: Time elapsed [ View source ]","title":"#elapsed_time"},{"location":"api/SF/Clock.html#SF::Clock#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Clock.html#SF::Clock#restart()","text":"Restart the clock This function puts the time counter back to zero. It also returns the time elapsed since the clock was started. Returns: Time elapsed [ View source ]","title":"#restart"},{"location":"api/SF/Color.html","text":"struct SF::Color inherits Struct # Utility struct for manipulating RGBA colors SF::Color is a simple color struct composed of 4 components: Red Green Blue Alpha (opacity) Each component is a public member, an unsigned integer in the range 0..255 . Thus, colors can be constructed and manipulated very easily: color = SF :: Color . new ( 255 , 0 , 0 ) # red color . r = 0 # make it black color . b = 128 # make it dark blue The fourth component of colors, named \"alpha\", represents the opacity of the color. A color with an alpha value of 255 will be fully opaque, while an alpha value of 0 will make a color fully transparent, whatever the value of the other components is. The most common colors are already defined as static variables: black = SF :: Color :: Black white = SF :: Color :: White red = SF :: Color :: Red green = SF :: Color :: Green blue = SF :: Color :: Blue yellow = SF :: Color :: Yellow magenta = SF :: Color :: Magenta cyan = SF :: Color :: Cyan transparent = SF :: Color :: Transparent Colors can also be added and modulated (multiplied) using the overloaded operators + and *. Constants # Black # Black predefined color Blue # Blue predefined color Cyan # Cyan predefined color Green # Green predefined color Magenta # Magenta predefined color Red # Red predefined color Transparent # Transparent (black) predefined color White # White predefined color Yellow # Yellow predefined color Class methods # .new ( red : Int , green : Int , blue : Int , alpha : Int = 255 ) # Construct the color from its 4 RGBA components red - Red component (in the range 0..255 ) green - Green component (in the range 0..255 ) blue - Blue component (in the range 0..255 ) alpha - Alpha (opacity) component (in the range 0..255 ) [ View source ] .new ( color : Int ) # Construct the color from 32-bit unsigned integer color - Number containing the RGBA components (in that order) [ View source ] .new # Default constructor Constructs an opaque black color. It is equivalent to SF::Color (0, 0, 0, 255). [ View source ] Methods # #!= ( right : Color ) : Bool # Overload of the != operator This operator compares two colors and check if they are different. left - Left operand right - Right operand Returns: True if colors are different, false if they are equal [ View source ] #* ( right : Color ) : Color # Overload of the binary * operator This operator returns the component-wise multiplication (also called \"modulation\") of two colors. Components are then divided by 255 so that the result is still in the range 0 .. 255 . left - Left operand right - Right operand Returns: Result of left * right [ View source ] #+ ( right : Color ) : Color # Overload of the binary + operator This operator returns the component-wise sum of two colors. Components that exceed 255 are clamped to 255. left - Left operand right - Right operand Returns: Result of left + right [ View source ] #- ( right : Color ) : Color # Overload of the binary - operator This operator returns the component-wise subtraction of two colors. Components below 0 are clamped to 0. left - Left operand right - Right operand Returns: Result of left - right [ View source ] #== ( right : Color ) : Bool # Overload of the == operator This operator compares two colors and check if they are equal. left - Left operand right - Right operand Returns: True if colors are equal, false if they are different [ View source ] #a : UInt8 # Alpha (opacity) component [ View source ] #a= ( a : Int ) # [ View source ] #b : UInt8 # Blue component [ View source ] #b= ( b : Int ) # [ View source ] #dup : Color # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #g : UInt8 # Green component [ View source ] #g= ( g : Int ) # [ View source ] #inspect ( io ) # [ View source ] #r : UInt8 # Red component [ View source ] #r= ( r : Int ) # [ View source ] #to_integer : UInt32 # Retrieve the color as a 32-bit unsigned integer Returns: Color represented as a 32-bit unsigned integer [ View source ]","title":"Color"},{"location":"api/SF/Color.html#SF::Color","text":"Utility struct for manipulating RGBA colors SF::Color is a simple color struct composed of 4 components: Red Green Blue Alpha (opacity) Each component is a public member, an unsigned integer in the range 0..255 . Thus, colors can be constructed and manipulated very easily: color = SF :: Color . new ( 255 , 0 , 0 ) # red color . r = 0 # make it black color . b = 128 # make it dark blue The fourth component of colors, named \"alpha\", represents the opacity of the color. A color with an alpha value of 255 will be fully opaque, while an alpha value of 0 will make a color fully transparent, whatever the value of the other components is. The most common colors are already defined as static variables: black = SF :: Color :: Black white = SF :: Color :: White red = SF :: Color :: Red green = SF :: Color :: Green blue = SF :: Color :: Blue yellow = SF :: Color :: Yellow magenta = SF :: Color :: Magenta cyan = SF :: Color :: Cyan transparent = SF :: Color :: Transparent Colors can also be added and modulated (multiplied) using the overloaded operators + and *.","title":"Color"},{"location":"api/SF/Color.html#constants","text":"","title":"Constants"},{"location":"api/SF/Color.html#SF::Color::Black","text":"Black predefined color","title":"Black"},{"location":"api/SF/Color.html#SF::Color::Blue","text":"Blue predefined color","title":"Blue"},{"location":"api/SF/Color.html#SF::Color::Cyan","text":"Cyan predefined color","title":"Cyan"},{"location":"api/SF/Color.html#SF::Color::Green","text":"Green predefined color","title":"Green"},{"location":"api/SF/Color.html#SF::Color::Magenta","text":"Magenta predefined color","title":"Magenta"},{"location":"api/SF/Color.html#SF::Color::Red","text":"Red predefined color","title":"Red"},{"location":"api/SF/Color.html#SF::Color::Transparent","text":"Transparent (black) predefined color","title":"Transparent"},{"location":"api/SF/Color.html#SF::Color::White","text":"White predefined color","title":"White"},{"location":"api/SF/Color.html#SF::Color::Yellow","text":"Yellow predefined color","title":"Yellow"},{"location":"api/SF/Color.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Color.html#SF::Color.new(red,green,blue,alpha)","text":"Construct the color from its 4 RGBA components red - Red component (in the range 0..255 ) green - Green component (in the range 0..255 ) blue - Blue component (in the range 0..255 ) alpha - Alpha (opacity) component (in the range 0..255 ) [ View source ]","title":".new"},{"location":"api/SF/Color.html#methods","text":"","title":"Methods"},{"location":"api/SF/Color.html#SF::Color#!=(right)","text":"Overload of the != operator This operator compares two colors and check if they are different. left - Left operand right - Right operand Returns: True if colors are different, false if they are equal [ View source ]","title":"#!="},{"location":"api/SF/Color.html#SF::Color#*(right)","text":"Overload of the binary * operator This operator returns the component-wise multiplication (also called \"modulation\") of two colors. Components are then divided by 255 so that the result is still in the range 0 .. 255 . left - Left operand right - Right operand Returns: Result of left * right [ View source ]","title":"#*"},{"location":"api/SF/Color.html#SF::Color#+(right)","text":"Overload of the binary + operator This operator returns the component-wise sum of two colors. Components that exceed 255 are clamped to 255. left - Left operand right - Right operand Returns: Result of left + right [ View source ]","title":"#+"},{"location":"api/SF/Color.html#SF::Color#-(right)","text":"Overload of the binary - operator This operator returns the component-wise subtraction of two colors. Components below 0 are clamped to 0. left - Left operand right - Right operand Returns: Result of left - right [ View source ]","title":"#-"},{"location":"api/SF/Color.html#SF::Color#==(right)","text":"Overload of the == operator This operator compares two colors and check if they are equal. left - Left operand right - Right operand Returns: True if colors are equal, false if they are different [ View source ]","title":"#=="},{"location":"api/SF/Color.html#SF::Color#a()","text":"Alpha (opacity) component [ View source ]","title":"#a"},{"location":"api/SF/Color.html#SF::Color#a=(a)","text":"[ View source ]","title":"#a="},{"location":"api/SF/Color.html#SF::Color#b()","text":"Blue component [ View source ]","title":"#b"},{"location":"api/SF/Color.html#SF::Color#b=(b)","text":"[ View source ]","title":"#b="},{"location":"api/SF/Color.html#SF::Color#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Color.html#SF::Color#g()","text":"Green component [ View source ]","title":"#g"},{"location":"api/SF/Color.html#SF::Color#g=(g)","text":"[ View source ]","title":"#g="},{"location":"api/SF/Color.html#SF::Color#inspect(io)","text":"[ View source ]","title":"#inspect"},{"location":"api/SF/Color.html#SF::Color#r()","text":"Red component [ View source ]","title":"#r"},{"location":"api/SF/Color.html#SF::Color#r=(r)","text":"[ View source ]","title":"#r="},{"location":"api/SF/Color.html#SF::Color#to_integer()","text":"Retrieve the color as a 32-bit unsigned integer Returns: Color represented as a 32-bit unsigned integer [ View source ]","title":"#to_integer"},{"location":"api/SF/Context.html","text":"class SF::Context inherits Reference # Class holding a valid drawing context If you need to make OpenGL calls without having an active window (like in a thread), you can use an instance of this class to get a valid context. Having a valid context is necessary for every OpenGL call. Note that a context is only active in its current thread, if you create a new thread it will have no valid context by default. To use a SF::Context instance, just construct it and let it live as long as you need a valid context. No explicit activation is needed, all it has to do is to exist. Its destructor will take care of deactivating and freeing all the attached resources. Usage example: void threadFunction ( void * ) SF :: Context context # from now on, you have a valid context # you can make OpenGL calls glClear ( GL_DEPTH_BUFFER_BIT ) end # the context is automatically deactivated and destroyed # by the SF::Context destructor Included modules # SF::GlResource SF::NonCopyable Class methods # .active_context_id : UInt64 # Get the currently active context's ID The context ID is used to identify contexts when managing unshareable OpenGL resources. Returns: The active context's ID or 0 if no context is currently active [ View source ] .extension_available? ( name : String ) : Bool # Check whether a given OpenGL extension is available name - Name of the extension to check for Returns: True if available, false if unavailable [ View source ] .new ( settings : ContextSettings , width : Int , height : Int ) # Construct a in-memory context This constructor is for internal use, you don't need to bother with it. settings - Creation parameters width - Back buffer width height - Back buffer height [ View source ] .new # Default constructor The constructor creates and activates the context [ View source ] Methods # #active= ( active : Bool ) : Bool # Activate or deactivate explicitly the context active - True to activate, false to deactivate Returns: True on success, false on failure [ View source ] #finalize # Destructor The destructor deactivates and destroys the context [ View source ] #settings : ContextSettings # Get the settings of the context Note that these settings may be different than the ones passed to the constructor; they are indeed adjusted if the original settings are not directly supported by the system. Returns: Structure containing the settings [ View source ]","title":"Context"},{"location":"api/SF/Context.html#SF::Context","text":"Class holding a valid drawing context If you need to make OpenGL calls without having an active window (like in a thread), you can use an instance of this class to get a valid context. Having a valid context is necessary for every OpenGL call. Note that a context is only active in its current thread, if you create a new thread it will have no valid context by default. To use a SF::Context instance, just construct it and let it live as long as you need a valid context. No explicit activation is needed, all it has to do is to exist. Its destructor will take care of deactivating and freeing all the attached resources. Usage example: void threadFunction ( void * ) SF :: Context context # from now on, you have a valid context # you can make OpenGL calls glClear ( GL_DEPTH_BUFFER_BIT ) end # the context is automatically deactivated and destroyed # by the SF::Context destructor","title":"Context"},{"location":"api/SF/Context.html#included-modules","text":"SF::GlResource SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Context.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Context.html#SF::Context.active_context_id()","text":"Get the currently active context's ID The context ID is used to identify contexts when managing unshareable OpenGL resources. Returns: The active context's ID or 0 if no context is currently active [ View source ]","title":".active_context_id"},{"location":"api/SF/Context.html#SF::Context.extension_available?(name)","text":"Check whether a given OpenGL extension is available name - Name of the extension to check for Returns: True if available, false if unavailable [ View source ]","title":".extension_available?"},{"location":"api/SF/Context.html#SF::Context.new(settings,width,height)","text":"Construct a in-memory context This constructor is for internal use, you don't need to bother with it. settings - Creation parameters width - Back buffer width height - Back buffer height [ View source ]","title":".new"},{"location":"api/SF/Context.html#methods","text":"","title":"Methods"},{"location":"api/SF/Context.html#SF::Context#active=(active)","text":"Activate or deactivate explicitly the context active - True to activate, false to deactivate Returns: True on success, false on failure [ View source ]","title":"#active="},{"location":"api/SF/Context.html#SF::Context#finalize()","text":"Destructor The destructor deactivates and destroys the context [ View source ]","title":"#finalize"},{"location":"api/SF/Context.html#SF::Context#settings()","text":"Get the settings of the context Note that these settings may be different than the ones passed to the constructor; they are indeed adjusted if the original settings are not directly supported by the system. Returns: Structure containing the settings [ View source ]","title":"#settings"},{"location":"api/SF/ContextSettings.html","text":"struct SF::ContextSettings inherits Struct # Structure defining the settings of the OpenGL context attached to a window ContextSettings allows to define several advanced settings of the OpenGL context attached to a window. All these settings with the exception of the compatibility flag and anti-aliasing level have no impact on the regular SFML rendering (graphics module), so you may need to use this structure only if you're using SFML as a windowing system for custom OpenGL rendering. The depth_bits and stencil_bits members define the number of bits per pixel requested for the (respectively) depth and stencil buffers. antialiasing_level represents the requested number of multisampling levels for anti-aliasing. major_version and minor_version define the version of the OpenGL context that you want. Only versions greater or equal to 3.0 are relevant; versions lesser than 3.0 are all handled the same way (i.e. you can use any version < 3.0 if you don't want an OpenGL 3 context). When requesting a context with a version greater or equal to 3.2, you have the option of specifying whether the context should follow the core or compatibility profile of all newer (>= 3.2) OpenGL specifications. For versions 3.0 and 3.1 there is only the core profile. By default a compatibility context is created. You only need to specify the core flag if you want a core profile context to use with your own OpenGL rendering. Warning: The graphics module will not function if you request a core profile context. Make sure the attributes are set to Default if you want to use the graphics module. Setting the debug attribute flag will request a context with additional debugging features enabled. Depending on the system, this might be required for advanced OpenGL debugging. OpenGL debugging is disabled by default. Special Note for OS X: Apple only supports choosing between either a legacy context (OpenGL 2.1) or a core context (OpenGL version depends on the operating system version but is at least 3.2). Compatibility contexts are not supported. Further information is available on the OpenGL Capabilities Tables page. OS X also currently does not support debug contexts. Please note that these values are only a hint. No failure will be reported if one or more of these values are not supported by the system; instead, SFML will try to find the closest valid match. You can then retrieve the settings that the window actually used to create its context, with Window.settings(). Class methods # .new ( depth : Int = 0 , stencil : Int = 0 , antialiasing : Int = 0 , major : Int = 1 , minor : Int = 1 , attributes : Attribute = Default , s_rgb : Bool = false ) # Default constructor depth - Depth buffer bits stencil - Stencil buffer bits antialiasing - Antialiasing level major - Major number of the context version minor - Minor number of the context version attributes - Attribute flags of the context s_rgb - sRGB capable framebuffer [ View source ] Methods # #antialiasing_level : UInt32 # Level of antialiasing [ View source ] #antialiasing_level= ( antialiasing_level : Int ) # [ View source ] #attribute_flags : UInt32 # The attribute flags to create the context with [ View source ] #attribute_flags= ( attribute_flags : Int ) # [ View source ] #depth_bits : UInt32 # Bits of the depth buffer [ View source ] #depth_bits= ( depth_bits : Int ) # [ View source ] #dup : ContextSettings # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #major_version : UInt32 # Major number of the context version to create [ View source ] #major_version= ( major_version : Int ) # [ View source ] #minor_version : UInt32 # Minor number of the context version to create [ View source ] #minor_version= ( minor_version : Int ) # [ View source ] #s_rgb_capable : Bool # Whether the context framebuffer is sRGB capable [ View source ] #s_rgb_capable= ( s_rgb_capable : Bool ) # [ View source ] #stencil_bits : UInt32 # Bits of the stencil buffer [ View source ] #stencil_bits= ( stencil_bits : Int ) # [ View source ]","title":"ContextSettings"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings","text":"Structure defining the settings of the OpenGL context attached to a window ContextSettings allows to define several advanced settings of the OpenGL context attached to a window. All these settings with the exception of the compatibility flag and anti-aliasing level have no impact on the regular SFML rendering (graphics module), so you may need to use this structure only if you're using SFML as a windowing system for custom OpenGL rendering. The depth_bits and stencil_bits members define the number of bits per pixel requested for the (respectively) depth and stencil buffers. antialiasing_level represents the requested number of multisampling levels for anti-aliasing. major_version and minor_version define the version of the OpenGL context that you want. Only versions greater or equal to 3.0 are relevant; versions lesser than 3.0 are all handled the same way (i.e. you can use any version < 3.0 if you don't want an OpenGL 3 context). When requesting a context with a version greater or equal to 3.2, you have the option of specifying whether the context should follow the core or compatibility profile of all newer (>= 3.2) OpenGL specifications. For versions 3.0 and 3.1 there is only the core profile. By default a compatibility context is created. You only need to specify the core flag if you want a core profile context to use with your own OpenGL rendering. Warning: The graphics module will not function if you request a core profile context. Make sure the attributes are set to Default if you want to use the graphics module. Setting the debug attribute flag will request a context with additional debugging features enabled. Depending on the system, this might be required for advanced OpenGL debugging. OpenGL debugging is disabled by default. Special Note for OS X: Apple only supports choosing between either a legacy context (OpenGL 2.1) or a core context (OpenGL version depends on the operating system version but is at least 3.2). Compatibility contexts are not supported. Further information is available on the OpenGL Capabilities Tables page. OS X also currently does not support debug contexts. Please note that these values are only a hint. No failure will be reported if one or more of these values are not supported by the system; instead, SFML will try to find the closest valid match. You can then retrieve the settings that the window actually used to create its context, with Window.settings().","title":"ContextSettings"},{"location":"api/SF/ContextSettings.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings.new(depth,stencil,antialiasing,major,minor,attributes,s_rgb)","text":"Default constructor depth - Depth buffer bits stencil - Stencil buffer bits antialiasing - Antialiasing level major - Major number of the context version minor - Minor number of the context version attributes - Attribute flags of the context s_rgb - sRGB capable framebuffer [ View source ]","title":".new"},{"location":"api/SF/ContextSettings.html#methods","text":"","title":"Methods"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#antialiasing_level()","text":"Level of antialiasing [ View source ]","title":"#antialiasing_level"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#antialiasing_level=(antialiasing_level)","text":"[ View source ]","title":"#antialiasing_level="},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#attribute_flags()","text":"The attribute flags to create the context with [ View source ]","title":"#attribute_flags"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#attribute_flags=(attribute_flags)","text":"[ View source ]","title":"#attribute_flags="},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#depth_bits()","text":"Bits of the depth buffer [ View source ]","title":"#depth_bits"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#depth_bits=(depth_bits)","text":"[ View source ]","title":"#depth_bits="},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#major_version()","text":"Major number of the context version to create [ View source ]","title":"#major_version"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#major_version=(major_version)","text":"[ View source ]","title":"#major_version="},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#minor_version()","text":"Minor number of the context version to create [ View source ]","title":"#minor_version"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#minor_version=(minor_version)","text":"[ View source ]","title":"#minor_version="},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#s_rgb_capable()","text":"Whether the context framebuffer is sRGB capable [ View source ]","title":"#s_rgb_capable"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#s_rgb_capable=(s_rgb_capable)","text":"[ View source ]","title":"#s_rgb_capable="},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#stencil_bits()","text":"Bits of the stencil buffer [ View source ]","title":"#stencil_bits"},{"location":"api/SF/ContextSettings.html#SF::ContextSettings#stencil_bits=(stencil_bits)","text":"[ View source ]","title":"#stencil_bits="},{"location":"api/SF/ConvexShape.html","text":"class SF::ConvexShape inherits SF::Shape # Specialized shape representing a convex polygon This class inherits all the functions of SF::Transformable (position, rotation, scale, bounds, ...) as well as the functions of SF::Shape (outline, color, texture, ...). It is important to keep in mind that a convex shape must always be... convex, otherwise it may not be drawn correctly. Moreover, the points must be defined in order; using a random order would result in an incorrect shape. Usage example: polygon = SF :: ConvexShape . new polygon . point_count = 3 polygon [ 0 ] = SF . vector2f ( 0 , 0 ) polygon [ 1 ] = SF . vector2f ( 0 , 10 ) polygon [ 2 ] = SF . vector2f ( 25 , 5 ) polygon . outline_color = SF :: Color :: Red polygon . outline_thickness = 5 polygon . position = { 10 , 20 } ... window . draw polygon See also: SF::Shape , SF::RectangleShape , SF::CircleShape Class methods # .new ( point_count : Int = 0 ) # Default constructor point_count - Number of points of the polygon [ View source ] Methods # #[] ( index ) # Shorthand for get_point [ View source ] #[]= ( index , point ) # Shorthand for set_point [ View source ] #dup : ConvexShape # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Virtual destructor [ View source ] #get_point ( index : Int ) : Vector2f # Get the position of a point The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0 ... point_count Returns: Position of the index-th point of the polygon See also: point= [ View source ] #point_count : Int32 # Get the number of points of the polygon Returns: Number of points of the polygon See also: point_count= [ View source ] #point_count= ( count : Int ) # Set the number of points of the polygon count must be greater than 2 to define a valid shape. count - New number of points of the polygon See also: point_count [ View source ] #set_point ( index : Int , point : Vector2 | Tuple ) # Set the position of a point Don't forget that the polygon must remain convex, and the points need to stay ordered! point_count= must be called first in order to set the total number of points. The result is undefined if index is out of the valid range. index - Index of the point to change, in range 0 ... point_count point - New position of the point See also: point [ View source ]","title":"ConvexShape"},{"location":"api/SF/ConvexShape.html#SF::ConvexShape","text":"Specialized shape representing a convex polygon This class inherits all the functions of SF::Transformable (position, rotation, scale, bounds, ...) as well as the functions of SF::Shape (outline, color, texture, ...). It is important to keep in mind that a convex shape must always be... convex, otherwise it may not be drawn correctly. Moreover, the points must be defined in order; using a random order would result in an incorrect shape. Usage example: polygon = SF :: ConvexShape . new polygon . point_count = 3 polygon [ 0 ] = SF . vector2f ( 0 , 0 ) polygon [ 1 ] = SF . vector2f ( 0 , 10 ) polygon [ 2 ] = SF . vector2f ( 25 , 5 ) polygon . outline_color = SF :: Color :: Red polygon . outline_thickness = 5 polygon . position = { 10 , 20 } ... window . draw polygon See also: SF::Shape , SF::RectangleShape , SF::CircleShape","title":"ConvexShape"},{"location":"api/SF/ConvexShape.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/ConvexShape.html#SF::ConvexShape.new(point_count)","text":"Default constructor point_count - Number of points of the polygon [ View source ]","title":".new"},{"location":"api/SF/ConvexShape.html#methods","text":"","title":"Methods"},{"location":"api/SF/ConvexShape.html#SF::ConvexShape#[](index)","text":"Shorthand for get_point [ View source ]","title":"#[]"},{"location":"api/SF/ConvexShape.html#SF::ConvexShape#[]=(index,point)","text":"Shorthand for set_point [ View source ]","title":"#[]="},{"location":"api/SF/ConvexShape.html#SF::ConvexShape#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/ConvexShape.html#SF::ConvexShape#finalize()","text":"Virtual destructor [ View source ]","title":"#finalize"},{"location":"api/SF/ConvexShape.html#SF::ConvexShape#get_point(index)","text":"Get the position of a point The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0 ... point_count Returns: Position of the index-th point of the polygon See also: point= [ View source ]","title":"#get_point"},{"location":"api/SF/ConvexShape.html#SF::ConvexShape#point_count()","text":"Get the number of points of the polygon Returns: Number of points of the polygon See also: point_count= [ View source ]","title":"#point_count"},{"location":"api/SF/ConvexShape.html#SF::ConvexShape#point_count=(count)","text":"Set the number of points of the polygon count must be greater than 2 to define a valid shape. count - New number of points of the polygon See also: point_count [ View source ]","title":"#point_count="},{"location":"api/SF/ConvexShape.html#SF::ConvexShape#set_point(index,point)","text":"Set the position of a point Don't forget that the polygon must remain convex, and the points need to stay ordered! point_count= must be called first in order to set the total number of points. The result is undefined if index is out of the valid range. index - Index of the point to change, in range 0 ... point_count point - New position of the point See also: point [ View source ]","title":"#set_point"},{"location":"api/SF/Cursor.html","text":"class SF::Cursor inherits Reference # Cursor defines the appearance of a system cursor Warning: Features related to Cursor are not supported on iOS and Android. This class abstracts the operating system resources associated with either a native system cursor or a custom cursor. After loading the cursor the graphical appearance with either load_from_pixels() or load_from_system(), the cursor can be changed with SF::Window.mouse_cursor=() . The behaviour is undefined if the cursor is destroyed while in use by the window. Usage example: sf :: Window window ; // ... create window as usual ... sf :: Cursor cursor ; if ( cursor . loadFromSystem ( sf :: Cursor :: Hand )) window . setMouseCursor ( cursor ); See also: SF::Window.mouse_cursor= Included modules # SF::NonCopyable Class methods # .from_pixels ( * args , ** kwargs ) : self # Shorthand for cursor = Cursor.new; cursor.load_from_pixels(...); cursor Raises InitError on failure [ View source ] .from_system ( * args , ** kwargs ) : self # Shorthand for cursor = Cursor.new; cursor.load_from_system(...); cursor Raises InitError on failure [ View source ] .new # Default constructor This constructor doesn't actually create the cursor; initially the new instance is invalid and must not be used until either load_from_pixels() or load_from_system() is called and successfully created a cursor. [ View source ] Methods # #finalize # Destructor This destructor releases the system resources associated with this cursor, if any. [ View source ] #load_from_pixels ( pixels : Pointer ( UInt8 ), size : Vector2 | Tuple , hotspot : Vector2 | Tuple ) : Bool # Create a cursor with the provided image pixels must be an array of width by height pixels in 32-bit RGBA format. If not, this will cause undefined behavior. If pixels is null or either width or height are 0, the current cursor is left unchanged and the function will return false. In addition to specifying the pixel data, you can also specify the location of the hotspot of the cursor. The hotspot is the pixel coordinate within the cursor image which will be located exactly where the mouse pointer position is. Any mouse actions that are performed will return the window/screen location of the hotspot. Warning: On Unix, the pixels are mapped into a monochrome bitmap: pixels with an alpha channel to 0 are transparent, black if the RGB channel are close to zero, and white otherwise. pixels - Array of pixels of the image size - Width and height of the image hotspot - (x,y) location of the hotspot Returns: true if the cursor was successfully loaded; false otherwise [ View source ] #load_from_system ( type : Cursor :: Type ) : Bool # Create a native system cursor Refer to the list of cursor available on each system (see SF::Cursor::Type ) to know whether a given cursor is expected to load successfully or is not supported by the operating system. type - Native system cursor type Returns: true if and only if the corresponding cursor is natively supported by the operating system; false otherwise [ View source ]","title":"Cursor"},{"location":"api/SF/Cursor.html#SF::Cursor","text":"Cursor defines the appearance of a system cursor Warning: Features related to Cursor are not supported on iOS and Android. This class abstracts the operating system resources associated with either a native system cursor or a custom cursor. After loading the cursor the graphical appearance with either load_from_pixels() or load_from_system(), the cursor can be changed with SF::Window.mouse_cursor=() . The behaviour is undefined if the cursor is destroyed while in use by the window. Usage example: sf :: Window window ; // ... create window as usual ... sf :: Cursor cursor ; if ( cursor . loadFromSystem ( sf :: Cursor :: Hand )) window . setMouseCursor ( cursor ); See also: SF::Window.mouse_cursor=","title":"Cursor"},{"location":"api/SF/Cursor.html#included-modules","text":"SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Cursor.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Cursor.html#SF::Cursor.from_pixels(*args,**kwargs)","text":"Shorthand for cursor = Cursor.new; cursor.load_from_pixels(...); cursor Raises InitError on failure [ View source ]","title":".from_pixels"},{"location":"api/SF/Cursor.html#SF::Cursor.from_system(*args,**kwargs)","text":"Shorthand for cursor = Cursor.new; cursor.load_from_system(...); cursor Raises InitError on failure [ View source ]","title":".from_system"},{"location":"api/SF/Cursor.html#SF::Cursor.new()","text":"Default constructor This constructor doesn't actually create the cursor; initially the new instance is invalid and must not be used until either load_from_pixels() or load_from_system() is called and successfully created a cursor. [ View source ]","title":".new"},{"location":"api/SF/Cursor.html#methods","text":"","title":"Methods"},{"location":"api/SF/Cursor.html#SF::Cursor#finalize()","text":"Destructor This destructor releases the system resources associated with this cursor, if any. [ View source ]","title":"#finalize"},{"location":"api/SF/Cursor.html#SF::Cursor#load_from_pixels(pixels,size,hotspot)","text":"Create a cursor with the provided image pixels must be an array of width by height pixels in 32-bit RGBA format. If not, this will cause undefined behavior. If pixels is null or either width or height are 0, the current cursor is left unchanged and the function will return false. In addition to specifying the pixel data, you can also specify the location of the hotspot of the cursor. The hotspot is the pixel coordinate within the cursor image which will be located exactly where the mouse pointer position is. Any mouse actions that are performed will return the window/screen location of the hotspot. Warning: On Unix, the pixels are mapped into a monochrome bitmap: pixels with an alpha channel to 0 are transparent, black if the RGB channel are close to zero, and white otherwise. pixels - Array of pixels of the image size - Width and height of the image hotspot - (x,y) location of the hotspot Returns: true if the cursor was successfully loaded; false otherwise [ View source ]","title":"#load_from_pixels"},{"location":"api/SF/Cursor.html#SF::Cursor#load_from_system(type)","text":"Create a native system cursor Refer to the list of cursor available on each system (see SF::Cursor::Type ) to know whether a given cursor is expected to load successfully or is not supported by the operating system. type - Native system cursor type Returns: true if and only if the corresponding cursor is natively supported by the operating system; false otherwise [ View source ]","title":"#load_from_system"},{"location":"api/SF/Drawable.html","text":"module SF::Drawable # Abstract module for objects that can be drawn to a render target SF::Drawable is a very simple module that allows objects of derived classes to be drawn to a SF::RenderTarget . All you have to do in your derived class is to implement the draw function. Note that including SF::Drawable is not mandatory, but it allows this nice syntax window.draw(object) rather than object.draw(window) , which is more consistent with other SFML classes. Example: class MyDrawable include SF :: Drawable def draw ( target : SF :: RenderTarget , states : SF :: RenderStates ) # You can draw other high-level objects target . draw ( @sprite , states ) # ... or use the low-level API states . texture = @texture target . draw ( @vertices , states ) # ... or draw with OpenGL directly glBegin ( GL_QUADS ) ... glEnd () end @sprite : SF :: Sprite @texture : SF :: Texture @vertices : SF :: VertexArray end See also: SF::RenderTarget Direct including types # SF::Shape SF::Sprite SF::Text SF::VertexArray SF::VertexBuffer Methods # abstract #draw ( target : RenderTarget , states : RenderStates ) # Draw the object to a render target. This is an abstract method that has to be implemented by the including class to define how the drawable should be drawn. * target - Render target to draw to * states - Current render states [ View source ]","title":"Drawable"},{"location":"api/SF/Drawable.html#SF::Drawable","text":"Abstract module for objects that can be drawn to a render target SF::Drawable is a very simple module that allows objects of derived classes to be drawn to a SF::RenderTarget . All you have to do in your derived class is to implement the draw function. Note that including SF::Drawable is not mandatory, but it allows this nice syntax window.draw(object) rather than object.draw(window) , which is more consistent with other SFML classes. Example: class MyDrawable include SF :: Drawable def draw ( target : SF :: RenderTarget , states : SF :: RenderStates ) # You can draw other high-level objects target . draw ( @sprite , states ) # ... or use the low-level API states . texture = @texture target . draw ( @vertices , states ) # ... or draw with OpenGL directly glBegin ( GL_QUADS ) ... glEnd () end @sprite : SF :: Sprite @texture : SF :: Texture @vertices : SF :: VertexArray end See also: SF::RenderTarget","title":"Drawable"},{"location":"api/SF/Drawable.html#direct-including-types","text":"SF::Shape SF::Sprite SF::Text SF::VertexArray SF::VertexBuffer","title":"Direct including types"},{"location":"api/SF/Drawable.html#methods","text":"","title":"Methods"},{"location":"api/SF/Drawable.html#SF::Drawable#draw(target,states)","text":"Draw the object to a render target. This is an abstract method that has to be implemented by the including class to define how the drawable should be drawn. * target - Render target to draw to * states - Current render states [ View source ]","title":"#draw"},{"location":"api/SF/Event.html","text":"abstract struct SF::Event inherits Struct # Defines a system event and its parameters SF::Event holds all the informations about a system event that just happened. Events are retrieved using the SF::Window.poll_event and SF::Window.wait_event functions. A SF::Event instance contains the type of the event (mouse moved, key pressed, window closed, ...) as well as the details about this particular event. Please note that the event parameters are defined in a union, which means that only the member matching the type of the event will be properly filled; all other members will have undefined values and must not be read if the type of the event doesn't match. For example, if you received a KeyPressed event, then you must read the event.key member, all other members such as event.mouse_move or event.text will have undefined values. Usage example: while ( event = window . poll_event ()) case event # Request for closing the window when SF :: Event :: Closed window . close () # The escape key was pressed when SF :: Event :: KeyPressed if event . code == SF :: Keyboard :: Escape window . close () end # The window was resized when SF :: Event :: Resized do_something ( event . width , event . height ) # etc ... end end Direct known subclasses # SF::Event::Closed SF::Event::GainedFocus SF::Event::JoystickButtonEvent SF::Event::JoystickConnectEvent SF::Event::JoystickMoveEvent SF::Event::KeyEvent SF::Event::LostFocus SF::Event::MouseButtonEvent SF::Event::MouseEntered SF::Event::MouseLeft SF::Event::MouseMoveEvent SF::Event::MouseWheelEvent SF::Event::MouseWheelScrollEvent SF::Event::SensorEvent SF::Event::SizeEvent SF::Event::TextEvent SF::Event::TouchEvent Class methods # .new # [ View source ]","title":"Event"},{"location":"api/SF/Event.html#SF::Event","text":"Defines a system event and its parameters SF::Event holds all the informations about a system event that just happened. Events are retrieved using the SF::Window.poll_event and SF::Window.wait_event functions. A SF::Event instance contains the type of the event (mouse moved, key pressed, window closed, ...) as well as the details about this particular event. Please note that the event parameters are defined in a union, which means that only the member matching the type of the event will be properly filled; all other members will have undefined values and must not be read if the type of the event doesn't match. For example, if you received a KeyPressed event, then you must read the event.key member, all other members such as event.mouse_move or event.text will have undefined values. Usage example: while ( event = window . poll_event ()) case event # Request for closing the window when SF :: Event :: Closed window . close () # The escape key was pressed when SF :: Event :: KeyPressed if event . code == SF :: Keyboard :: Escape window . close () end # The window was resized when SF :: Event :: Resized do_something ( event . width , event . height ) # etc ... end end","title":"Event"},{"location":"api/SF/Event.html#direct-known-subclasses","text":"SF::Event::Closed SF::Event::GainedFocus SF::Event::JoystickButtonEvent SF::Event::JoystickConnectEvent SF::Event::JoystickMoveEvent SF::Event::KeyEvent SF::Event::LostFocus SF::Event::MouseButtonEvent SF::Event::MouseEntered SF::Event::MouseLeft SF::Event::MouseMoveEvent SF::Event::MouseWheelEvent SF::Event::MouseWheelScrollEvent SF::Event::SensorEvent SF::Event::SizeEvent SF::Event::TextEvent SF::Event::TouchEvent","title":"Direct known subclasses"},{"location":"api/SF/Event.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event.html#SF::Event.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/FileInputStream.html","text":"class SF::FileInputStream inherits SF::InputStream # Implementation of input stream based on a file This class is a specialization of InputStream that reads from a file on disk. It wraps a file in the common InputStream interface and therefore allows to use generic classes or functions that accept such a stream, with a file on disk as the data source. In addition to the virtual functions inherited from InputStream, FileInputStream adds a function to specify the file to open. SFML resource classes can usually be loaded directly from a filename, so this class shouldn't be useful to you unless you create your own algorithms that operate on an InputStream. Usage example: def process ( stream : InputStream ) end stream = SF :: FileInputStream . open ( \"some_file.dat\" ) process ( stream ) InputStream, MemoryInputStream Included modules # SF::NonCopyable Class methods # .new # Default constructor [ View source ] .open ( * args , ** kwargs ) : self # Shorthand for file_input_stream = FileInputStream.new; file_input_stream.open(...); file_input_stream Raises InitError on failure [ View source ] Methods # #finalize # Default destructor [ View source ] #open ( filename : String ) : Bool # Open the stream from a file path filename - Name of the file to open Returns: True on success, false on error [ View source ] #read ( data : Slice ) : Int64 # Read data from the stream After reading, the stream's reading position must be advanced by the amount of bytes read. data - Buffer where to copy the read data Returns: The number of bytes actually read, or -1 on error [ View source ] #seek ( position : Int ) : Int64 # Change the current reading position position - The position to seek to, from the beginning Returns: The position actually sought to, or -1 on error [ View source ] #size : Int64 # Return the size of the stream Returns: The total number of bytes available in the stream, or -1 on error [ View source ] #tell : Int64 # Get the current reading position in the stream Returns: The current position, or -1 on error. [ View source ]","title":"FileInputStream"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream","text":"Implementation of input stream based on a file This class is a specialization of InputStream that reads from a file on disk. It wraps a file in the common InputStream interface and therefore allows to use generic classes or functions that accept such a stream, with a file on disk as the data source. In addition to the virtual functions inherited from InputStream, FileInputStream adds a function to specify the file to open. SFML resource classes can usually be loaded directly from a filename, so this class shouldn't be useful to you unless you create your own algorithms that operate on an InputStream. Usage example: def process ( stream : InputStream ) end stream = SF :: FileInputStream . open ( \"some_file.dat\" ) process ( stream ) InputStream, MemoryInputStream","title":"FileInputStream"},{"location":"api/SF/FileInputStream.html#included-modules","text":"SF::NonCopyable","title":"Included modules"},{"location":"api/SF/FileInputStream.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream.open(*args,**kwargs)","text":"Shorthand for file_input_stream = FileInputStream.new; file_input_stream.open(...); file_input_stream Raises InitError on failure [ View source ]","title":".open"},{"location":"api/SF/FileInputStream.html#methods","text":"","title":"Methods"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream#finalize()","text":"Default destructor [ View source ]","title":"#finalize"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream#open(filename)","text":"Open the stream from a file path filename - Name of the file to open Returns: True on success, false on error [ View source ]","title":"#open"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream#read(data)","text":"Read data from the stream After reading, the stream's reading position must be advanced by the amount of bytes read. data - Buffer where to copy the read data Returns: The number of bytes actually read, or -1 on error [ View source ]","title":"#read"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream#seek(position)","text":"Change the current reading position position - The position to seek to, from the beginning Returns: The position actually sought to, or -1 on error [ View source ]","title":"#seek"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream#size()","text":"Return the size of the stream Returns: The total number of bytes available in the stream, or -1 on error [ View source ]","title":"#size"},{"location":"api/SF/FileInputStream.html#SF::FileInputStream#tell()","text":"Get the current reading position in the stream Returns: The current position, or -1 on error. [ View source ]","title":"#tell"},{"location":"api/SF/FloatRect.html","text":"alias SF::FloatRect # Alias definition # SF :: Rect ( Float32 )","title":"FloatRect"},{"location":"api/SF/FloatRect.html#SF::FloatRect","text":"","title":"FloatRect"},{"location":"api/SF/FloatRect.html#alias-definition","text":"SF :: Rect ( Float32 )","title":"Alias definition"},{"location":"api/SF/Font.html","text":"class SF::Font inherits Reference # Class for loading and manipulating character fonts Fonts can be loaded from a file, from memory or from a custom stream, and supports the most common types of fonts. See the load_from_file function for the complete list of supported formats. Once it is loaded, a SF::Font instance provides three types of information about the font: Global metrics, such as the line spacing Per-glyph metrics, such as bounding box or kerning Pixel representation of glyphs Fonts alone are not very useful: they hold the font data but cannot make anything useful of it. To do so you need to use the SF::Text class, which is able to properly output text with several options such as character size, style, color, position, rotation, etc. This separation allows more flexibility and better performances: indeed a SF::Font is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a SF::Text is a lightweight object which can combine the glyphs data and metrics of a SF::Font to display any text on a render target. Note that it is also possible to bind several SF::Text instances to the same SF::Font . It is important to note that the SF::Text instance doesn't copy the font that it uses, it only keeps a reference to it. Thus, a SF::Font must not be destructed while it is used by a SF::Text (i.e. never write a function that uses a local SF::Font instance for creating a text). Usage example: # Load a new font from file font = SF :: Font . from_file ( \"arial.ttf\" ) # Create a text which uses our font text1 = SF :: Text . new ( \"text\" , font , 30 ) # Create another text using the same font, but with different parameters text2 = SF :: Text . new text2 . font = font text2 . character_size = 50 text2 . style = SF :: Text :: Italic Apart from loading font files, and passing them to instances of SF::Text , you should normally not have to deal directly with this class. However, it may be useful to access the font metrics or rasterized glyphs for advanced usage. Note that if the font is a bitmap font, it is not scalable, thus not all requested sizes will be available to use. This needs to be taken into consideration when using SF::Text . If you need to display text of a certain size, make sure the corresponding bitmap font that supports that size is used. See also: SF::Text Class methods # .from_file ( * args , ** kwargs ) : self # Shorthand for font = Font.new; font.load_from_file(...); font Raises InitError on failure [ View source ] .from_memory ( * args , ** kwargs ) : self # Shorthand for font = Font.new; font.load_from_memory(...); font Raises InitError on failure [ View source ] .from_stream ( * args , ** kwargs ) : self # Shorthand for font = Font.new; font.load_from_stream(...); font Raises InitError on failure [ View source ] .new # Default constructor This constructor defines an empty font [ View source ] Methods # #dup : Font # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Destructor Cleans up all the internal resources used by the font [ View source ] #get_glyph ( code_point : Int , character_size : Int , bold : Bool , outline_thickness : Number = 0 ) : Glyph # Retrieve a glyph of the font If the font is a bitmap font, not all character sizes might be available. If the glyph is not available at the requested size, an empty glyph is returned. Be aware that using a negative value for the outline thickness will cause distorted rendering. code_point - Unicode code point of the character to get character_size - Reference character size bold - Retrieve the bold version or the regular one? outline_thickness - Thickness of outline (when != 0 the glyph will not be filled) Returns: The glyph corresponding to code_point and character_size [ View source ] #get_kerning ( first : Int , second : Int , character_size : Int ) : Float32 # Get the kerning offset of two glyphs The kerning is an extra offset (negative) to apply between two glyphs when rendering them, to make the pair look more \"natural\". For example, the pair \"AV\" have a special kerning to make them closer than other characters. Most of the glyphs pairs have a kerning offset of zero, though. first - Unicode code point of the first character second - Unicode code point of the second character character_size - Reference character size Returns: Kerning value for first and second, in pixels [ View source ] #get_line_spacing ( character_size : Int ) : Float32 # Get the line spacing Line spacing is the vertical offset to apply between two consecutive lines of text. character_size - Reference character size Returns: Line spacing, in pixels [ View source ] #get_texture ( character_size : Int ) : Texture # Retrieve the texture containing the loaded glyphs of a certain size The contents of the returned texture changes as more glyphs are requested, thus it is not very relevant. It is mainly used internally by SF::Text . character_size - Reference character size Returns: Texture containing the glyphs of the requested size [ View source ] #get_underline_position ( character_size : Int ) : Float32 # Get the position of the underline Underline position is the vertical offset to apply between the baseline and the underline. character_size - Reference character size Returns: Underline position, in pixels See also: underline_thickness [ View source ] #get_underline_thickness ( character_size : Int ) : Float32 # Get the thickness of the underline Underline thickness is the vertical size of the underline. character_size - Reference character size Returns: Underline thickness, in pixels See also: underline_position [ View source ] #info : Font :: Info # Get the font information Returns: A structure that holds the font information [ View source ] #load_from_file ( filename : String ) : Bool # Load the font from a file The supported font formats are: TrueType, Type 1, CFF, OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR and Type 42. Note that this function knows nothing about the standard fonts installed on the user's system, thus you can't load them directly. Warning: SFML cannot preload all the font data in this function, so the file has to remain accessible until the SF::Font object loads a new font or is destroyed. filename - Path of the font file to load Returns: True if loading succeeded, false if it failed See also: load_from_memory , load_from_stream [ View source ] #load_from_memory ( data : Slice ) : Bool # Load the font from a file in memory The supported font formats are: TrueType, Type 1, CFF, OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR and Type 42. Warning: SFML cannot preload all the font data in this function, so the buffer pointed by data has to remain valid until the SF::Font object loads a new font or is destroyed. data - Slice containing the file data in memory Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_stream [ View source ] #load_from_stream ( stream : InputStream ) : Bool # Load the font from a custom stream The supported font formats are: TrueType, Type 1, CFF, OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR and Type 42. Warning: SFML cannot preload all the font data in this function, so the contents of stream have to remain valid as long as the font is used. Warning: SFML cannot preload all the font data in this function, so the stream has to remain accessible until the SF::Font object loads a new font or is destroyed. stream - Source stream to read from Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory [ View source ]","title":"Font"},{"location":"api/SF/Font.html#SF::Font","text":"Class for loading and manipulating character fonts Fonts can be loaded from a file, from memory or from a custom stream, and supports the most common types of fonts. See the load_from_file function for the complete list of supported formats. Once it is loaded, a SF::Font instance provides three types of information about the font: Global metrics, such as the line spacing Per-glyph metrics, such as bounding box or kerning Pixel representation of glyphs Fonts alone are not very useful: they hold the font data but cannot make anything useful of it. To do so you need to use the SF::Text class, which is able to properly output text with several options such as character size, style, color, position, rotation, etc. This separation allows more flexibility and better performances: indeed a SF::Font is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a SF::Text is a lightweight object which can combine the glyphs data and metrics of a SF::Font to display any text on a render target. Note that it is also possible to bind several SF::Text instances to the same SF::Font . It is important to note that the SF::Text instance doesn't copy the font that it uses, it only keeps a reference to it. Thus, a SF::Font must not be destructed while it is used by a SF::Text (i.e. never write a function that uses a local SF::Font instance for creating a text). Usage example: # Load a new font from file font = SF :: Font . from_file ( \"arial.ttf\" ) # Create a text which uses our font text1 = SF :: Text . new ( \"text\" , font , 30 ) # Create another text using the same font, but with different parameters text2 = SF :: Text . new text2 . font = font text2 . character_size = 50 text2 . style = SF :: Text :: Italic Apart from loading font files, and passing them to instances of SF::Text , you should normally not have to deal directly with this class. However, it may be useful to access the font metrics or rasterized glyphs for advanced usage. Note that if the font is a bitmap font, it is not scalable, thus not all requested sizes will be available to use. This needs to be taken into consideration when using SF::Text . If you need to display text of a certain size, make sure the corresponding bitmap font that supports that size is used. See also: SF::Text","title":"Font"},{"location":"api/SF/Font.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Font.html#SF::Font.from_file(*args,**kwargs)","text":"Shorthand for font = Font.new; font.load_from_file(...); font Raises InitError on failure [ View source ]","title":".from_file"},{"location":"api/SF/Font.html#SF::Font.from_memory(*args,**kwargs)","text":"Shorthand for font = Font.new; font.load_from_memory(...); font Raises InitError on failure [ View source ]","title":".from_memory"},{"location":"api/SF/Font.html#SF::Font.from_stream(*args,**kwargs)","text":"Shorthand for font = Font.new; font.load_from_stream(...); font Raises InitError on failure [ View source ]","title":".from_stream"},{"location":"api/SF/Font.html#SF::Font.new()","text":"Default constructor This constructor defines an empty font [ View source ]","title":".new"},{"location":"api/SF/Font.html#methods","text":"","title":"Methods"},{"location":"api/SF/Font.html#SF::Font#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Font.html#SF::Font#finalize()","text":"Destructor Cleans up all the internal resources used by the font [ View source ]","title":"#finalize"},{"location":"api/SF/Font.html#SF::Font#get_glyph(code_point,character_size,bold,outline_thickness)","text":"Retrieve a glyph of the font If the font is a bitmap font, not all character sizes might be available. If the glyph is not available at the requested size, an empty glyph is returned. Be aware that using a negative value for the outline thickness will cause distorted rendering. code_point - Unicode code point of the character to get character_size - Reference character size bold - Retrieve the bold version or the regular one? outline_thickness - Thickness of outline (when != 0 the glyph will not be filled) Returns: The glyph corresponding to code_point and character_size [ View source ]","title":"#get_glyph"},{"location":"api/SF/Font.html#SF::Font#get_kerning(first,second,character_size)","text":"Get the kerning offset of two glyphs The kerning is an extra offset (negative) to apply between two glyphs when rendering them, to make the pair look more \"natural\". For example, the pair \"AV\" have a special kerning to make them closer than other characters. Most of the glyphs pairs have a kerning offset of zero, though. first - Unicode code point of the first character second - Unicode code point of the second character character_size - Reference character size Returns: Kerning value for first and second, in pixels [ View source ]","title":"#get_kerning"},{"location":"api/SF/Font.html#SF::Font#get_line_spacing(character_size)","text":"Get the line spacing Line spacing is the vertical offset to apply between two consecutive lines of text. character_size - Reference character size Returns: Line spacing, in pixels [ View source ]","title":"#get_line_spacing"},{"location":"api/SF/Font.html#SF::Font#get_texture(character_size)","text":"Retrieve the texture containing the loaded glyphs of a certain size The contents of the returned texture changes as more glyphs are requested, thus it is not very relevant. It is mainly used internally by SF::Text . character_size - Reference character size Returns: Texture containing the glyphs of the requested size [ View source ]","title":"#get_texture"},{"location":"api/SF/Font.html#SF::Font#get_underline_position(character_size)","text":"Get the position of the underline Underline position is the vertical offset to apply between the baseline and the underline. character_size - Reference character size Returns: Underline position, in pixels See also: underline_thickness [ View source ]","title":"#get_underline_position"},{"location":"api/SF/Font.html#SF::Font#get_underline_thickness(character_size)","text":"Get the thickness of the underline Underline thickness is the vertical size of the underline. character_size - Reference character size Returns: Underline thickness, in pixels See also: underline_position [ View source ]","title":"#get_underline_thickness"},{"location":"api/SF/Font.html#SF::Font#info()","text":"Get the font information Returns: A structure that holds the font information [ View source ]","title":"#info"},{"location":"api/SF/Font.html#SF::Font#load_from_file(filename)","text":"Load the font from a file The supported font formats are: TrueType, Type 1, CFF, OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR and Type 42. Note that this function knows nothing about the standard fonts installed on the user's system, thus you can't load them directly. Warning: SFML cannot preload all the font data in this function, so the file has to remain accessible until the SF::Font object loads a new font or is destroyed. filename - Path of the font file to load Returns: True if loading succeeded, false if it failed See also: load_from_memory , load_from_stream [ View source ]","title":"#load_from_file"},{"location":"api/SF/Font.html#SF::Font#load_from_memory(data)","text":"Load the font from a file in memory The supported font formats are: TrueType, Type 1, CFF, OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR and Type 42. Warning: SFML cannot preload all the font data in this function, so the buffer pointed by data has to remain valid until the SF::Font object loads a new font or is destroyed. data - Slice containing the file data in memory Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_stream [ View source ]","title":"#load_from_memory"},{"location":"api/SF/Font.html#SF::Font#load_from_stream(stream)","text":"Load the font from a custom stream The supported font formats are: TrueType, Type 1, CFF, OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR and Type 42. Warning: SFML cannot preload all the font data in this function, so the contents of stream have to remain valid as long as the font is used. Warning: SFML cannot preload all the font data in this function, so the stream has to remain accessible until the SF::Font object loads a new font or is destroyed. stream - Source stream to read from Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory [ View source ]","title":"#load_from_stream"},{"location":"api/SF/Ftp.html","text":"class SF::Ftp inherits Reference # A FTP client SF::Ftp is a very simple FTP client that allows you to communicate with a FTP server. The FTP protocol allows you to manipulate a remote file system (list files, upload, download, create, remove, ...). Using the FTP client consists of 4 parts: Connecting to the FTP server Logging in (either as a registered user or anonymously) Sending commands to the server Disconnecting (this part can be done implicitly by the destructor) Every command returns a FTP response, which contains the status code as well as a message from the server. Some commands such as working_directory() and directory_listing() return additional data, and use a class derived from SF::Ftp::Response to provide this data. The most often used commands are directly provided as member functions, but it is also possible to use specific commands with the send_command() function. Note that response statuses >= 1000 are not part of the FTP standard, they are generated by SFML when an internal error occurs. All commands, especially upload and download, may take some time to complete. This is important to know if you don't want to block your application while the server is completing the task. Usage example: # Create a new FTP client ftp = SF :: Ftp . new # Connect to the server response = ftp . connect ( \"ftp://ftp.myserver.com\" ) if response . ok? puts \"Connected\" end # Log in response = ftp . login ( \"laurent\" , \"dF6Zm89D\" ) if response . ok? puts \"Logged in\" end # Print the working directory directory = ftp . working_directory () if directory . ok? puts \"Working directory: #{ directory . directory } \" end # Create a new directory response = ftp . create_directory \"files\" if response . ok? puts \"Created new directory\" end # Upload a file to this new directory response = ftp . upload ( \"local-path/file.txt\" , \"files\" , SF :: Ftp :: Ascii ) if response . ok? ) puts \"File uploaded\" end # Send specific commands (here: FEAT to list supported FTP features) response = ftp . send_command \"FEAT\" if response . ok? puts \"Feature list: \\n #{ response . message } \" end # Disconnect from the server ftp . disconnect () Included modules # SF::NonCopyable Class methods # .new # [ View source ] Methods # #change_directory ( directory : String ) : Ftp :: Response # Change the current working directory The new directory must be relative to the current one. directory - New working directory Returns: Server response to the request See also: working_directory , directory_listing , parent_directory [ View source ] #connect ( server : IpAddress , port : Int = 21 , timeout : Time = Time :: Zero ) : Ftp :: Response # Connect to the specified FTP server The port has a default value of 21, which is the standard port used by the FTP protocol. You shouldn't use a different value, unless you really know what you do. This function tries to connect to the server so it may take a while to complete, especially if the server is not reachable. To avoid blocking your application for too long, you can use a timeout. The default value, Time::Zero, means that the system timeout will be used (which is usually pretty long). server - Name or address of the FTP server to connect to port - Port used for the connection timeout - Maximum time to wait Returns: Server response to the request See also: disconnect [ View source ] #create_directory ( name : String ) : Ftp :: Response # Create a new directory The new directory is created as a child of the current working directory. name - Name of the directory to create Returns: Server response to the request See also: delete_directory [ View source ] #delete_directory ( name : String ) : Ftp :: Response # Remove an existing directory The directory to remove must be relative to the current working directory. Use this function with caution, the directory will be removed permanently! name - Name of the directory to remove Returns: Server response to the request See also: create_directory [ View source ] #delete_file ( name : String ) : Ftp :: Response # Remove an existing file The file name must be relative to the current working directory. Use this function with caution, the file will be removed permanently! name - File to remove Returns: Server response to the request See also: rename_file [ View source ] #disconnect : Ftp :: Response # Close the connection with the server Returns: Server response to the request See also: connect [ View source ] #download ( remote_file : String , local_path : String , mode : Ftp :: TransferMode = Binary ) : Ftp :: Response # Download a file from the server The filename of the distant file is relative to the current working directory of the server, and the local destination path is relative to the current directory of your application. If a file with the same filename as the distant file already exists in the local destination path, it will be overwritten. remote_file - Filename of the distant file to download local_path - The directory in which to put the file on the local computer mode - Transfer mode Returns: Server response to the request See also: upload [ View source ] #finalize # Destructor Automatically closes the connection with the server if it is still opened. [ View source ] #get_directory_listing ( directory : String = \"\" ) : Ftp :: ListingResponse # Get the contents of the given directory This function retrieves the sub-directories and files contained in the given directory. It is not recursive. The directory parameter is relative to the current working directory. directory - Directory to list Returns: Server response to the request See also: working_directory , change_directory , parent_directory [ View source ] #keep_alive : Ftp :: Response # Send a null command to keep the connection alive This command is useful because the server may close the connection automatically if no command is sent. Returns: Server response to the request [ View source ] #login : Ftp :: Response # Log in using an anonymous account Logging in is mandatory after connecting to the server. Users that are not logged in cannot perform any operation. Returns: Server response to the request [ View source ] #login ( name : String , password : String ) : Ftp :: Response # Log in using a username and a password Logging in is mandatory after connecting to the server. Users that are not logged in cannot perform any operation. name - User name password - Password Returns: Server response to the request [ View source ] #parent_directory : Ftp :: Response # Go to the parent directory of the current one Returns: Server response to the request See also: working_directory , directory_listing , change_directory [ View source ] #rename_file ( file : String , new_name : String ) : Ftp :: Response # Rename an existing file The filenames must be relative to the current working directory. file - File to rename new_name - New name of the file Returns: Server response to the request See also: delete_file [ View source ] #send_command ( command : String , parameter : String = \"\" ) : Ftp :: Response # Send a command to the FTP server While the most often used commands are provided as member functions in the SF::Ftp class, this method can be used to send any FTP command to the server. If the command requires one or more parameters, they can be specified in parameter. If the server returns information, you can extract it from the response using Response.message(). command - Command to send parameter - Command parameter Returns: Server response to the request [ View source ] #upload ( local_file : String , remote_path : String , mode : Ftp :: TransferMode = Binary , append : Bool = false ) : Ftp :: Response # Upload a file to the server The name of the local file is relative to the current working directory of your application, and the remote path is relative to the current directory of the FTP server. The append parameter controls whether the remote file is appended to or overwritten if it already exists. local_file - Path of the local file to upload remote_path - The directory in which to put the file on the server mode - Transfer mode append - Pass true to append to or false to overwrite the remote file if it already exists Returns: Server response to the request See also: download [ View source ] #working_directory : Ftp :: DirectoryResponse # Get the current working directory The working directory is the root path for subsequent operations involving directories and/or filenames. Returns: Server response to the request See also: directory_listing , change_directory , parent_directory [ View source ]","title":"Ftp"},{"location":"api/SF/Ftp.html#SF::Ftp","text":"A FTP client SF::Ftp is a very simple FTP client that allows you to communicate with a FTP server. The FTP protocol allows you to manipulate a remote file system (list files, upload, download, create, remove, ...). Using the FTP client consists of 4 parts: Connecting to the FTP server Logging in (either as a registered user or anonymously) Sending commands to the server Disconnecting (this part can be done implicitly by the destructor) Every command returns a FTP response, which contains the status code as well as a message from the server. Some commands such as working_directory() and directory_listing() return additional data, and use a class derived from SF::Ftp::Response to provide this data. The most often used commands are directly provided as member functions, but it is also possible to use specific commands with the send_command() function. Note that response statuses >= 1000 are not part of the FTP standard, they are generated by SFML when an internal error occurs. All commands, especially upload and download, may take some time to complete. This is important to know if you don't want to block your application while the server is completing the task. Usage example: # Create a new FTP client ftp = SF :: Ftp . new # Connect to the server response = ftp . connect ( \"ftp://ftp.myserver.com\" ) if response . ok? puts \"Connected\" end # Log in response = ftp . login ( \"laurent\" , \"dF6Zm89D\" ) if response . ok? puts \"Logged in\" end # Print the working directory directory = ftp . working_directory () if directory . ok? puts \"Working directory: #{ directory . directory } \" end # Create a new directory response = ftp . create_directory \"files\" if response . ok? puts \"Created new directory\" end # Upload a file to this new directory response = ftp . upload ( \"local-path/file.txt\" , \"files\" , SF :: Ftp :: Ascii ) if response . ok? ) puts \"File uploaded\" end # Send specific commands (here: FEAT to list supported FTP features) response = ftp . send_command \"FEAT\" if response . ok? puts \"Feature list: \\n #{ response . message } \" end # Disconnect from the server ftp . disconnect ()","title":"Ftp"},{"location":"api/SF/Ftp.html#included-modules","text":"SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Ftp.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Ftp.html#SF::Ftp.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Ftp.html#methods","text":"","title":"Methods"},{"location":"api/SF/Ftp.html#SF::Ftp#change_directory(directory)","text":"Change the current working directory The new directory must be relative to the current one. directory - New working directory Returns: Server response to the request See also: working_directory , directory_listing , parent_directory [ View source ]","title":"#change_directory"},{"location":"api/SF/Ftp.html#SF::Ftp#connect(server,port,timeout)","text":"Connect to the specified FTP server The port has a default value of 21, which is the standard port used by the FTP protocol. You shouldn't use a different value, unless you really know what you do. This function tries to connect to the server so it may take a while to complete, especially if the server is not reachable. To avoid blocking your application for too long, you can use a timeout. The default value, Time::Zero, means that the system timeout will be used (which is usually pretty long). server - Name or address of the FTP server to connect to port - Port used for the connection timeout - Maximum time to wait Returns: Server response to the request See also: disconnect [ View source ]","title":"#connect"},{"location":"api/SF/Ftp.html#SF::Ftp#create_directory(name)","text":"Create a new directory The new directory is created as a child of the current working directory. name - Name of the directory to create Returns: Server response to the request See also: delete_directory [ View source ]","title":"#create_directory"},{"location":"api/SF/Ftp.html#SF::Ftp#delete_directory(name)","text":"Remove an existing directory The directory to remove must be relative to the current working directory. Use this function with caution, the directory will be removed permanently! name - Name of the directory to remove Returns: Server response to the request See also: create_directory [ View source ]","title":"#delete_directory"},{"location":"api/SF/Ftp.html#SF::Ftp#delete_file(name)","text":"Remove an existing file The file name must be relative to the current working directory. Use this function with caution, the file will be removed permanently! name - File to remove Returns: Server response to the request See also: rename_file [ View source ]","title":"#delete_file"},{"location":"api/SF/Ftp.html#SF::Ftp#disconnect()","text":"Close the connection with the server Returns: Server response to the request See also: connect [ View source ]","title":"#disconnect"},{"location":"api/SF/Ftp.html#SF::Ftp#download(remote_file,local_path,mode)","text":"Download a file from the server The filename of the distant file is relative to the current working directory of the server, and the local destination path is relative to the current directory of your application. If a file with the same filename as the distant file already exists in the local destination path, it will be overwritten. remote_file - Filename of the distant file to download local_path - The directory in which to put the file on the local computer mode - Transfer mode Returns: Server response to the request See also: upload [ View source ]","title":"#download"},{"location":"api/SF/Ftp.html#SF::Ftp#finalize()","text":"Destructor Automatically closes the connection with the server if it is still opened. [ View source ]","title":"#finalize"},{"location":"api/SF/Ftp.html#SF::Ftp#get_directory_listing(directory)","text":"Get the contents of the given directory This function retrieves the sub-directories and files contained in the given directory. It is not recursive. The directory parameter is relative to the current working directory. directory - Directory to list Returns: Server response to the request See also: working_directory , change_directory , parent_directory [ View source ]","title":"#get_directory_listing"},{"location":"api/SF/Ftp.html#SF::Ftp#keep_alive()","text":"Send a null command to keep the connection alive This command is useful because the server may close the connection automatically if no command is sent. Returns: Server response to the request [ View source ]","title":"#keep_alive"},{"location":"api/SF/Ftp.html#SF::Ftp#login()","text":"Log in using an anonymous account Logging in is mandatory after connecting to the server. Users that are not logged in cannot perform any operation. Returns: Server response to the request [ View source ]","title":"#login"},{"location":"api/SF/Ftp.html#SF::Ftp#parent_directory()","text":"Go to the parent directory of the current one Returns: Server response to the request See also: working_directory , directory_listing , change_directory [ View source ]","title":"#parent_directory"},{"location":"api/SF/Ftp.html#SF::Ftp#rename_file(file,new_name)","text":"Rename an existing file The filenames must be relative to the current working directory. file - File to rename new_name - New name of the file Returns: Server response to the request See also: delete_file [ View source ]","title":"#rename_file"},{"location":"api/SF/Ftp.html#SF::Ftp#send_command(command,parameter)","text":"Send a command to the FTP server While the most often used commands are provided as member functions in the SF::Ftp class, this method can be used to send any FTP command to the server. If the command requires one or more parameters, they can be specified in parameter. If the server returns information, you can extract it from the response using Response.message(). command - Command to send parameter - Command parameter Returns: Server response to the request [ View source ]","title":"#send_command"},{"location":"api/SF/Ftp.html#SF::Ftp#upload(local_file,remote_path,mode,append)","text":"Upload a file to the server The name of the local file is relative to the current working directory of your application, and the remote path is relative to the current directory of the FTP server. The append parameter controls whether the remote file is appended to or overwritten if it already exists. local_file - Path of the local file to upload remote_path - The directory in which to put the file on the server mode - Transfer mode append - Pass true to append to or false to overwrite the remote file if it already exists Returns: Server response to the request See also: download [ View source ]","title":"#upload"},{"location":"api/SF/Ftp.html#SF::Ftp#working_directory()","text":"Get the current working directory The working directory is the root path for subsequent operations involving directories and/or filenames. Returns: Server response to the request See also: directory_listing , change_directory , parent_directory [ View source ]","title":"#working_directory"},{"location":"api/SF/GlResource.html","text":"module SF::GlResource # Empty module that indicates the class requires an OpenGL context Direct including types # SF::Context SF::Shader SF::Texture SF::VertexBuffer SF::Window","title":"GlResource"},{"location":"api/SF/GlResource.html#SF::GlResource","text":"Empty module that indicates the class requires an OpenGL context","title":"GlResource"},{"location":"api/SF/GlResource.html#direct-including-types","text":"SF::Context SF::Shader SF::Texture SF::VertexBuffer SF::Window","title":"Direct including types"},{"location":"api/SF/Glyph.html","text":"struct SF::Glyph inherits Struct # Structure describing a glyph A glyph is the visual representation of a character. The SF::Glyph structure provides the information needed to handle the glyph: its coordinates in the font's texture its bounding rectangle the offset to apply to get the starting position of the next glyph See also: SF::Font Class methods # .new # Default constructor [ View source ] Methods # #advance : Float32 # Offset to move horizontally to the next character [ View source ] #advance= ( advance : Number ) # [ View source ] #bounds : FloatRect # Bounding rectangle of the glyph, in coordinates relative to the baseline [ View source ] #bounds= ( bounds : FloatRect ) # [ View source ] #dup : Glyph # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #texture_rect : IntRect # Texture coordinates of the glyph inside the font's texture [ View source ] #texture_rect= ( texture_rect : IntRect ) # [ View source ]","title":"Glyph"},{"location":"api/SF/Glyph.html#SF::Glyph","text":"Structure describing a glyph A glyph is the visual representation of a character. The SF::Glyph structure provides the information needed to handle the glyph: its coordinates in the font's texture its bounding rectangle the offset to apply to get the starting position of the next glyph See also: SF::Font","title":"Glyph"},{"location":"api/SF/Glyph.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Glyph.html#SF::Glyph.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/Glyph.html#methods","text":"","title":"Methods"},{"location":"api/SF/Glyph.html#SF::Glyph#advance()","text":"Offset to move horizontally to the next character [ View source ]","title":"#advance"},{"location":"api/SF/Glyph.html#SF::Glyph#advance=(advance)","text":"[ View source ]","title":"#advance="},{"location":"api/SF/Glyph.html#SF::Glyph#bounds()","text":"Bounding rectangle of the glyph, in coordinates relative to the baseline [ View source ]","title":"#bounds"},{"location":"api/SF/Glyph.html#SF::Glyph#bounds=(bounds)","text":"[ View source ]","title":"#bounds="},{"location":"api/SF/Glyph.html#SF::Glyph#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Glyph.html#SF::Glyph#texture_rect()","text":"Texture coordinates of the glyph inside the font's texture [ View source ]","title":"#texture_rect"},{"location":"api/SF/Glyph.html#SF::Glyph#texture_rect=(texture_rect)","text":"[ View source ]","title":"#texture_rect="},{"location":"api/SF/Http.html","text":"class SF::Http inherits Reference # A HTTP client SF::Http is a very simple HTTP client that allows you to communicate with a web server. You can retrieve web pages, send data to an interactive resource, download a remote file, etc. The HTTPS protocol is not supported. The HTTP client is split into 3 classes: SF::Http::Request SF::Http::Response SF::Http SF::Http::Request builds the request that will be sent to the server. A request is made of: a method (what you want to do) a target URI (usually the name of the web page or file) one or more header fields (options that you can pass to the server) an optional body (for POST requests) SF::Http::Response parse the response from the web server and provides getters to read them. The response contains: a status code header fields (that may be answers to the ones that you requested) a body, which contains the contents of the requested resource SF::Http provides a simple function, SendRequest, to send a SF::Http::Request and return the corresponding SF::Http::Response from the server. Usage example: # Create a new HTTP client http = SF :: Http . new ( \"http://www.sfml-dev.org\" ) # Prepare a request to get the 'features.php' page request = SF :: Http :: Request . new ( \"features.php\" ) # Send the request response = http . send_request request # Check the status code and display the result SF :: Http :: Response :: Status status = response . getStatus () if response . status == SF :: Http :: Response :: Ok puts response . body else puts \"Error #{ response . status } \" end Included modules # SF::NonCopyable Class methods # .new ( host : String , port : Int = 0 ) # Construct the HTTP client with the target host This is equivalent to calling host=(host, port). The port has a default value of 0, which means that the HTTP client will use the right port according to the protocol used (80 for HTTP). You should leave it like this unless you really need a port other than the standard one, or use an unknown protocol. host - Web server to connect to port - Port to use for connection [ View source ] .new # Default constructor [ View source ] Methods # #finalize # [ View source ] #send_request ( request : Http :: Request , timeout : Time = Time :: Zero ) : Http :: Response # Send a HTTP request and return the server's response. You must have a valid host before sending a request (see host=). Any missing mandatory header field in the request will be added with an appropriate value. Warning: this function waits for the server's response and may not return instantly; use a thread if you don't want to block your application, or use a timeout to limit the time to wait. A value of Time::Zero means that the client will use the system default timeout (which is usually pretty long). request - Request to send timeout - Maximum time to wait Returns: Server's response [ View source ] #set_host ( host : String , port : Int = 0 ) # Set the target host This function just stores the host address and port, it doesn't actually connect to it until you send a request. The port has a default value of 0, which means that the HTTP client will use the right port according to the protocol used (80 for HTTP). You should leave it like this unless you really need a port other than the standard one, or use an unknown protocol. host - Web server to connect to port - Port to use for connection [ View source ]","title":"Http"},{"location":"api/SF/Http.html#SF::Http","text":"A HTTP client SF::Http is a very simple HTTP client that allows you to communicate with a web server. You can retrieve web pages, send data to an interactive resource, download a remote file, etc. The HTTPS protocol is not supported. The HTTP client is split into 3 classes: SF::Http::Request SF::Http::Response SF::Http SF::Http::Request builds the request that will be sent to the server. A request is made of: a method (what you want to do) a target URI (usually the name of the web page or file) one or more header fields (options that you can pass to the server) an optional body (for POST requests) SF::Http::Response parse the response from the web server and provides getters to read them. The response contains: a status code header fields (that may be answers to the ones that you requested) a body, which contains the contents of the requested resource SF::Http provides a simple function, SendRequest, to send a SF::Http::Request and return the corresponding SF::Http::Response from the server. Usage example: # Create a new HTTP client http = SF :: Http . new ( \"http://www.sfml-dev.org\" ) # Prepare a request to get the 'features.php' page request = SF :: Http :: Request . new ( \"features.php\" ) # Send the request response = http . send_request request # Check the status code and display the result SF :: Http :: Response :: Status status = response . getStatus () if response . status == SF :: Http :: Response :: Ok puts response . body else puts \"Error #{ response . status } \" end","title":"Http"},{"location":"api/SF/Http.html#included-modules","text":"SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Http.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Http.html#SF::Http.new(host,port)","text":"Construct the HTTP client with the target host This is equivalent to calling host=(host, port). The port has a default value of 0, which means that the HTTP client will use the right port according to the protocol used (80 for HTTP). You should leave it like this unless you really need a port other than the standard one, or use an unknown protocol. host - Web server to connect to port - Port to use for connection [ View source ]","title":".new"},{"location":"api/SF/Http.html#methods","text":"","title":"Methods"},{"location":"api/SF/Http.html#SF::Http#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Http.html#SF::Http#send_request(request,timeout)","text":"Send a HTTP request and return the server's response. You must have a valid host before sending a request (see host=). Any missing mandatory header field in the request will be added with an appropriate value. Warning: this function waits for the server's response and may not return instantly; use a thread if you don't want to block your application, or use a timeout to limit the time to wait. A value of Time::Zero means that the client will use the system default timeout (which is usually pretty long). request - Request to send timeout - Maximum time to wait Returns: Server's response [ View source ]","title":"#send_request"},{"location":"api/SF/Http.html#SF::Http#set_host(host,port)","text":"Set the target host This function just stores the host address and port, it doesn't actually connect to it until you send a request. The port has a default value of 0, which means that the HTTP client will use the right port according to the protocol used (80 for HTTP). You should leave it like this unless you really need a port other than the standard one, or use an unknown protocol. host - Web server to connect to port - Port to use for connection [ View source ]","title":"#set_host"},{"location":"api/SF/Image.html","text":"class SF::Image inherits Reference # Class for loading, manipulating and saving images SF::Image is an abstraction to manipulate images as bidimensional arrays of pixels. The class provides functions to load, read, write and save pixels, as well as many other useful functions. SF::Image can handle a unique internal representation of pixels, which is RGBA 32 bits. This means that a pixel must be composed of 8 bits red, green, blue and alpha channels -- just like a SF::Color . All the functions that return an array of pixels follow this rule, and all parameters that you pass to SF::Image functions (such as load_from_memory) must use this representation as well. A SF::Image can be copied, but it is a heavy resource and if possible you should always use [const] references to pass or return them to avoid useless copies. Usage example: # Load an image file from a file background = SF :: Image . from_file ( \"background.jpg\" ) # Create a 20x20 image filled with black color image = SF :: Image . new ( 20 , 20 , SF :: Color :: Black ) # Copy image1 on image2 at position (10, 10) image . copy ( background , 10 , 10 ) # Make the top-left pixel transparent color = image . get_pixel ( 0 , 0 ) color . a = 128 image . set_pixel ( 0 , 0 , color ) # Save the image to a file image . save_to_file ( \"result.png\" ) || error See also: SF::Texture Class methods # .from_file ( * args , ** kwargs ) : self # Shorthand for image = Image.new; image.load_from_file(...); image Raises InitError on failure [ View source ] .from_memory ( * args , ** kwargs ) : self # Shorthand for image = Image.new; image.load_from_memory(...); image Raises InitError on failure [ View source ] .from_stream ( * args , ** kwargs ) : self # Shorthand for image = Image.new; image.load_from_stream(...); image Raises InitError on failure [ View source ] .new # Default constructor Creates an empty image. [ View source ] .new ( * args , ** kwargs ) : self # Shorthand for image = Image.new; image.create(...); image [ View source ] Methods # #copy ( source : Image , dest_x : Int , dest_y : Int , source_rect : IntRect = IntRect . new ( 0 , 0 , 0 , 0 ), apply_alpha : Bool = false ) # Copy pixels from another image onto this one This function does a slow pixel copy and should not be used intensively. It can be used to prepare a complex static image from several others, but if you need this kind of feature in real-time you'd better use SF::RenderTexture . If source_rect is empty, the whole image is copied. If apply_alpha is set to true, the transparency of source pixels is applied. If it is false, the pixels are copied unchanged with their alpha value. source - Source image to copy dest_x - X coordinate of the destination position dest_y - Y coordinate of the destination position source_rect - Sub-rectangle of the source image to copy apply_alpha - Should the copy take into account the source transparency? [ View source ] #create ( width : Int , height : Int , color : Color = Color . new ( 0 , 0 , 0 )) # Create the image and fill it with a unique color width - Width of the image height - Height of the image color - Fill color [ View source ] #create ( width : Int , height : Int , pixels : Pointer ( UInt8 )) # Create the image from an array of pixels The pixel array is assumed to contain 32-bits RGBA pixels, and have the given width and height. If not, this is an undefined behavior. If pixels is null, an empty image is created. width - Width of the image height - Height of the image pixels - Array of pixels to copy to the image [ View source ] #create_mask_from_color ( color : Color , alpha : Int = 0 ) # Create a transparency mask from a specified color-key This function sets the alpha value of every pixel matching the given color to alpha (0 by default), so that they become transparent. color - Color to make transparent alpha - Alpha value to assign to transparent pixels [ View source ] #dup : Image # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Destructor [ View source ] #flip_horizontally # Flip the image horizontally (left <-> right) [ View source ] #flip_vertically # Flip the image vertically (top <-> bottom) [ View source ] #get_pixel ( x : Int , y : Int ) : Color # Get the color of a pixel This function doesn't check the validity of the pixel coordinates, using out-of-range values will result in an undefined behavior. x - X coordinate of pixel to get y - Y coordinate of pixel to get Returns: Color of the pixel at coordinates (x, y) See also: pixel= [ View source ] #load_from_file ( filename : String ) : Bool # Load the image from a file on disk The supported image formats are bmp, png, tga, jpg, gif, psd, hdr and pic. Some format options are not supported, like progressive jpeg. If this function fails, the image is left unchanged. filename - Path of the image file to load Returns: True if loading was successful See also: load_from_memory , load_from_stream , save_to_file [ View source ] #load_from_memory ( data : Slice ) : Bool # Load the image from a file in memory The supported image formats are bmp, png, tga, jpg, gif, psd, hdr and pic. Some format options are not supported, like progressive jpeg. If this function fails, the image is left unchanged. data - Slice containing the file data in memory Returns: True if loading was successful See also: load_from_file , load_from_stream [ View source ] #load_from_stream ( stream : InputStream ) : Bool # Load the image from a custom stream The supported image formats are bmp, png, tga, jpg, gif, psd, hdr and pic. Some format options are not supported, like progressive jpeg. If this function fails, the image is left unchanged. stream - Source stream to read from Returns: True if loading was successful See also: load_from_file , load_from_memory [ View source ] #pixels_ptr : Pointer ( UInt8 ) # Get a read-only pointer to the array of pixels The returned value points to an array of RGBA pixels made of 8 bits integers components. The size of the array is width * height * 4 (size().x * size() .y * 4). Warning: the returned pointer may become invalid if you modify the image, so you should never store it for too long. If the image is empty, a null pointer is returned. Returns: Read-only pointer to the array of pixels [ View source ] #save_to_file ( filename : String ) : Bool # Save the image to a file on disk The format of the image is automatically deduced from the extension. The supported image formats are bmp, png, tga and jpg. The destination file is overwritten if it already exists. This function fails if the image is empty. filename - Path of the file to save Returns: True if saving was successful See also: create , load_from_file , load_from_memory [ View source ] #set_pixel ( x : Int , y : Int , color : Color ) # Change the color of a pixel This function doesn't check the validity of the pixel coordinates, using out-of-range values will result in an undefined behavior. x - X coordinate of pixel to change y - Y coordinate of pixel to change color - New color of the pixel See also: pixel [ View source ] #size : Vector2u # Return the size (width and height) of the image Returns: Size of the image, in pixels [ View source ]","title":"Image"},{"location":"api/SF/Image.html#SF::Image","text":"Class for loading, manipulating and saving images SF::Image is an abstraction to manipulate images as bidimensional arrays of pixels. The class provides functions to load, read, write and save pixels, as well as many other useful functions. SF::Image can handle a unique internal representation of pixels, which is RGBA 32 bits. This means that a pixel must be composed of 8 bits red, green, blue and alpha channels -- just like a SF::Color . All the functions that return an array of pixels follow this rule, and all parameters that you pass to SF::Image functions (such as load_from_memory) must use this representation as well. A SF::Image can be copied, but it is a heavy resource and if possible you should always use [const] references to pass or return them to avoid useless copies. Usage example: # Load an image file from a file background = SF :: Image . from_file ( \"background.jpg\" ) # Create a 20x20 image filled with black color image = SF :: Image . new ( 20 , 20 , SF :: Color :: Black ) # Copy image1 on image2 at position (10, 10) image . copy ( background , 10 , 10 ) # Make the top-left pixel transparent color = image . get_pixel ( 0 , 0 ) color . a = 128 image . set_pixel ( 0 , 0 , color ) # Save the image to a file image . save_to_file ( \"result.png\" ) || error See also: SF::Texture","title":"Image"},{"location":"api/SF/Image.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Image.html#SF::Image.from_file(*args,**kwargs)","text":"Shorthand for image = Image.new; image.load_from_file(...); image Raises InitError on failure [ View source ]","title":".from_file"},{"location":"api/SF/Image.html#SF::Image.from_memory(*args,**kwargs)","text":"Shorthand for image = Image.new; image.load_from_memory(...); image Raises InitError on failure [ View source ]","title":".from_memory"},{"location":"api/SF/Image.html#SF::Image.from_stream(*args,**kwargs)","text":"Shorthand for image = Image.new; image.load_from_stream(...); image Raises InitError on failure [ View source ]","title":".from_stream"},{"location":"api/SF/Image.html#SF::Image.new()","text":"Default constructor Creates an empty image. [ View source ]","title":".new"},{"location":"api/SF/Image.html#methods","text":"","title":"Methods"},{"location":"api/SF/Image.html#SF::Image#copy(source,dest_x,dest_y,source_rect,apply_alpha)","text":"Copy pixels from another image onto this one This function does a slow pixel copy and should not be used intensively. It can be used to prepare a complex static image from several others, but if you need this kind of feature in real-time you'd better use SF::RenderTexture . If source_rect is empty, the whole image is copied. If apply_alpha is set to true, the transparency of source pixels is applied. If it is false, the pixels are copied unchanged with their alpha value. source - Source image to copy dest_x - X coordinate of the destination position dest_y - Y coordinate of the destination position source_rect - Sub-rectangle of the source image to copy apply_alpha - Should the copy take into account the source transparency? [ View source ]","title":"#copy"},{"location":"api/SF/Image.html#SF::Image#create(width,height,color)","text":"Create the image and fill it with a unique color width - Width of the image height - Height of the image color - Fill color [ View source ]","title":"#create"},{"location":"api/SF/Image.html#SF::Image#create_mask_from_color(color,alpha)","text":"Create a transparency mask from a specified color-key This function sets the alpha value of every pixel matching the given color to alpha (0 by default), so that they become transparent. color - Color to make transparent alpha - Alpha value to assign to transparent pixels [ View source ]","title":"#create_mask_from_color"},{"location":"api/SF/Image.html#SF::Image#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Image.html#SF::Image#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Image.html#SF::Image#flip_horizontally()","text":"Flip the image horizontally (left <-> right) [ View source ]","title":"#flip_horizontally"},{"location":"api/SF/Image.html#SF::Image#flip_vertically()","text":"Flip the image vertically (top <-> bottom) [ View source ]","title":"#flip_vertically"},{"location":"api/SF/Image.html#SF::Image#get_pixel(x,y)","text":"Get the color of a pixel This function doesn't check the validity of the pixel coordinates, using out-of-range values will result in an undefined behavior. x - X coordinate of pixel to get y - Y coordinate of pixel to get Returns: Color of the pixel at coordinates (x, y) See also: pixel= [ View source ]","title":"#get_pixel"},{"location":"api/SF/Image.html#SF::Image#load_from_file(filename)","text":"Load the image from a file on disk The supported image formats are bmp, png, tga, jpg, gif, psd, hdr and pic. Some format options are not supported, like progressive jpeg. If this function fails, the image is left unchanged. filename - Path of the image file to load Returns: True if loading was successful See also: load_from_memory , load_from_stream , save_to_file [ View source ]","title":"#load_from_file"},{"location":"api/SF/Image.html#SF::Image#load_from_memory(data)","text":"Load the image from a file in memory The supported image formats are bmp, png, tga, jpg, gif, psd, hdr and pic. Some format options are not supported, like progressive jpeg. If this function fails, the image is left unchanged. data - Slice containing the file data in memory Returns: True if loading was successful See also: load_from_file , load_from_stream [ View source ]","title":"#load_from_memory"},{"location":"api/SF/Image.html#SF::Image#load_from_stream(stream)","text":"Load the image from a custom stream The supported image formats are bmp, png, tga, jpg, gif, psd, hdr and pic. Some format options are not supported, like progressive jpeg. If this function fails, the image is left unchanged. stream - Source stream to read from Returns: True if loading was successful See also: load_from_file , load_from_memory [ View source ]","title":"#load_from_stream"},{"location":"api/SF/Image.html#SF::Image#pixels_ptr()","text":"Get a read-only pointer to the array of pixels The returned value points to an array of RGBA pixels made of 8 bits integers components. The size of the array is width * height * 4 (size().x * size() .y * 4). Warning: the returned pointer may become invalid if you modify the image, so you should never store it for too long. If the image is empty, a null pointer is returned. Returns: Read-only pointer to the array of pixels [ View source ]","title":"#pixels_ptr"},{"location":"api/SF/Image.html#SF::Image#save_to_file(filename)","text":"Save the image to a file on disk The format of the image is automatically deduced from the extension. The supported image formats are bmp, png, tga and jpg. The destination file is overwritten if it already exists. This function fails if the image is empty. filename - Path of the file to save Returns: True if saving was successful See also: create , load_from_file , load_from_memory [ View source ]","title":"#save_to_file"},{"location":"api/SF/Image.html#SF::Image#set_pixel(x,y,color)","text":"Change the color of a pixel This function doesn't check the validity of the pixel coordinates, using out-of-range values will result in an undefined behavior. x - X coordinate of pixel to change y - Y coordinate of pixel to change color - New color of the pixel See also: pixel [ View source ]","title":"#set_pixel"},{"location":"api/SF/Image.html#SF::Image#size()","text":"Return the size (width and height) of the image Returns: Size of the image, in pixels [ View source ]","title":"#size"},{"location":"api/SF/InitError.html","text":"class SF::InitError inherits Exception # Raised in shorthand class methods if initialization or resource loading fails","title":"InitError"},{"location":"api/SF/InitError.html#SF::InitError","text":"Raised in shorthand class methods if initialization or resource loading fails","title":"InitError"},{"location":"api/SF/InputStream.html","text":"abstract class SF::InputStream inherits Reference # Abstract class for custom file input streams This class allows users to define their own file input sources from which SFML can load resources. SFML resource classes like SF::Texture and SF::SoundBuffer provide load_from_file and load_from_memory functions, which read data from conventional sources. However, if you have data coming from a different source (over a network, embedded, encrypted, compressed, etc) you can derive your own class from SF::InputStream and load SFML resources with their load_from_stream function. Usage example: # custom stream class that reads from inside a zip file class ZipStream < SF :: InputStream def initialize ( archive : String ) def open ( filename : String ) def read ( data : Slice ) : Int64 def seek ( position : Int ) : Int64 def tell () : Int64 def size () : Int64 ... end # now you can load textures... stream = ZipStream . new ( \"resources.zip\" ) stream . open ( \"images/img.png\" ) texture = SF :: Texture . from_stream ( stream ) # musics... stream = ZipStream . new ( \"resources.zip\" ) stream . open ( \"musics/msc.ogg\" ) music = SF :: Music . from_stream ( stream ) # etc. Direct known subclasses # SF::FileInputStream SF::MemoryInputStream Class methods # .new # [ View source ] Methods # #finalize # [ View source ] abstract #read ( data : Slice ) : Int64 # Read data from the stream After reading, the stream's reading position must be advanced by the amount of bytes read. data - Buffer where to copy the read data Returns: The number of bytes actually read, or -1 on error [ View source ] abstract #seek ( position : Int ) : Int64 # Change the current reading position position - The position to seek to, from the beginning Returns: The position actually sought to, or -1 on error [ View source ] abstract #size : Int64 # Return the size of the stream Returns: The total number of bytes available in the stream, or -1 on error [ View source ] abstract #tell : Int64 # Get the current reading position in the stream Returns: The current position, or -1 on error. [ View source ]","title":"InputStream"},{"location":"api/SF/InputStream.html#SF::InputStream","text":"Abstract class for custom file input streams This class allows users to define their own file input sources from which SFML can load resources. SFML resource classes like SF::Texture and SF::SoundBuffer provide load_from_file and load_from_memory functions, which read data from conventional sources. However, if you have data coming from a different source (over a network, embedded, encrypted, compressed, etc) you can derive your own class from SF::InputStream and load SFML resources with their load_from_stream function. Usage example: # custom stream class that reads from inside a zip file class ZipStream < SF :: InputStream def initialize ( archive : String ) def open ( filename : String ) def read ( data : Slice ) : Int64 def seek ( position : Int ) : Int64 def tell () : Int64 def size () : Int64 ... end # now you can load textures... stream = ZipStream . new ( \"resources.zip\" ) stream . open ( \"images/img.png\" ) texture = SF :: Texture . from_stream ( stream ) # musics... stream = ZipStream . new ( \"resources.zip\" ) stream . open ( \"musics/msc.ogg\" ) music = SF :: Music . from_stream ( stream ) # etc.","title":"InputStream"},{"location":"api/SF/InputStream.html#direct-known-subclasses","text":"SF::FileInputStream SF::MemoryInputStream","title":"Direct known subclasses"},{"location":"api/SF/InputStream.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/InputStream.html#SF::InputStream.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/InputStream.html#methods","text":"","title":"Methods"},{"location":"api/SF/InputStream.html#SF::InputStream#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/InputStream.html#SF::InputStream#read(data)","text":"Read data from the stream After reading, the stream's reading position must be advanced by the amount of bytes read. data - Buffer where to copy the read data Returns: The number of bytes actually read, or -1 on error [ View source ]","title":"#read"},{"location":"api/SF/InputStream.html#SF::InputStream#seek(position)","text":"Change the current reading position position - The position to seek to, from the beginning Returns: The position actually sought to, or -1 on error [ View source ]","title":"#seek"},{"location":"api/SF/InputStream.html#SF::InputStream#size()","text":"Return the size of the stream Returns: The total number of bytes available in the stream, or -1 on error [ View source ]","title":"#size"},{"location":"api/SF/InputStream.html#SF::InputStream#tell()","text":"Get the current reading position in the stream Returns: The current position, or -1 on error. [ View source ]","title":"#tell"},{"location":"api/SF/IntRect.html","text":"alias SF::IntRect # Alias definition # SF :: Rect ( Int32 )","title":"IntRect"},{"location":"api/SF/IntRect.html#SF::IntRect","text":"","title":"IntRect"},{"location":"api/SF/IntRect.html#alias-definition","text":"SF :: Rect ( Int32 )","title":"Alias definition"},{"location":"api/SF/IpAddress.html","text":"struct SF::IpAddress inherits Struct # Encapsulate an IPv4 network address SF::IpAddress is a utility class for manipulating network addresses. It provides a set a implicit constructors and conversion functions to easily build or transform an IP address from/to various representations. Usage example: a0 = SF :: IpAddress . new # an invalid address a1 = SF :: IpAddress :: None # an invalid address (same as a0) a2 = SF :: IpAddress . new ( \"127.0.0.1\" ) # the local host address a3 = SF :: IpAddress :: Broadcast # the broadcast address a4 = SF :: IpAddress . new ( 192 , 168 , 1 , 56 ) # a local address a5 = SF :: IpAddress . new ( \"my_computer\" ) # a local address created from a network name a6 = SF :: IpAddress . new ( \"89.54.1.169\" ) # a distant address a7 = SF :: IpAddress . new ( \"www.google.com\" ) # a distant address created from a network name a8 = SF :: IpAddress . local_address # my address on the local network a9 = SF :: IpAddress . get_public_address () # my address on the internet Note that SF::IpAddress currently doesn't support IPv6 nor other types of network addresses. Constants # Any # Value representing any address (0.0.0.0) Broadcast # The \"broadcast\" address (for sending UDP messages to everyone on a local network) LocalHost # The \"localhost\" address (for connecting a computer to itself locally) None # Value representing an empty/invalid address Class methods # .get_public_address ( timeout : Time = Time :: Zero ) : IpAddress # Get the computer's public address The public address is the address of the computer from the internet point of view, i.e. something like 89.54.1.169. It is necessary for communications over the world wide web. The only way to get a public address is to ask it to a distant website; as a consequence, this function depends on both your network connection and the server, and may be very slow. You should use it as few as possible. Because this function depends on the network connection and on a distant server, you may use a time limit if you don't want your program to be possibly stuck waiting in case there is a problem; this limit is deactivated by default. timeout - Maximum time to wait Returns: Public IP address of the computer See also: local_address [ View source ] .local_address : IpAddress # Get the computer's local address The local address is the address of the computer from the LAN point of view, i.e. something like 192.168.1.56. It is meaningful only for communications over the local network. Unlike public_address, this function is fast and may be used safely anywhere. Returns: Local IP address of the computer See also: public_address [ View source ] .new ( byte0 : Int , byte1 : Int , byte2 : Int , byte3 : Int ) # Construct the address from 4 bytes Calling IpAddress(a, b, c, d) is equivalent to calling IpAddress(\"a.b.c.d\"), but safer as it doesn't have to parse a string to get the address components. byte0 - First byte of the address byte1 - Second byte of the address byte2 - Third byte of the address byte3 - Fourth byte of the address [ View source ] .new ( address : String ) # Construct the address from a string Here address can be either a decimal address (ex: \"192.168.1.56\") or a network name (ex: \"localhost\"). This is equivalent to the constructor taking a std::string parameter, it is defined for convenience so that the implicit conversions from literal strings to IpAddress work. address - IP address or network name [ View source ] .new ( address : Int ) # Construct the address from a 32-bits integer This constructor uses the internal representation of the address directly. It should be used for optimization purposes, and only if you got that representation from IpAddress.to_integer(). address - 4 bytes of the address packed into a 32-bits integer See also: to_integer [ View source ] .new # Default constructor This constructor creates an empty (invalid) address [ View source ] Methods # #!= ( right : IpAddress ) : Bool # Overload of != operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if both addresses are different [ View source ] #< ( right : IpAddress ) : Bool # Overload of < operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if left is lesser than right [ View source ] #<= ( right : IpAddress ) : Bool # Overload of <= operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if left is lesser or equal than right [ View source ] #== ( right : IpAddress ) : Bool # Overload of == operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if both addresses are equal [ View source ] #> ( right : IpAddress ) : Bool # Overload of > operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if left is greater than right [ View source ] #>= ( right : IpAddress ) : Bool # Overload of >= operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if left is greater or equal than right [ View source ] #dup : IpAddress # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #inspect ( io ) # [ View source ] #to_integer : UInt32 # Get an integer representation of the address The returned number is the internal representation of the address, and should be used for optimization purposes only (like sending the address through a socket). The integer produced by this function can then be converted back to a SF::IpAddress with the proper constructor. Returns: 32-bits unsigned integer representation of the address See also: to_s [ View source ] #to_s : String # Get a string representation of the address The returned string is the decimal representation of the IP address (like \"192.168.1.56\"), even if it was constructed from a host name. Returns: String representation of the address See also: to_integer [ View source ]","title":"IpAddress"},{"location":"api/SF/IpAddress.html#SF::IpAddress","text":"Encapsulate an IPv4 network address SF::IpAddress is a utility class for manipulating network addresses. It provides a set a implicit constructors and conversion functions to easily build or transform an IP address from/to various representations. Usage example: a0 = SF :: IpAddress . new # an invalid address a1 = SF :: IpAddress :: None # an invalid address (same as a0) a2 = SF :: IpAddress . new ( \"127.0.0.1\" ) # the local host address a3 = SF :: IpAddress :: Broadcast # the broadcast address a4 = SF :: IpAddress . new ( 192 , 168 , 1 , 56 ) # a local address a5 = SF :: IpAddress . new ( \"my_computer\" ) # a local address created from a network name a6 = SF :: IpAddress . new ( \"89.54.1.169\" ) # a distant address a7 = SF :: IpAddress . new ( \"www.google.com\" ) # a distant address created from a network name a8 = SF :: IpAddress . local_address # my address on the local network a9 = SF :: IpAddress . get_public_address () # my address on the internet Note that SF::IpAddress currently doesn't support IPv6 nor other types of network addresses.","title":"IpAddress"},{"location":"api/SF/IpAddress.html#constants","text":"","title":"Constants"},{"location":"api/SF/IpAddress.html#SF::IpAddress::Any","text":"Value representing any address (0.0.0.0)","title":"Any"},{"location":"api/SF/IpAddress.html#SF::IpAddress::Broadcast","text":"The \"broadcast\" address (for sending UDP messages to everyone on a local network)","title":"Broadcast"},{"location":"api/SF/IpAddress.html#SF::IpAddress::LocalHost","text":"The \"localhost\" address (for connecting a computer to itself locally)","title":"LocalHost"},{"location":"api/SF/IpAddress.html#SF::IpAddress::None","text":"Value representing an empty/invalid address","title":"None"},{"location":"api/SF/IpAddress.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/IpAddress.html#SF::IpAddress.get_public_address(timeout)","text":"Get the computer's public address The public address is the address of the computer from the internet point of view, i.e. something like 89.54.1.169. It is necessary for communications over the world wide web. The only way to get a public address is to ask it to a distant website; as a consequence, this function depends on both your network connection and the server, and may be very slow. You should use it as few as possible. Because this function depends on the network connection and on a distant server, you may use a time limit if you don't want your program to be possibly stuck waiting in case there is a problem; this limit is deactivated by default. timeout - Maximum time to wait Returns: Public IP address of the computer See also: local_address [ View source ]","title":".get_public_address"},{"location":"api/SF/IpAddress.html#SF::IpAddress.local_address()","text":"Get the computer's local address The local address is the address of the computer from the LAN point of view, i.e. something like 192.168.1.56. It is meaningful only for communications over the local network. Unlike public_address, this function is fast and may be used safely anywhere. Returns: Local IP address of the computer See also: public_address [ View source ]","title":".local_address"},{"location":"api/SF/IpAddress.html#SF::IpAddress.new(byte0,byte1,byte2,byte3)","text":"Construct the address from 4 bytes Calling IpAddress(a, b, c, d) is equivalent to calling IpAddress(\"a.b.c.d\"), but safer as it doesn't have to parse a string to get the address components. byte0 - First byte of the address byte1 - Second byte of the address byte2 - Third byte of the address byte3 - Fourth byte of the address [ View source ]","title":".new"},{"location":"api/SF/IpAddress.html#methods","text":"","title":"Methods"},{"location":"api/SF/IpAddress.html#SF::IpAddress#!=(right)","text":"Overload of != operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if both addresses are different [ View source ]","title":"#!="},{"location":"api/SF/IpAddress.html#SF::IpAddress#<(right)","text":"Overload of < operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if left is lesser than right [ View source ]","title":"#&lt;"},{"location":"api/SF/IpAddress.html#SF::IpAddress#<=(right)","text":"Overload of <= operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if left is lesser or equal than right [ View source ]","title":"#&lt;="},{"location":"api/SF/IpAddress.html#SF::IpAddress#==(right)","text":"Overload of == operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if both addresses are equal [ View source ]","title":"#=="},{"location":"api/SF/IpAddress.html#SF::IpAddress#>(right)","text":"Overload of > operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if left is greater than right [ View source ]","title":"#&gt;"},{"location":"api/SF/IpAddress.html#SF::IpAddress#>=(right)","text":"Overload of >= operator to compare two IP addresses left - Left operand (a IP address) right - Right operand (a IP address) Returns: True if left is greater or equal than right [ View source ]","title":"#&gt;="},{"location":"api/SF/IpAddress.html#SF::IpAddress#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/IpAddress.html#SF::IpAddress#inspect(io)","text":"[ View source ]","title":"#inspect"},{"location":"api/SF/IpAddress.html#SF::IpAddress#to_integer()","text":"Get an integer representation of the address The returned number is the internal representation of the address, and should be used for optimization purposes only (like sending the address through a socket). The integer produced by this function can then be converted back to a SF::IpAddress with the proper constructor. Returns: 32-bits unsigned integer representation of the address See also: to_s [ View source ]","title":"#to_integer"},{"location":"api/SF/IpAddress.html#SF::IpAddress#to_s()","text":"Get a string representation of the address The returned string is the decimal representation of the IP address (like \"192.168.1.56\"), even if it was constructed from a host name. Returns: String representation of the address See also: to_integer [ View source ]","title":"#to_s"},{"location":"api/SF/Joystick.html","text":"module SF::Joystick # Give access to the real-time state of the joysticks SF::Joystick provides an interface to the state of the joysticks. It only contains static functions, so it's not meant to be instantiated. Instead, each joystick is identified by an index that is passed to the functions of this module. This module allows users to query the state of joysticks at any time and directly, without having to deal with a window and its events. Compared to the JoystickMoved , JoystickButtonPressed and JoystickButtonReleased events, SF::Joystick can retrieve the state of axes and buttons of joysticks at any time (you don't need to store and update a boolean on your side in order to know if a button is pressed or released), and you always get the real state of joysticks, even if they are moved, pressed or released when your window is out of focus and no event is triggered. SFML supports: 8 joysticks ( SF::Joystick::Count ) 32 buttons per joystick ( SF::Joystick::ButtonCount ) 8 axes per joystick ( SF::Joystick::AxisCount ) Unlike the keyboard or mouse, the state of joysticks is sometimes not directly available (depending on the OS), therefore an update() function must be called in order to update the current state of joysticks. When you have a window with event handling, this is done automatically, you don't need to call anything. But if you have no window, or if you want to check joysticks state before creating one, you must call SF::Joystick.update explicitly. Usage example: # Is joystick #0 connected? connected = SF :: Joystick . connected? ( 0 ) # How many buttons does joystick #0 support? buttons = SF :: Joystick . get_button_count ( 0 ) # Does joystick #0 define a X axis? has_x = SF :: Joystick . axis? ( 0 , SF :: Joystick :: X ) # Is button #2 pressed on joystick #0? pressed = SF :: Joystick . button_pressed? ( 0 , 2 ) # What's the current position of the Y axis on joystick #0? position = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: Y ) See also: SF::Keyboard , SF::Mouse Constants # AxisCount # Maximum number of supported axes ButtonCount # Maximum number of supported buttons Count # Maximum number of supported joysticks Class methods # .axis? ( joystick : Int , axis : Joystick :: Axis ) : Bool # Check if a joystick supports a given axis If the joystick is not connected, this function returns false. joystick - Index of the joystick axis - Axis to check Returns: True if the joystick supports the axis, false otherwise [ View source ] .button_pressed? ( joystick : Int , button : Int ) : Bool # Check if a joystick button is pressed If the joystick is not connected, this function returns false. joystick - Index of the joystick button - Button to check Returns: True if the button is pressed, false otherwise [ View source ] .connected? ( joystick : Int ) : Bool # Check if a joystick is connected joystick - Index of the joystick to check Returns: True if the joystick is connected, false otherwise [ View source ] .get_axis_position ( joystick : Int , axis : Joystick :: Axis ) : Float32 # Get the current position of a joystick axis If the joystick is not connected, this function returns 0. joystick - Index of the joystick axis - Axis to check Returns: Current position of the axis, in range -100 .. 100 [ View source ] .get_button_count ( joystick : Int ) : Int32 # Return the number of buttons supported by a joystick If the joystick is not connected, this function returns 0. joystick - Index of the joystick Returns: Number of buttons supported by the joystick [ View source ] .get_identification ( joystick : Int ) : Joystick :: Identification # Get the joystick information joystick - Index of the joystick Returns: Structure containing joystick information. [ View source ] .update # Update the states of all joysticks This function is used internally by SFML, so you normally don't have to call it explicitly. However, you may need to call it if you have no window yet (or no window at all): in this case the joystick states are not updated automatically. [ View source ]","title":"Joystick"},{"location":"api/SF/Joystick.html#SF::Joystick","text":"Give access to the real-time state of the joysticks SF::Joystick provides an interface to the state of the joysticks. It only contains static functions, so it's not meant to be instantiated. Instead, each joystick is identified by an index that is passed to the functions of this module. This module allows users to query the state of joysticks at any time and directly, without having to deal with a window and its events. Compared to the JoystickMoved , JoystickButtonPressed and JoystickButtonReleased events, SF::Joystick can retrieve the state of axes and buttons of joysticks at any time (you don't need to store and update a boolean on your side in order to know if a button is pressed or released), and you always get the real state of joysticks, even if they are moved, pressed or released when your window is out of focus and no event is triggered. SFML supports: 8 joysticks ( SF::Joystick::Count ) 32 buttons per joystick ( SF::Joystick::ButtonCount ) 8 axes per joystick ( SF::Joystick::AxisCount ) Unlike the keyboard or mouse, the state of joysticks is sometimes not directly available (depending on the OS), therefore an update() function must be called in order to update the current state of joysticks. When you have a window with event handling, this is done automatically, you don't need to call anything. But if you have no window, or if you want to check joysticks state before creating one, you must call SF::Joystick.update explicitly. Usage example: # Is joystick #0 connected? connected = SF :: Joystick . connected? ( 0 ) # How many buttons does joystick #0 support? buttons = SF :: Joystick . get_button_count ( 0 ) # Does joystick #0 define a X axis? has_x = SF :: Joystick . axis? ( 0 , SF :: Joystick :: X ) # Is button #2 pressed on joystick #0? pressed = SF :: Joystick . button_pressed? ( 0 , 2 ) # What's the current position of the Y axis on joystick #0? position = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: Y ) See also: SF::Keyboard , SF::Mouse","title":"Joystick"},{"location":"api/SF/Joystick.html#constants","text":"","title":"Constants"},{"location":"api/SF/Joystick.html#SF::Joystick::AxisCount","text":"Maximum number of supported axes","title":"AxisCount"},{"location":"api/SF/Joystick.html#SF::Joystick::ButtonCount","text":"Maximum number of supported buttons","title":"ButtonCount"},{"location":"api/SF/Joystick.html#SF::Joystick::Count","text":"Maximum number of supported joysticks","title":"Count"},{"location":"api/SF/Joystick.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Joystick.html#SF::Joystick.axis?(joystick,axis)","text":"Check if a joystick supports a given axis If the joystick is not connected, this function returns false. joystick - Index of the joystick axis - Axis to check Returns: True if the joystick supports the axis, false otherwise [ View source ]","title":".axis?"},{"location":"api/SF/Joystick.html#SF::Joystick.button_pressed?(joystick,button)","text":"Check if a joystick button is pressed If the joystick is not connected, this function returns false. joystick - Index of the joystick button - Button to check Returns: True if the button is pressed, false otherwise [ View source ]","title":".button_pressed?"},{"location":"api/SF/Joystick.html#SF::Joystick.connected?(joystick)","text":"Check if a joystick is connected joystick - Index of the joystick to check Returns: True if the joystick is connected, false otherwise [ View source ]","title":".connected?"},{"location":"api/SF/Joystick.html#SF::Joystick.get_axis_position(joystick,axis)","text":"Get the current position of a joystick axis If the joystick is not connected, this function returns 0. joystick - Index of the joystick axis - Axis to check Returns: Current position of the axis, in range -100 .. 100 [ View source ]","title":".get_axis_position"},{"location":"api/SF/Joystick.html#SF::Joystick.get_button_count(joystick)","text":"Return the number of buttons supported by a joystick If the joystick is not connected, this function returns 0. joystick - Index of the joystick Returns: Number of buttons supported by the joystick [ View source ]","title":".get_button_count"},{"location":"api/SF/Joystick.html#SF::Joystick.get_identification(joystick)","text":"Get the joystick information joystick - Index of the joystick Returns: Structure containing joystick information. [ View source ]","title":".get_identification"},{"location":"api/SF/Joystick.html#SF::Joystick.update()","text":"Update the states of all joysticks This function is used internally by SFML, so you normally don't have to call it explicitly. However, you may need to call it if you have no window yet (or no window at all): in this case the joystick states are not updated automatically. [ View source ]","title":".update"},{"location":"api/SF/Keyboard.html","text":"module SF::Keyboard # Give access to the real-time state of the keyboard SF::Keyboard provides an interface to the state of the keyboard. It only contains static functions (a single keyboard is assumed), so it's not meant to be instantiated. This module allows users to query the keyboard state at any time and directly, without having to deal with a window and its events. Compared to the KeyPressed and KeyReleased events, SF::Keyboard can retrieve the state of a key at any time (you don't need to store and update a boolean on your side in order to know if a key is pressed or released), and you always get the real state of the keyboard, even if keys are pressed or released when your window is out of focus and no event is triggered. Usage example: if SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Left ) # move left... elsif SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Right ) # move right... elsif SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Escape ) # quit... end See also: SF::Joystick , SF::Mouse , SF::Touch Class methods # .key_pressed? ( key : Keyboard :: Key ) : Bool # Check if a key is pressed key - Key to check Returns: True if the key is pressed, false otherwise [ View source ] .virtual_keyboard_visible= ( visible : Bool ) # Show or hide the virtual keyboard Warning: the virtual keyboard is not supported on all systems. It will typically be implemented on mobile OSes (Android, iOS) but not on desktop OSes (Windows, Linux, ...). If the virtual keyboard is not available, this function does nothing. visible - True to show, false to hide [ View source ]","title":"Keyboard"},{"location":"api/SF/Keyboard.html#SF::Keyboard","text":"Give access to the real-time state of the keyboard SF::Keyboard provides an interface to the state of the keyboard. It only contains static functions (a single keyboard is assumed), so it's not meant to be instantiated. This module allows users to query the keyboard state at any time and directly, without having to deal with a window and its events. Compared to the KeyPressed and KeyReleased events, SF::Keyboard can retrieve the state of a key at any time (you don't need to store and update a boolean on your side in order to know if a key is pressed or released), and you always get the real state of the keyboard, even if keys are pressed or released when your window is out of focus and no event is triggered. Usage example: if SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Left ) # move left... elsif SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Right ) # move right... elsif SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Escape ) # quit... end See also: SF::Joystick , SF::Mouse , SF::Touch","title":"Keyboard"},{"location":"api/SF/Keyboard.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Keyboard.html#SF::Keyboard.key_pressed?(key)","text":"Check if a key is pressed key - Key to check Returns: True if the key is pressed, false otherwise [ View source ]","title":".key_pressed?"},{"location":"api/SF/Keyboard.html#SF::Keyboard.virtual_keyboard_visible=(visible)","text":"Show or hide the virtual keyboard Warning: the virtual keyboard is not supported on all systems. It will typically be implemented on mobile OSes (Android, iOS) but not on desktop OSes (Windows, Linux, ...). If the virtual keyboard is not available, this function does nothing. visible - True to show, false to hide [ View source ]","title":".virtual_keyboard_visible="},{"location":"api/SF/Listener.html","text":"module SF::Listener # The audio listener is the point in the scene from where all the sounds are heard The audio listener defines the global properties of the audio environment, it defines where and how sounds and musics are heard. If SF::View is the eyes of the user, then SF::Listener is his ears (by the way, they are often linked together -- same position, orientation, etc.). SF::Listener is a simple interface, which allows to setup the listener in the 3D audio environment (position, direction and up vector), and to adjust the global volume. Because the listener is unique in the scene, SF::Listener only contains static functions and doesn't have to be instantiated. Usage example: # Move the listener to the position (1, 0, -5) SF :: Listener . set_position ( 1 , 0 , - 5 ) # Make it face the right axis (1, 0, 0) SF :: Listener . direction = SF . vector3f ( 1 , 0 , 0 ) # Reduce the global volume SF :: Listener . global_volume = 50 Class methods # .direction : Vector3f # Get the current forward vector of the listener in the scene Returns: Listener's forward vector (not normalized) See also: direction= [ View source ] .direction= ( direction : Vector3f ) # Set the forward vector of the listener in the scene The direction (also called \"at vector\") is the vector pointing forward from the listener's perspective. Together with the up vector, it defines the 3D orientation of the listener in the scene. The direction vector doesn't have to be normalized. The default listener's direction is (0, 0, -1). direction - New listener's direction See also: direction , up_vector= , position= [ View source ] .global_volume : Float32 # Get the current value of the global volume Returns: Current global volume, in the range 0..100 See also: global_volume= [ View source ] .global_volume= ( volume : Number ) # Change the global volume of all the sounds and musics The volume is a number between 0 and 100; it is combined with the individual volume of each sound / music. The default value for the volume is 100 (maximum). volume - New global volume, in the range 0..100 See also: global_volume [ View source ] .position : Vector3f # Get the current position of the listener in the scene Returns: Listener's position See also: position= [ View source ] .position= ( position : Vector3f ) # Set the position of the listener in the scene The default listener's position is (0, 0, 0). position - New listener's position See also: position , direction= [ View source ] .set_direction ( x : Number , y : Number , z : Number ) # Set the forward vector of the listener in the scene The direction (also called \"at vector\") is the vector pointing forward from the listener's perspective. Together with the up vector, it defines the 3D orientation of the listener in the scene. The direction vector doesn't have to be normalized. The default listener's direction is (0, 0, -1). x - X coordinate of the listener's direction y - Y coordinate of the listener's direction z - Z coordinate of the listener's direction See also: direction , up_vector= , position= [ View source ] .set_position ( x : Number , y : Number , z : Number ) # Set the position of the listener in the scene The default listener's position is (0, 0, 0). x - X coordinate of the listener's position y - Y coordinate of the listener's position z - Z coordinate of the listener's position See also: position , direction= [ View source ] .set_up_vector ( x : Number , y : Number , z : Number ) # Set the upward vector of the listener in the scene The up vector is the vector that points upward from the listener's perspective. Together with the direction, it defines the 3D orientation of the listener in the scene. The up vector doesn't have to be normalized. The default listener's up vector is (0, 1, 0). It is usually not necessary to change it, especially in 2D scenarios. x - X coordinate of the listener's up vector y - Y coordinate of the listener's up vector z - Z coordinate of the listener's up vector See also: up_vector , direction= , position= [ View source ] .up_vector : Vector3f # Get the current upward vector of the listener in the scene Returns: Listener's upward vector (not normalized) See also: up_vector= [ View source ] .up_vector= ( up_vector : Vector3f ) # Set the upward vector of the listener in the scene The up vector is the vector that points upward from the listener's perspective. Together with the direction, it defines the 3D orientation of the listener in the scene. The up vector doesn't have to be normalized. The default listener's up vector is (0, 1, 0). It is usually not necessary to change it, especially in 2D scenarios. up_vector - New listener's up vector See also: up_vector , direction= , position= [ View source ]","title":"Listener"},{"location":"api/SF/Listener.html#SF::Listener","text":"The audio listener is the point in the scene from where all the sounds are heard The audio listener defines the global properties of the audio environment, it defines where and how sounds and musics are heard. If SF::View is the eyes of the user, then SF::Listener is his ears (by the way, they are often linked together -- same position, orientation, etc.). SF::Listener is a simple interface, which allows to setup the listener in the 3D audio environment (position, direction and up vector), and to adjust the global volume. Because the listener is unique in the scene, SF::Listener only contains static functions and doesn't have to be instantiated. Usage example: # Move the listener to the position (1, 0, -5) SF :: Listener . set_position ( 1 , 0 , - 5 ) # Make it face the right axis (1, 0, 0) SF :: Listener . direction = SF . vector3f ( 1 , 0 , 0 ) # Reduce the global volume SF :: Listener . global_volume = 50","title":"Listener"},{"location":"api/SF/Listener.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Listener.html#SF::Listener.direction()","text":"Get the current forward vector of the listener in the scene Returns: Listener's forward vector (not normalized) See also: direction= [ View source ]","title":".direction"},{"location":"api/SF/Listener.html#SF::Listener.direction=(direction)","text":"Set the forward vector of the listener in the scene The direction (also called \"at vector\") is the vector pointing forward from the listener's perspective. Together with the up vector, it defines the 3D orientation of the listener in the scene. The direction vector doesn't have to be normalized. The default listener's direction is (0, 0, -1). direction - New listener's direction See also: direction , up_vector= , position= [ View source ]","title":".direction="},{"location":"api/SF/Listener.html#SF::Listener.global_volume()","text":"Get the current value of the global volume Returns: Current global volume, in the range 0..100 See also: global_volume= [ View source ]","title":".global_volume"},{"location":"api/SF/Listener.html#SF::Listener.global_volume=(volume)","text":"Change the global volume of all the sounds and musics The volume is a number between 0 and 100; it is combined with the individual volume of each sound / music. The default value for the volume is 100 (maximum). volume - New global volume, in the range 0..100 See also: global_volume [ View source ]","title":".global_volume="},{"location":"api/SF/Listener.html#SF::Listener.position()","text":"Get the current position of the listener in the scene Returns: Listener's position See also: position= [ View source ]","title":".position"},{"location":"api/SF/Listener.html#SF::Listener.position=(position)","text":"Set the position of the listener in the scene The default listener's position is (0, 0, 0). position - New listener's position See also: position , direction= [ View source ]","title":".position="},{"location":"api/SF/Listener.html#SF::Listener.set_direction(x,y,z)","text":"Set the forward vector of the listener in the scene The direction (also called \"at vector\") is the vector pointing forward from the listener's perspective. Together with the up vector, it defines the 3D orientation of the listener in the scene. The direction vector doesn't have to be normalized. The default listener's direction is (0, 0, -1). x - X coordinate of the listener's direction y - Y coordinate of the listener's direction z - Z coordinate of the listener's direction See also: direction , up_vector= , position= [ View source ]","title":".set_direction"},{"location":"api/SF/Listener.html#SF::Listener.set_position(x,y,z)","text":"Set the position of the listener in the scene The default listener's position is (0, 0, 0). x - X coordinate of the listener's position y - Y coordinate of the listener's position z - Z coordinate of the listener's position See also: position , direction= [ View source ]","title":".set_position"},{"location":"api/SF/Listener.html#SF::Listener.set_up_vector(x,y,z)","text":"Set the upward vector of the listener in the scene The up vector is the vector that points upward from the listener's perspective. Together with the direction, it defines the 3D orientation of the listener in the scene. The up vector doesn't have to be normalized. The default listener's up vector is (0, 1, 0). It is usually not necessary to change it, especially in 2D scenarios. x - X coordinate of the listener's up vector y - Y coordinate of the listener's up vector z - Z coordinate of the listener's up vector See also: up_vector , direction= , position= [ View source ]","title":".set_up_vector"},{"location":"api/SF/Listener.html#SF::Listener.up_vector()","text":"Get the current upward vector of the listener in the scene Returns: Listener's upward vector (not normalized) See also: up_vector= [ View source ]","title":".up_vector"},{"location":"api/SF/Listener.html#SF::Listener.up_vector=(up_vector)","text":"Set the upward vector of the listener in the scene The up vector is the vector that points upward from the listener's perspective. Together with the direction, it defines the 3D orientation of the listener in the scene. The up vector doesn't have to be normalized. The default listener's up vector is (0, 1, 0). It is usually not necessary to change it, especially in 2D scenarios. up_vector - New listener's up vector See also: up_vector , direction= , position= [ View source ]","title":".up_vector="},{"location":"api/SF/MemoryInputStream.html","text":"class SF::MemoryInputStream inherits SF::InputStream # Implementation of input stream based on a memory chunk This class is a specialization of InputStream that reads from data in memory. It wraps a memory chunk in the common InputStream interface and therefore allows to use generic classes or functions that accept such a stream, with content already loaded in memory. In addition to the virtual functions inherited from InputStream, MemoryInputStream adds a function to specify the pointer and size of the data in memory. SFML resource classes can usually be loaded directly from memory, so this class shouldn't be useful to you unless you create your own algorithms that operate on an InputStream. Usage example: def process ( stream : InputStream ) end stream = SF :: MemoryInputStream . open ( slice ) process ( stream ) InputStream, FileInputStream Class methods # .new # Default constructor [ View source ] .open ( * args , ** kwargs ) : self # Shorthand for memory_input_stream = MemoryInputStream.new; memory_input_stream.open(...); memory_input_stream [ View source ] Methods # #dup : MemoryInputStream # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ] #open ( data : Slice ) # Open the stream from its data data - Pointer to the data in memory [ View source ] #read ( data : Slice ) : Int64 # Read data from the stream After reading, the stream's reading position must be advanced by the amount of bytes read. data - Buffer where to copy the read data Returns: The number of bytes actually read, or -1 on error [ View source ] #seek ( position : Int ) : Int64 # Change the current reading position position - The position to seek to, from the beginning Returns: The position actually sought to, or -1 on error [ View source ] #size : Int64 # Return the size of the stream Returns: The total number of bytes available in the stream, or -1 on error [ View source ] #tell : Int64 # Get the current reading position in the stream Returns: The current position, or -1 on error. [ View source ]","title":"MemoryInputStream"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream","text":"Implementation of input stream based on a memory chunk This class is a specialization of InputStream that reads from data in memory. It wraps a memory chunk in the common InputStream interface and therefore allows to use generic classes or functions that accept such a stream, with content already loaded in memory. In addition to the virtual functions inherited from InputStream, MemoryInputStream adds a function to specify the pointer and size of the data in memory. SFML resource classes can usually be loaded directly from memory, so this class shouldn't be useful to you unless you create your own algorithms that operate on an InputStream. Usage example: def process ( stream : InputStream ) end stream = SF :: MemoryInputStream . open ( slice ) process ( stream ) InputStream, FileInputStream","title":"MemoryInputStream"},{"location":"api/SF/MemoryInputStream.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream.open(*args,**kwargs)","text":"Shorthand for memory_input_stream = MemoryInputStream.new; memory_input_stream.open(...); memory_input_stream [ View source ]","title":".open"},{"location":"api/SF/MemoryInputStream.html#methods","text":"","title":"Methods"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream#open(data)","text":"Open the stream from its data data - Pointer to the data in memory [ View source ]","title":"#open"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream#read(data)","text":"Read data from the stream After reading, the stream's reading position must be advanced by the amount of bytes read. data - Buffer where to copy the read data Returns: The number of bytes actually read, or -1 on error [ View source ]","title":"#read"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream#seek(position)","text":"Change the current reading position position - The position to seek to, from the beginning Returns: The position actually sought to, or -1 on error [ View source ]","title":"#seek"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream#size()","text":"Return the size of the stream Returns: The total number of bytes available in the stream, or -1 on error [ View source ]","title":"#size"},{"location":"api/SF/MemoryInputStream.html#SF::MemoryInputStream#tell()","text":"Get the current reading position in the stream Returns: The current position, or -1 on error. [ View source ]","title":"#tell"},{"location":"api/SF/Mouse.html","text":"module SF::Mouse # Give access to the real-time state of the mouse SF::Mouse provides an interface to the state of the mouse. It only contains static functions (a single mouse is assumed), so it's not meant to be instantiated. This module allows users to query the mouse state at any time and directly, without having to deal with a window and its events. Compared to the MouseMoved , MouseButtonPressed and MouseButtonReleased events, SF::Mouse can retrieve the state of the cursor and the buttons at any time (you don't need to store and update a boolean on your side in order to know if a button is pressed or released), and you always get the real state of the mouse, even if it is moved, pressed or released when your window is out of focus and no event is triggered. The position= and position functions can be used to change or retrieve the current position of the mouse pointer. There are two versions: one that operates in global coordinates (relative to the desktop) and one that operates in window coordinates (relative to a specific window). Usage example: if SF :: Mouse . button_pressed? ( SF :: Mouse :: Left ) # left click... end # get global mouse position position = SF :: Mouse . position # set mouse position relative to a window SF :: Mouse . set_position ( SF . vector2i ( 100 , 200 ), window ) See also: SF::Joystick , SF::Keyboard , SF::Touch Class methods # .button_pressed? ( button : Mouse :: Button ) : Bool # Check if a mouse button is pressed button - Button to check Returns: True if the button is pressed, false otherwise [ View source ] .get_position ( relative_to : Window ) : Vector2i # Get the current position of the mouse in window coordinates This function returns the current position of the mouse cursor, relative to the given window. relative_to - Reference window Returns: Current position of the mouse [ View source ] .position : Vector2i # Get the current position of the mouse in desktop coordinates This function returns the global position of the mouse cursor on the desktop. Returns: Current position of the mouse [ View source ] .position= ( position : Vector2 | Tuple ) # Set the current position of the mouse in desktop coordinates This function sets the global position of the mouse cursor on the desktop. position - New position of the mouse [ View source ] .set_position ( position : Vector2 | Tuple , relative_to : Window ) # Set the current position of the mouse in window coordinates This function sets the current position of the mouse cursor, relative to the given window. position - New position of the mouse relative_to - Reference window [ View source ]","title":"Mouse"},{"location":"api/SF/Mouse.html#SF::Mouse","text":"Give access to the real-time state of the mouse SF::Mouse provides an interface to the state of the mouse. It only contains static functions (a single mouse is assumed), so it's not meant to be instantiated. This module allows users to query the mouse state at any time and directly, without having to deal with a window and its events. Compared to the MouseMoved , MouseButtonPressed and MouseButtonReleased events, SF::Mouse can retrieve the state of the cursor and the buttons at any time (you don't need to store and update a boolean on your side in order to know if a button is pressed or released), and you always get the real state of the mouse, even if it is moved, pressed or released when your window is out of focus and no event is triggered. The position= and position functions can be used to change or retrieve the current position of the mouse pointer. There are two versions: one that operates in global coordinates (relative to the desktop) and one that operates in window coordinates (relative to a specific window). Usage example: if SF :: Mouse . button_pressed? ( SF :: Mouse :: Left ) # left click... end # get global mouse position position = SF :: Mouse . position # set mouse position relative to a window SF :: Mouse . set_position ( SF . vector2i ( 100 , 200 ), window ) See also: SF::Joystick , SF::Keyboard , SF::Touch","title":"Mouse"},{"location":"api/SF/Mouse.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Mouse.html#SF::Mouse.button_pressed?(button)","text":"Check if a mouse button is pressed button - Button to check Returns: True if the button is pressed, false otherwise [ View source ]","title":".button_pressed?"},{"location":"api/SF/Mouse.html#SF::Mouse.get_position(relative_to)","text":"Get the current position of the mouse in window coordinates This function returns the current position of the mouse cursor, relative to the given window. relative_to - Reference window Returns: Current position of the mouse [ View source ]","title":".get_position"},{"location":"api/SF/Mouse.html#SF::Mouse.position()","text":"Get the current position of the mouse in desktop coordinates This function returns the global position of the mouse cursor on the desktop. Returns: Current position of the mouse [ View source ]","title":".position"},{"location":"api/SF/Mouse.html#SF::Mouse.position=(position)","text":"Set the current position of the mouse in desktop coordinates This function sets the global position of the mouse cursor on the desktop. position - New position of the mouse [ View source ]","title":".position="},{"location":"api/SF/Mouse.html#SF::Mouse.set_position(position,relative_to)","text":"Set the current position of the mouse in window coordinates This function sets the current position of the mouse cursor, relative to the given window. position - New position of the mouse relative_to - Reference window [ View source ]","title":".set_position"},{"location":"api/SF/Music.html","text":"class SF::Music inherits SF::SoundStream # Streamed music played from an audio file Musics are sounds that are streamed rather than completely loaded in memory. This is especially useful for compressed musics that usually take hundreds of MB when they are uncompressed: by streaming it instead of loading it entirely, you avoid saturating the memory and have almost no loading delay. This implies that the underlying resource (file, stream or memory buffer) must remain valid for the lifetime of the SF::Music object. Apart from that, a SF::Music has almost the same features as the SF::SoundBuffer / SF::Sound pair: you can play/pause/stop it, request its parameters (channels, sample rate), change the way it is played (pitch, volume, 3D position, ...), etc. As a sound stream, a music is played in its own thread in order not to block the rest of the program. This means that you can leave the music alone after calling play() , it will manage itself very well. Usage example: # Declare a new music music = SF :: Music . new # Open it from an audio file if ! music . open_from_file ( \"music.ogg\" ) # error... end # Change some parameters music . set_position ( 0 , 1 , 10 ) # change its 3D position music . pitch = 2 # increase the pitch music . volume = 50 # reduce the volume music . loop = true # make it loop # Play it music . play () See also: SF::Sound , SF::SoundStream Class methods # .from_file ( * args , ** kwargs ) : self # Shorthand for music = Music.new; music.open_from_file(...); music Raises InitError on failure [ View source ] .from_memory ( * args , ** kwargs ) : self # Shorthand for music = Music.new; music.open_from_memory(...); music Raises InitError on failure [ View source ] .from_stream ( * args , ** kwargs ) : self # Shorthand for music = Music.new; music.open_from_stream(...); music Raises InitError on failure [ View source ] .new # Default constructor [ View source ] Methods # #duration : Time # Get the total duration of the music Returns: Music duration [ View source ] #finalize # Destructor [ View source ] #loop_points : Music :: TimeSpan # Get the positions of the of the sound's looping sequence Returns: Loop Time position class. Warning: Since loop_points=() performs some adjustments on the provided values and rounds them to internal samples, a call to loop_points() is not guaranteed to return the same times passed into a previous call to loop_points=() . However, it is guaranteed to return times that will map to the valid internal samples of this Music if they are later passed to loop_points=() . See also: loop_points= [ View source ] #loop_points= ( time_points : Music :: TimeSpan ) # Sets the beginning and end of the sound's looping sequence using SF::Time Loop points allow one to specify a pair of positions such that, when the music is enabled for looping, it will seamlessly seek to the beginning whenever it encounters the end. Valid ranges for time_points.offset and time_points.length are [0, Dur) and (0, Dur-offset] respectively, where Dur is the value returned by duration() . Note that the EOF \"loop point\" from the end to the beginning of the stream is still honored, in case the caller seeks to a point after the end of the loop range. This function can be safely called at any point after a stream is opened, and will be applied to a playing sound without affecting the current playing offset. Warning: Setting the loop points while the stream's status is Paused will set its status to Stopped. The playing offset will be unaffected. time_points - The definition of the loop. Can be any time points within the sound's length See also: loop_points [ View source ] #on_get_data : Slice ( Int16 )? # Request a new chunk of audio samples from the stream source This function fills the chunk from the next samples to read from the audio file. data - Chunk of data to fill Returns: True to continue playback, false to stop [ View source ] #on_loop : Int64 # Change the current playing position in the stream source to the loop offset This is called by the underlying SoundStream whenever it needs us to reset the seek position for a loop. We then determine whether we are looping on a loop point or the end-of-file, perform the seek, and return the new position. Returns: The seek position after looping (or -1 if there's no loop) [ View source ] #on_seek ( time_offset : Time ) # Change the current playing position in the stream source time_offset - New playing position, from the beginning of the music [ View source ] #open_from_file ( filename : String ) : Bool # Open a music from an audio file This function doesn't start playing the music (call play() to do so). See the documentation of SF::InputSoundFile for the list of supported formats. Warning: Since the music is not loaded at once but rather streamed continuously, the file must remain accessible until the SF::Music object loads a new music or is destroyed. filename - Path of the music file to open Returns: True if loading succeeded, false if it failed See also: open_from_memory , open_from_stream [ View source ] #open_from_memory ( data : Slice ) : Bool # Open a music from an audio file in memory This function doesn't start playing the music (call play() to do so). See the documentation of SF::InputSoundFile for the list of supported formats. Warning: Since the music is not loaded at once but rather streamed continuously, the data buffer must remain accessible until the SF::Music object loads a new music or is destroyed. That is, you can't deallocate the buffer right after calling this function. data - Slice containing the file data in memory Returns: True if loading succeeded, false if it failed See also: open_from_file , open_from_stream [ View source ] #open_from_stream ( stream : InputStream ) : Bool # Open a music from an audio file in a custom stream This function doesn't start playing the music (call play() to do so). See the documentation of SF::InputSoundFile for the list of supported formats. Warning: Since the music is not loaded at once but rather streamed continuously, the stream must remain accessible until the SF::Music object loads a new music or is destroyed. stream - Source stream to read from Returns: True if loading succeeded, false if it failed See also: open_from_file , open_from_memory [ View source ]","title":"Music"},{"location":"api/SF/Music.html#SF::Music","text":"Streamed music played from an audio file Musics are sounds that are streamed rather than completely loaded in memory. This is especially useful for compressed musics that usually take hundreds of MB when they are uncompressed: by streaming it instead of loading it entirely, you avoid saturating the memory and have almost no loading delay. This implies that the underlying resource (file, stream or memory buffer) must remain valid for the lifetime of the SF::Music object. Apart from that, a SF::Music has almost the same features as the SF::SoundBuffer / SF::Sound pair: you can play/pause/stop it, request its parameters (channels, sample rate), change the way it is played (pitch, volume, 3D position, ...), etc. As a sound stream, a music is played in its own thread in order not to block the rest of the program. This means that you can leave the music alone after calling play() , it will manage itself very well. Usage example: # Declare a new music music = SF :: Music . new # Open it from an audio file if ! music . open_from_file ( \"music.ogg\" ) # error... end # Change some parameters music . set_position ( 0 , 1 , 10 ) # change its 3D position music . pitch = 2 # increase the pitch music . volume = 50 # reduce the volume music . loop = true # make it loop # Play it music . play () See also: SF::Sound , SF::SoundStream","title":"Music"},{"location":"api/SF/Music.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Music.html#SF::Music.from_file(*args,**kwargs)","text":"Shorthand for music = Music.new; music.open_from_file(...); music Raises InitError on failure [ View source ]","title":".from_file"},{"location":"api/SF/Music.html#SF::Music.from_memory(*args,**kwargs)","text":"Shorthand for music = Music.new; music.open_from_memory(...); music Raises InitError on failure [ View source ]","title":".from_memory"},{"location":"api/SF/Music.html#SF::Music.from_stream(*args,**kwargs)","text":"Shorthand for music = Music.new; music.open_from_stream(...); music Raises InitError on failure [ View source ]","title":".from_stream"},{"location":"api/SF/Music.html#SF::Music.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/Music.html#methods","text":"","title":"Methods"},{"location":"api/SF/Music.html#SF::Music#duration()","text":"Get the total duration of the music Returns: Music duration [ View source ]","title":"#duration"},{"location":"api/SF/Music.html#SF::Music#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Music.html#SF::Music#loop_points()","text":"Get the positions of the of the sound's looping sequence Returns: Loop Time position class. Warning: Since loop_points=() performs some adjustments on the provided values and rounds them to internal samples, a call to loop_points() is not guaranteed to return the same times passed into a previous call to loop_points=() . However, it is guaranteed to return times that will map to the valid internal samples of this Music if they are later passed to loop_points=() . See also: loop_points= [ View source ]","title":"#loop_points"},{"location":"api/SF/Music.html#SF::Music#loop_points=(time_points)","text":"Sets the beginning and end of the sound's looping sequence using SF::Time Loop points allow one to specify a pair of positions such that, when the music is enabled for looping, it will seamlessly seek to the beginning whenever it encounters the end. Valid ranges for time_points.offset and time_points.length are [0, Dur) and (0, Dur-offset] respectively, where Dur is the value returned by duration() . Note that the EOF \"loop point\" from the end to the beginning of the stream is still honored, in case the caller seeks to a point after the end of the loop range. This function can be safely called at any point after a stream is opened, and will be applied to a playing sound without affecting the current playing offset. Warning: Setting the loop points while the stream's status is Paused will set its status to Stopped. The playing offset will be unaffected. time_points - The definition of the loop. Can be any time points within the sound's length See also: loop_points [ View source ]","title":"#loop_points="},{"location":"api/SF/Music.html#SF::Music#on_get_data()","text":"Request a new chunk of audio samples from the stream source This function fills the chunk from the next samples to read from the audio file. data - Chunk of data to fill Returns: True to continue playback, false to stop [ View source ]","title":"#on_get_data"},{"location":"api/SF/Music.html#SF::Music#on_loop()","text":"Change the current playing position in the stream source to the loop offset This is called by the underlying SoundStream whenever it needs us to reset the seek position for a loop. We then determine whether we are looping on a loop point or the end-of-file, perform the seek, and return the new position. Returns: The seek position after looping (or -1 if there's no loop) [ View source ]","title":"#on_loop"},{"location":"api/SF/Music.html#SF::Music#on_seek(time_offset)","text":"Change the current playing position in the stream source time_offset - New playing position, from the beginning of the music [ View source ]","title":"#on_seek"},{"location":"api/SF/Music.html#SF::Music#open_from_file(filename)","text":"Open a music from an audio file This function doesn't start playing the music (call play() to do so). See the documentation of SF::InputSoundFile for the list of supported formats. Warning: Since the music is not loaded at once but rather streamed continuously, the file must remain accessible until the SF::Music object loads a new music or is destroyed. filename - Path of the music file to open Returns: True if loading succeeded, false if it failed See also: open_from_memory , open_from_stream [ View source ]","title":"#open_from_file"},{"location":"api/SF/Music.html#SF::Music#open_from_memory(data)","text":"Open a music from an audio file in memory This function doesn't start playing the music (call play() to do so). See the documentation of SF::InputSoundFile for the list of supported formats. Warning: Since the music is not loaded at once but rather streamed continuously, the data buffer must remain accessible until the SF::Music object loads a new music or is destroyed. That is, you can't deallocate the buffer right after calling this function. data - Slice containing the file data in memory Returns: True if loading succeeded, false if it failed See also: open_from_file , open_from_stream [ View source ]","title":"#open_from_memory"},{"location":"api/SF/Music.html#SF::Music#open_from_stream(stream)","text":"Open a music from an audio file in a custom stream This function doesn't start playing the music (call play() to do so). See the documentation of SF::InputSoundFile for the list of supported formats. Warning: Since the music is not loaded at once but rather streamed continuously, the stream must remain accessible until the SF::Music object loads a new music or is destroyed. stream - Source stream to read from Returns: True if loading succeeded, false if it failed See also: open_from_file , open_from_memory [ View source ]","title":"#open_from_stream"},{"location":"api/SF/Mutex.html","text":"class SF::Mutex inherits Reference # Blocks concurrent access to shared resources from multiple threads Mutex stands for \"MUTual EXclusion\". A mutex is a synchronization object, used when multiple threads are involved. When you want to protect a part of the code from being accessed simultaneously by multiple threads, you typically use a mutex. When a thread is locked by a mutex, any other thread trying to lock it will be blocked until the mutex is released by the thread that locked it. This way, you can allow only one thread at a time to access a critical region of your code. Usage example: @database = Database . new # this is a critical resource that needs some protection @mutex = SF :: Mutex . new def thread1 () @mutex . lock () # this call will block the thread if the mutex is already locked by thread2 @database . write ( ... ) @mutex . unlock () # if thread2 was waiting, it will now be unblocked end def thread2 () @mutex . lock () # this call will block the thread if the mutex is already locked by thread1 @database . write ( ... ) @mutex . unlock () # if thread1 was waiting, it will now be unblocked end Be very careful with mutexes. A bad usage can lead to bad problems, like deadlocks (two threads are waiting for each other and the application is globally stuck). To make the usage of mutexes more robust, particularly in environments where exceptions can be thrown, you should use the helper method synchronize to lock/unlock mutexes. SFML mutexes are recursive, which means that you can lock a mutex multiple times in the same thread without creating a deadlock. In this case, the first call to lock() behaves as usual, and the following ones have no effect. However, you must call unlock() exactly as many times as you called lock() . If you don't, the mutex won't be released. However, you must call unlock() exactly as many times as you called lock(). If you don't, the mutex won't be released. See also: SF::Lock Included modules # SF::NonCopyable Class methods # .new # Default constructor [ View source ] Methods # #finalize # Destructor [ View source ] #lock # Lock the mutex If the mutex is already locked in another thread, this call will block the execution until the mutex is released. See also: unlock [ View source ] #synchronize # Lock the mutex, execute the block, then unlock the mutex (even if an exception is raised). [ View source ] #unlock # Unlock the mutex See also: lock [ View source ]","title":"Mutex"},{"location":"api/SF/Mutex.html#SF::Mutex","text":"Blocks concurrent access to shared resources from multiple threads Mutex stands for \"MUTual EXclusion\". A mutex is a synchronization object, used when multiple threads are involved. When you want to protect a part of the code from being accessed simultaneously by multiple threads, you typically use a mutex. When a thread is locked by a mutex, any other thread trying to lock it will be blocked until the mutex is released by the thread that locked it. This way, you can allow only one thread at a time to access a critical region of your code. Usage example: @database = Database . new # this is a critical resource that needs some protection @mutex = SF :: Mutex . new def thread1 () @mutex . lock () # this call will block the thread if the mutex is already locked by thread2 @database . write ( ... ) @mutex . unlock () # if thread2 was waiting, it will now be unblocked end def thread2 () @mutex . lock () # this call will block the thread if the mutex is already locked by thread1 @database . write ( ... ) @mutex . unlock () # if thread1 was waiting, it will now be unblocked end Be very careful with mutexes. A bad usage can lead to bad problems, like deadlocks (two threads are waiting for each other and the application is globally stuck). To make the usage of mutexes more robust, particularly in environments where exceptions can be thrown, you should use the helper method synchronize to lock/unlock mutexes. SFML mutexes are recursive, which means that you can lock a mutex multiple times in the same thread without creating a deadlock. In this case, the first call to lock() behaves as usual, and the following ones have no effect. However, you must call unlock() exactly as many times as you called lock() . If you don't, the mutex won't be released. However, you must call unlock() exactly as many times as you called lock(). If you don't, the mutex won't be released. See also: SF::Lock","title":"Mutex"},{"location":"api/SF/Mutex.html#included-modules","text":"SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Mutex.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Mutex.html#SF::Mutex.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/Mutex.html#methods","text":"","title":"Methods"},{"location":"api/SF/Mutex.html#SF::Mutex#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Mutex.html#SF::Mutex#lock()","text":"Lock the mutex If the mutex is already locked in another thread, this call will block the execution until the mutex is released. See also: unlock [ View source ]","title":"#lock"},{"location":"api/SF/Mutex.html#SF::Mutex#synchronize()","text":"Lock the mutex, execute the block, then unlock the mutex (even if an exception is raised). [ View source ]","title":"#synchronize"},{"location":"api/SF/Mutex.html#SF::Mutex#unlock()","text":"Unlock the mutex See also: lock [ View source ]","title":"#unlock"},{"location":"api/SF/NonCopyable.html","text":"module SF::NonCopyable # Empty module that indicates the objects of the class can't be copied Direct including types # SF::Context SF::Cursor SF::FileInputStream SF::Ftp SF::Http SF::Mutex SF::RenderTarget SF::Shader SF::Socket SF::Thread SF::Window","title":"NonCopyable"},{"location":"api/SF/NonCopyable.html#SF::NonCopyable","text":"Empty module that indicates the objects of the class can't be copied","title":"NonCopyable"},{"location":"api/SF/NonCopyable.html#direct-including-types","text":"SF::Context SF::Cursor SF::FileInputStream SF::Ftp SF::Http SF::Mutex SF::RenderTarget SF::Shader SF::Socket SF::Thread SF::Window","title":"Direct including types"},{"location":"api/SF/Packet.html","text":"class SF::Packet inherits Reference # Utility class to build blocks of data to transfer over the network Packets provide a safe and easy way to serialize data, in order to send it over the network using sockets ( SF::TcpSocket , SF::UdpSocket ). Packets solve 2 fundamental problems that arise when transferring data over the network: data is interpreted correctly according to the endianness the bounds of the packet are preserved (one send == one receive) The SF::Packet class provides both input and output, using read and write methods. It is recommended to use only fixed-size types (like Int32 , etc.), to avoid possible differences between the sender and the receiver. Usage example: x = 24u32 s = \"hello\" d = 5.89 # Group the variables to send into a packet packet = SF :: Packet . new packet . write x packet . write s packet . write d # Send it over the network (socket is a valid SF::TcpSocket) socket . send packet ----------------------------------------------------------------- # Receive the packet at the other end packet = SF :: Packet . new socket . receive ( packet ) # Extract the variables contained in the packet x = packet . read UInt32 s = packet . read String d = packet . read Float64 if packet . valid? # Data extracted successfully... end Packets have overloads of read and write methods for standard types: Bool Fixed-size integer types ( Int8/16/32/64 , UInt8/16/32/64 ) Floating point numbers ( Float32/64 ) String Like standard streams, it is also possible to define your own overloads of these methods in order to handle your custom types. struct MyStruct number : Float32 integer : Int8 str : String end class SF:: Packet def write ( m : MyStruct ) write m . number write m . integer write m . str end def read ( type : MyStruct . class ) : MyStruct MyStruct . new ( packet . read ( Float32 ), packet . read ( Int8 ), packet . read ( String )) end end See also: SF::TcpSocket , SF::UdpSocket Class methods # .new # Default constructor Creates an empty packet. [ View source ] Methods # #append ( data : Slice ) # Append data to the end of the packet data - Pointer to the sequence of bytes to append size_in_bytes - Number of bytes to append See also: clear [ View source ] #clear # Clear the packet After calling Clear, the packet is empty. See also: append [ View source ] #data : Pointer ( Void ) # Get a pointer to the data contained in the packet Warning: the returned pointer may become invalid after you append data to the packet, therefore it should never be stored. The return pointer is NULL if the packet is empty. Returns: Pointer to the data See also: data_size [ View source ] #data_size : Int32 # Get the size of the data contained in the packet This function returns the number of bytes pointed to by what data returns. Returns: Data size, in bytes See also: data [ View source ] #dup : Packet # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #end_of_packet : Bool # Tell if the reading position has reached the end of the packet This function is useful to know if there is some data left to be read, without actually reading it. Returns: True if all data was read, false otherwise See also: operator bool [ View source ] #finalize # Virtual destructor [ View source ] #read ( type : Bool . class ) : Bool # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : Float32 . class ) : Float32 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : String . class ) : String # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : Float64 . class ) : Float64 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : UInt64 . class ) : UInt64 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : Int64 . class ) : Int64 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : UInt32 . class ) : UInt32 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : Int32 . class ) : Int32 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : UInt16 . class ) : UInt16 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : Int16 . class ) : Int16 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : UInt8 . class ) : UInt8 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #read ( type : Int8 . class ) : Int8 # Read data from the packet. The expected type corresponds to what was actually sent. [ View source ] #valid? : Bool # Test the validity of the packet, for reading This operator allows to test the packet as a boolean variable, to check if a reading operation was successful. A packet will be in an invalid state if it has no more data to read. This behavior is the same as standard C++ streams. Usage example: x = packet . read ( Float32 ) if packet . valid? # ok, x was extracted successfully end Returns: True if last data extraction from packet was successful See also: end_of_packet [ View source ] #write ( data : String ) # Write data into the packet [ View source ] #write ( data : Float64 ) # Write data into the packet [ View source ] #write ( data : Float32 ) # Write data into the packet [ View source ] #write ( data : UInt64 ) # Write data into the packet [ View source ] #write ( data : Int64 ) # Write data into the packet [ View source ] #write ( data : UInt32 ) # Write data into the packet [ View source ] #write ( data : Int32 ) # Write data into the packet [ View source ] #write ( data : UInt16 ) # Write data into the packet [ View source ] #write ( data : Int16 ) # Write data into the packet [ View source ] #write ( data : UInt8 ) # Write data into the packet [ View source ] #write ( data : Int8 ) # Write data into the packet [ View source ] #write ( data : Bool ) # Write data into the packet [ View source ]","title":"Packet"},{"location":"api/SF/Packet.html#SF::Packet","text":"Utility class to build blocks of data to transfer over the network Packets provide a safe and easy way to serialize data, in order to send it over the network using sockets ( SF::TcpSocket , SF::UdpSocket ). Packets solve 2 fundamental problems that arise when transferring data over the network: data is interpreted correctly according to the endianness the bounds of the packet are preserved (one send == one receive) The SF::Packet class provides both input and output, using read and write methods. It is recommended to use only fixed-size types (like Int32 , etc.), to avoid possible differences between the sender and the receiver. Usage example: x = 24u32 s = \"hello\" d = 5.89 # Group the variables to send into a packet packet = SF :: Packet . new packet . write x packet . write s packet . write d # Send it over the network (socket is a valid SF::TcpSocket) socket . send packet ----------------------------------------------------------------- # Receive the packet at the other end packet = SF :: Packet . new socket . receive ( packet ) # Extract the variables contained in the packet x = packet . read UInt32 s = packet . read String d = packet . read Float64 if packet . valid? # Data extracted successfully... end Packets have overloads of read and write methods for standard types: Bool Fixed-size integer types ( Int8/16/32/64 , UInt8/16/32/64 ) Floating point numbers ( Float32/64 ) String Like standard streams, it is also possible to define your own overloads of these methods in order to handle your custom types. struct MyStruct number : Float32 integer : Int8 str : String end class SF:: Packet def write ( m : MyStruct ) write m . number write m . integer write m . str end def read ( type : MyStruct . class ) : MyStruct MyStruct . new ( packet . read ( Float32 ), packet . read ( Int8 ), packet . read ( String )) end end See also: SF::TcpSocket , SF::UdpSocket","title":"Packet"},{"location":"api/SF/Packet.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Packet.html#SF::Packet.new()","text":"Default constructor Creates an empty packet. [ View source ]","title":".new"},{"location":"api/SF/Packet.html#methods","text":"","title":"Methods"},{"location":"api/SF/Packet.html#SF::Packet#append(data)","text":"Append data to the end of the packet data - Pointer to the sequence of bytes to append size_in_bytes - Number of bytes to append See also: clear [ View source ]","title":"#append"},{"location":"api/SF/Packet.html#SF::Packet#clear()","text":"Clear the packet After calling Clear, the packet is empty. See also: append [ View source ]","title":"#clear"},{"location":"api/SF/Packet.html#SF::Packet#data()","text":"Get a pointer to the data contained in the packet Warning: the returned pointer may become invalid after you append data to the packet, therefore it should never be stored. The return pointer is NULL if the packet is empty. Returns: Pointer to the data See also: data_size [ View source ]","title":"#data"},{"location":"api/SF/Packet.html#SF::Packet#data_size()","text":"Get the size of the data contained in the packet This function returns the number of bytes pointed to by what data returns. Returns: Data size, in bytes See also: data [ View source ]","title":"#data_size"},{"location":"api/SF/Packet.html#SF::Packet#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Packet.html#SF::Packet#end_of_packet()","text":"Tell if the reading position has reached the end of the packet This function is useful to know if there is some data left to be read, without actually reading it. Returns: True if all data was read, false otherwise See also: operator bool [ View source ]","title":"#end_of_packet"},{"location":"api/SF/Packet.html#SF::Packet#finalize()","text":"Virtual destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#read(type)","text":"Read data from the packet. The expected type corresponds to what was actually sent. [ View source ]","title":"#read"},{"location":"api/SF/Packet.html#SF::Packet#valid?()","text":"Test the validity of the packet, for reading This operator allows to test the packet as a boolean variable, to check if a reading operation was successful. A packet will be in an invalid state if it has no more data to read. This behavior is the same as standard C++ streams. Usage example: x = packet . read ( Float32 ) if packet . valid? # ok, x was extracted successfully end Returns: True if last data extraction from packet was successful See also: end_of_packet [ View source ]","title":"#valid?"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/Packet.html#SF::Packet#write(data)","text":"Write data into the packet [ View source ]","title":"#write"},{"location":"api/SF/PrimitiveType.html","text":"enum SF::PrimitiveType # Types of primitives that a SF::VertexArray can render Points and lines have no area, therefore their thickness will always be 1 pixel, regardless the current transform and view. Members # Points # List of individual points Lines # List of individual lines LineStrip # List of connected lines, a point uses the previous point to form a line Triangles # List of individual triangles TriangleStrip # List of connected triangles, a point uses the two previous points to form a triangle TriangleFan # List of connected triangles, a point uses the common center and the previous point to form a triangle Quads # List of individual quads (deprecated, don't work with OpenGL ES) LinesStrip # DEPRECATED: Use LineStrip instead TrianglesStrip # DEPRECATED: Use TriangleStrip instead TrianglesFan # DEPRECATED: Use TriangleFan instead Methods # #line_strip? # [ View source ] #lines? # [ View source ] #lines_strip? # [ View source ] #points? # [ View source ] #quads? # [ View source ] #triangle_fan? # [ View source ] #triangle_strip? # [ View source ] #triangles? # [ View source ] #triangles_fan? # [ View source ] #triangles_strip? # [ View source ]","title":"PrimitiveType"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType","text":"Types of primitives that a SF::VertexArray can render Points and lines have no area, therefore their thickness will always be 1 pixel, regardless the current transform and view.","title":"PrimitiveType"},{"location":"api/SF/PrimitiveType.html#members","text":"","title":"Members"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::Points","text":"List of individual points","title":"Points"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::Lines","text":"List of individual lines","title":"Lines"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::LineStrip","text":"List of connected lines, a point uses the previous point to form a line","title":"LineStrip"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::Triangles","text":"List of individual triangles","title":"Triangles"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::TriangleStrip","text":"List of connected triangles, a point uses the two previous points to form a triangle","title":"TriangleStrip"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::TriangleFan","text":"List of connected triangles, a point uses the common center and the previous point to form a triangle","title":"TriangleFan"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::Quads","text":"List of individual quads (deprecated, don't work with OpenGL ES)","title":"Quads"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::LinesStrip","text":"DEPRECATED: Use LineStrip instead","title":"LinesStrip"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::TrianglesStrip","text":"DEPRECATED: Use TriangleStrip instead","title":"TrianglesStrip"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType::TrianglesFan","text":"DEPRECATED: Use TriangleFan instead","title":"TrianglesFan"},{"location":"api/SF/PrimitiveType.html#methods","text":"","title":"Methods"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#line_strip?()","text":"[ View source ]","title":"#line_strip?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#lines?()","text":"[ View source ]","title":"#lines?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#lines_strip?()","text":"[ View source ]","title":"#lines_strip?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#points?()","text":"[ View source ]","title":"#points?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#quads?()","text":"[ View source ]","title":"#quads?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#triangle_fan?()","text":"[ View source ]","title":"#triangle_fan?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#triangle_strip?()","text":"[ View source ]","title":"#triangle_strip?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#triangles?()","text":"[ View source ]","title":"#triangles?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#triangles_fan?()","text":"[ View source ]","title":"#triangles_fan?"},{"location":"api/SF/PrimitiveType.html#SF::PrimitiveType#triangles_strip?()","text":"[ View source ]","title":"#triangles_strip?"},{"location":"api/SF/Rect.html","text":"struct SF::Rect(T) inherits Struct # Utility struct for manipulating 2D axis aligned rectangles A rectangle is defined by its top-left corner and its size. It is a very simple struct defined for convenience, so its member variables ( left , top , width and height ) can be accessed directly, just like the vector classes ( Vector2 and Vector3 ). To keep things simple, SF::Rect doesn't define functions to emulate the properties that are not directly members (such as right, bottom, center, etc.), it rather only provides intersection functions. SF::Rect uses the usual rules for its boundaries: The left and top edges are included in the rectangle's area The right (left + width) and bottom (top + height) edges are excluded from the rectangle's area This means that SF::IntRect.new(0, 0, 1, 1) and SF::IntRect.new(1, 1, 1, 1) don't intersect. SF::Rect is a generic and may be used with any numeric type, but for simplicity the instantiations used by SFML are aliased: SF::Rect(Int32) is SF::IntRect SF::Rect(Float32) is SF::FloatRect So that you don't have to care about the template syntax. See also: SF.int_rect , SF.float_rect . Usage example: # Define a rectangle, located at (0, 0) with a size of 20x5 r1 = SF . int_rect ( 0 , 0 , 20 , 5 ) # Define another rectangle, located at (4, 2) with a size of 18x10 position = SF . vector2i ( 4 , 2 ) size = SF . vector2i ( 18 , 10 ) r2 = SF :: IntRect . new ( position , size ) # Test intersections with the point (3, 1) r1 . contains? ( 3 , 1 ) #=> true r2 . contains? ( 3 , 1 ) #=> false # Test the intersection between r1 and r2 r1 . intersects? ( r2 ) #=> (4, 2, 16, 3) Class methods # .new ( left : T , top : T , width : T , height : T ) # Construct the rectangle from its coordinates Be careful, the last two parameters are the width and height, not the right and bottom coordinates! [ View source ] .new ( position : Vector2 ( T ), size : Vector2 ( T )) # Construct the rectangle from position and size Be careful, the last parameter is the size, not the bottom-right corner! [ View source ] .new # Default constructor: equivalent to new(0, 0, 0, 0) [ View source ] Methods # #== ( other : self ) : Bool # Returns true if all corresponding coordinates of two rects are equal [ View source ] #contains? ( x : Number , y : Number ) : Bool # Returns true if a point is inside the rectangle's area [ View source ] #contains? ( point : Vector2 | Tuple ) : Bool # Returns true if a point is inside the rectangle's area [ View source ] #height : T # Height of the rectangle [ View source ] #height= ( height : T ) # Height of the rectangle [ View source ] #intersects? ( other : Rect ( T )) : Rect ( T )? # Check the intersection between two rectangles Returns the overlapped rectangle or nil if there is no overlap. [ View source ] #left : T # Left coordinate of the rectangle [ View source ] #left= ( left : T ) # Left coordinate of the rectangle [ View source ] #top : T # Top coordinate of the rectangle [ View source ] #top= ( top : T ) # Top coordinate of the rectangle [ View source ] #width : T # Width of the rectangle [ View source ] #width= ( width : T ) # Width of the rectangle [ View source ]","title":"Rect"},{"location":"api/SF/Rect.html#SF::Rect","text":"Utility struct for manipulating 2D axis aligned rectangles A rectangle is defined by its top-left corner and its size. It is a very simple struct defined for convenience, so its member variables ( left , top , width and height ) can be accessed directly, just like the vector classes ( Vector2 and Vector3 ). To keep things simple, SF::Rect doesn't define functions to emulate the properties that are not directly members (such as right, bottom, center, etc.), it rather only provides intersection functions. SF::Rect uses the usual rules for its boundaries: The left and top edges are included in the rectangle's area The right (left + width) and bottom (top + height) edges are excluded from the rectangle's area This means that SF::IntRect.new(0, 0, 1, 1) and SF::IntRect.new(1, 1, 1, 1) don't intersect. SF::Rect is a generic and may be used with any numeric type, but for simplicity the instantiations used by SFML are aliased: SF::Rect(Int32) is SF::IntRect SF::Rect(Float32) is SF::FloatRect So that you don't have to care about the template syntax. See also: SF.int_rect , SF.float_rect . Usage example: # Define a rectangle, located at (0, 0) with a size of 20x5 r1 = SF . int_rect ( 0 , 0 , 20 , 5 ) # Define another rectangle, located at (4, 2) with a size of 18x10 position = SF . vector2i ( 4 , 2 ) size = SF . vector2i ( 18 , 10 ) r2 = SF :: IntRect . new ( position , size ) # Test intersections with the point (3, 1) r1 . contains? ( 3 , 1 ) #=> true r2 . contains? ( 3 , 1 ) #=> false # Test the intersection between r1 and r2 r1 . intersects? ( r2 ) #=> (4, 2, 16, 3)","title":"Rect"},{"location":"api/SF/Rect.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Rect.html#SF::Rect.new(left,top,width,height)","text":"Construct the rectangle from its coordinates Be careful, the last two parameters are the width and height, not the right and bottom coordinates! [ View source ]","title":".new"},{"location":"api/SF/Rect.html#methods","text":"","title":"Methods"},{"location":"api/SF/Rect.html#SF::Rect#==(other)","text":"Returns true if all corresponding coordinates of two rects are equal [ View source ]","title":"#=="},{"location":"api/SF/Rect.html#SF::Rect#contains?(x,y)","text":"Returns true if a point is inside the rectangle's area [ View source ]","title":"#contains?"},{"location":"api/SF/Rect.html#SF::Rect#height()","text":"Height of the rectangle [ View source ]","title":"#height"},{"location":"api/SF/Rect.html#SF::Rect#height=(height)","text":"Height of the rectangle [ View source ]","title":"#height="},{"location":"api/SF/Rect.html#SF::Rect#intersects?(other)","text":"Check the intersection between two rectangles Returns the overlapped rectangle or nil if there is no overlap. [ View source ]","title":"#intersects?"},{"location":"api/SF/Rect.html#SF::Rect#left()","text":"Left coordinate of the rectangle [ View source ]","title":"#left"},{"location":"api/SF/Rect.html#SF::Rect#left=(left)","text":"Left coordinate of the rectangle [ View source ]","title":"#left="},{"location":"api/SF/Rect.html#SF::Rect#top()","text":"Top coordinate of the rectangle [ View source ]","title":"#top"},{"location":"api/SF/Rect.html#SF::Rect#top=(top)","text":"Top coordinate of the rectangle [ View source ]","title":"#top="},{"location":"api/SF/Rect.html#SF::Rect#width()","text":"Width of the rectangle [ View source ]","title":"#width"},{"location":"api/SF/Rect.html#SF::Rect#width=(width)","text":"Width of the rectangle [ View source ]","title":"#width="},{"location":"api/SF/RectangleShape.html","text":"class SF::RectangleShape inherits SF::Shape # Specialized shape representing a rectangle This class inherits all the functions of SF::Transformable (position, rotation, scale, bounds, ...) as well as the functions of SF::Shape (outline, color, texture, ...). Usage example: rectangle = SF :: RectangleShape . new rectangle . size = SF . vector2f ( 100 , 50 ) rectangle . outline_color = SF :: Color :: Red rectangle . outline_thickness = 5 rectangle . position = { 10 , 20 } ... window . draw rectangle See also: SF::Shape , SF::CircleShape , SF::ConvexShape Class methods # .new ( size : Vector2 | Tuple = Vector2 . new ( 0 , 0 )) # Default constructor size - Size of the rectangle [ View source ] Methods # #dup : RectangleShape # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Virtual destructor [ View source ] #get_point ( index : Int ) : Vector2f # Get a point of the rectangle The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0..3 Returns: index-th point of the shape [ View source ] #point_count : Int32 # Get the number of points defining the shape Returns: Number of points of the shape. For rectangle shapes, this number is always 4. [ View source ] #size : Vector2f # Get the size of the rectangle Returns: Size of the rectangle See also: size= [ View source ] #size= ( size : Vector2 | Tuple ) # Set the size of the rectangle size - New size of the rectangle See also: size [ View source ]","title":"RectangleShape"},{"location":"api/SF/RectangleShape.html#SF::RectangleShape","text":"Specialized shape representing a rectangle This class inherits all the functions of SF::Transformable (position, rotation, scale, bounds, ...) as well as the functions of SF::Shape (outline, color, texture, ...). Usage example: rectangle = SF :: RectangleShape . new rectangle . size = SF . vector2f ( 100 , 50 ) rectangle . outline_color = SF :: Color :: Red rectangle . outline_thickness = 5 rectangle . position = { 10 , 20 } ... window . draw rectangle See also: SF::Shape , SF::CircleShape , SF::ConvexShape","title":"RectangleShape"},{"location":"api/SF/RectangleShape.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/RectangleShape.html#SF::RectangleShape.new(size)","text":"Default constructor size - Size of the rectangle [ View source ]","title":".new"},{"location":"api/SF/RectangleShape.html#methods","text":"","title":"Methods"},{"location":"api/SF/RectangleShape.html#SF::RectangleShape#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/RectangleShape.html#SF::RectangleShape#finalize()","text":"Virtual destructor [ View source ]","title":"#finalize"},{"location":"api/SF/RectangleShape.html#SF::RectangleShape#get_point(index)","text":"Get a point of the rectangle The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0..3 Returns: index-th point of the shape [ View source ]","title":"#get_point"},{"location":"api/SF/RectangleShape.html#SF::RectangleShape#point_count()","text":"Get the number of points defining the shape Returns: Number of points of the shape. For rectangle shapes, this number is always 4. [ View source ]","title":"#point_count"},{"location":"api/SF/RectangleShape.html#SF::RectangleShape#size()","text":"Get the size of the rectangle Returns: Size of the rectangle See also: size= [ View source ]","title":"#size"},{"location":"api/SF/RectangleShape.html#SF::RectangleShape#size=(size)","text":"Set the size of the rectangle size - New size of the rectangle See also: size [ View source ]","title":"#size="},{"location":"api/SF/RenderStates.html","text":"struct SF::RenderStates inherits Struct # Define the states used for drawing to a RenderTarget There are four global states that can be applied to the drawn objects: the blend mode: how pixels of the object are blended with the background the transform: how the object is positioned/rotated/scaled the texture: what image is mapped to the object the shader: what custom effect is applied to the object High-level objects such as sprites or text force some of these states when they are drawn. For example, a sprite will set its own texture, so that you don't have to care about it when drawing the sprite. The transform is a special case: sprites, texts and shapes (and it's a good idea to do it with your own drawable classes too) combine their transform with the one that is passed in the RenderStates structure. So that you can use a \"global\" transform on top of each object's transform. Most objects, especially high-level drawables, can be drawn directly without defining render states explicitly -- the default set of states is OK in most cases. window . draw ( sprite ) If you want to use a single specific render state, for example a shader, you can pass it to the constructor of SF::RenderStates . window . draw ( sprite , SF :: RenderStates . new ( shader )) When you're inside the Draw function of a drawable object (one that includes SF::Drawable ), you can either pass the render states unmodified, or change some of them. For example, a transformable object will combine the current transform with its own transform. A sprite will set its texture. Etc. See also: SF::RenderTarget , SF::Drawable Constants # Default # Special instance holding the default render states Class methods # .new ( blend_mode : BlendMode , transform : Transform , texture : Texture? , shader : Shader? ) # Construct a set of render states with all its attributes blend_mode - Blend mode to use transform - Transform to use texture - Texture to use shader - Shader to use [ View source ] .new ( blend_mode : BlendMode ) # Construct a default set of render states with a custom blend mode blend_mode - Blend mode to use [ View source ] .new ( transform : Transform ) # Construct a default set of render states with a custom transform transform - Transform to use [ View source ] .new ( texture : Texture? ) # Construct a default set of render states with a custom texture texture - Texture to use [ View source ] .new ( shader : Shader? ) # Construct a default set of render states with a custom shader shader - Shader to use [ View source ] .new # Default constructor Constructing a default set of render states is equivalent to using SF::RenderStates::Default . The default set defines: the BlendAlpha blend mode the identity transform a null texture a null shader [ View source ] Methods # #blend_mode : BlendMode # Blending mode [ View source ] #blend_mode= ( blend_mode : BlendMode ) # [ View source ] #dup : RenderStates # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #inspect ( io ) # [ View source ] #shader : Shader? # Shader [ View source ] #shader= ( shader : Shader? ) # [ View source ] #texture : Texture? # Texture [ View source ] #texture= ( texture : Texture? ) # [ View source ] #transform : Transform # Transform [ View source ] #transform= ( transform : Transform ) # [ View source ]","title":"RenderStates"},{"location":"api/SF/RenderStates.html#SF::RenderStates","text":"Define the states used for drawing to a RenderTarget There are four global states that can be applied to the drawn objects: the blend mode: how pixels of the object are blended with the background the transform: how the object is positioned/rotated/scaled the texture: what image is mapped to the object the shader: what custom effect is applied to the object High-level objects such as sprites or text force some of these states when they are drawn. For example, a sprite will set its own texture, so that you don't have to care about it when drawing the sprite. The transform is a special case: sprites, texts and shapes (and it's a good idea to do it with your own drawable classes too) combine their transform with the one that is passed in the RenderStates structure. So that you can use a \"global\" transform on top of each object's transform. Most objects, especially high-level drawables, can be drawn directly without defining render states explicitly -- the default set of states is OK in most cases. window . draw ( sprite ) If you want to use a single specific render state, for example a shader, you can pass it to the constructor of SF::RenderStates . window . draw ( sprite , SF :: RenderStates . new ( shader )) When you're inside the Draw function of a drawable object (one that includes SF::Drawable ), you can either pass the render states unmodified, or change some of them. For example, a transformable object will combine the current transform with its own transform. A sprite will set its texture. Etc. See also: SF::RenderTarget , SF::Drawable","title":"RenderStates"},{"location":"api/SF/RenderStates.html#constants","text":"","title":"Constants"},{"location":"api/SF/RenderStates.html#SF::RenderStates::Default","text":"Special instance holding the default render states","title":"Default"},{"location":"api/SF/RenderStates.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/RenderStates.html#SF::RenderStates.new(blend_mode,transform,texture,shader)","text":"Construct a set of render states with all its attributes blend_mode - Blend mode to use transform - Transform to use texture - Texture to use shader - Shader to use [ View source ]","title":".new"},{"location":"api/SF/RenderStates.html#methods","text":"","title":"Methods"},{"location":"api/SF/RenderStates.html#SF::RenderStates#blend_mode()","text":"Blending mode [ View source ]","title":"#blend_mode"},{"location":"api/SF/RenderStates.html#SF::RenderStates#blend_mode=(blend_mode)","text":"[ View source ]","title":"#blend_mode="},{"location":"api/SF/RenderStates.html#SF::RenderStates#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/RenderStates.html#SF::RenderStates#inspect(io)","text":"[ View source ]","title":"#inspect"},{"location":"api/SF/RenderStates.html#SF::RenderStates#shader()","text":"Shader [ View source ]","title":"#shader"},{"location":"api/SF/RenderStates.html#SF::RenderStates#shader=(shader)","text":"[ View source ]","title":"#shader="},{"location":"api/SF/RenderStates.html#SF::RenderStates#texture()","text":"Texture [ View source ]","title":"#texture"},{"location":"api/SF/RenderStates.html#SF::RenderStates#texture=(texture)","text":"[ View source ]","title":"#texture="},{"location":"api/SF/RenderStates.html#SF::RenderStates#transform()","text":"Transform [ View source ]","title":"#transform"},{"location":"api/SF/RenderStates.html#SF::RenderStates#transform=(transform)","text":"[ View source ]","title":"#transform="},{"location":"api/SF/RenderTarget.html","text":"module SF::RenderTarget # Base module for all render targets (window, texture, ...) SF::RenderTarget defines the common behavior of all the 2D render targets usable in the graphics module. It makes it possible to draw 2D entities like sprites, shapes, text without using any OpenGL command directly. A SF::RenderTarget is also able to use views ( SF::View ), which are a kind of 2D cameras. With views you can globally scroll, rotate or zoom everything that is drawn, without having to transform every single entity. See the documentation of SF::View for more details and sample pieces of code about this module. On top of that, render targets are still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. When doing so, make sure that OpenGL states are not messed up by calling the push_gl_states/pop_gl_states functions. See also: SF::RenderWindow , SF::RenderTexture , SF::View Included modules # SF::NonCopyable Direct including types # SF::RenderTexture SF::RenderWindow Methods # #active= ( active : Bool = true ) : Bool # Activate or deactivate the render target for rendering This function makes the render target's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff). A render target's context is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target don't forget to activate it again. Activating a render target will automatically deactivate the previously active context (if any). active - True to activate, false to deactivate Returns: True if operation was successful, false otherwise [ View source ] #clear ( color : Color = Color . new ( 0 , 0 , 0 , 255 )) # Clear the entire target with a single color This function is usually called once every frame, to clear the previous contents of the target. color - Fill color to use to clear the render target [ View source ] #default_view : View # Get the default view of the render target The default view has the initial size of the render target, and never changes after the target has been created. Returns: The default view of the render target See also: view= , view [ View source ] #draw ( drawable : Drawable , states : RenderStates = RenderStates :: Default ) # Draw a drawable object to the render target. Shorthand for Drawable#draw(self, states) drawable - Object to draw states - Render states to use for drawing [ View source ] #draw ( vertex_buffer : VertexBuffer , states : RenderStates = RenderStates :: Default ) # Draw primitives defined by a vertex buffer vertex_buffer - Vertex buffer states - Render states to use for drawing [ View source ] #draw ( vertex_buffer : VertexBuffer , first_vertex : Int , vertex_count : Int , states : RenderStates = RenderStates :: Default ) # Draw primitives defined by a vertex buffer vertex_buffer - Vertex buffer first_vertex - Index of the first vertex to render vertex_count - Number of vertices to render states - Render states to use for drawing [ View source ] #draw ( vertices : Array ( Vertex ) | Slice ( Vertex ), type : PrimitiveType , states : RenderStates = RenderStates :: Default ) # Draw primitives defined by an array of vertices vertices - Pointer to the vertices vertex_count - Number of vertices in the array type - Type of primitives to draw states - Render states to use for drawing [ View source ] #get_viewport ( view : View ) : IntRect # Get the viewport of a view, applied to this render target The viewport is defined in the view as a ratio, this function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the viewport actually covers in the target. view - The view for which we want to compute the viewport Returns: Viewport rectangle, expressed in pixels [ View source ] #map_coords_to_pixel ( point : Vector2 | Tuple , view : View ) : Vector2i # Convert a point from world coordinates to target coordinates This function finds the pixel of the render target that matches the given 2D point. In other words, it goes through the same process as the graphics card, to compute the final position of a rendered point. Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom view or resize your render target, this assertion is not true anymore, i.e. a point located at (150, 75) in your 2D world may map to the pixel (10, 50) of your render target -- if the view is translated by (140, 25). This version uses a custom view for calculations, see the other overload of the function if you want to use the current view of the render target. point - Point to convert view - The view to use for converting the point Returns: The converted point, in target coordinates (pixels) See also: map_pixel_to_coords [ View source ] #map_coords_to_pixel ( point : Vector2 | Tuple ) : Vector2i # Convert a point from world coordinates to target coordinates, using the current view This function is an overload of the map_coords_to_pixel function that implicitly uses the current view. It is equivalent to: target . map_coords_to_pixel ( point , target . view ) point - Point to convert Returns: The converted point, in target coordinates (pixels) See also: map_pixel_to_coords [ View source ] #map_pixel_to_coords ( point : Vector2 | Tuple ) : Vector2f # Convert a point from target coordinates to world coordinates, using the current view This function is an overload of the map_pixel_to_coords function that implicitly uses the current view. It is equivalent to: target . map_pixel_to_coords ( point , target . view ) point - Pixel to convert Returns: The converted point, in \"world\" coordinates See also: map_coords_to_pixel [ View source ] #map_pixel_to_coords ( point : Vector2 | Tuple , view : View ) : Vector2f # Convert a point from target coordinates to world coordinates This function finds the 2D position that matches the given pixel of the render target. In other words, it does the inverse of what the graphics card does, to find the initial position of a rendered pixel. Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom view or resize your render target, this assertion is not true anymore, i.e. a point located at (10, 50) in your render target may map to the point (150, 75) in your 2D world -- if the view is translated by (140, 25). For render-windows, this function is typically used to find which point (or object) is located below the mouse cursor. This version uses a custom view for calculations, see the other overload of the function if you want to use the current view of the render target. point - Pixel to convert view - The view to use for converting the point Returns: The converted point, in \"world\" units See also: map_coords_to_pixel [ View source ] #pop_gl_states # Restore the previously saved OpenGL render states and matrices See the description of push_gl_states to get a detailed description of these functions. See also: push_gl_states [ View source ] #push_gl_states # Save the current OpenGL render states and matrices This function can be used when you mix SFML drawing and direct OpenGL rendering. Combined with pop_gl_states, it ensures that: SFML's internal states are not messed up by your OpenGL code your OpenGL states are not modified by a call to a SFML function More specifically, it must be used around code that calls Draw functions. Example: # OpenGL code here... window . push_gl_states () window . draw ( ... ) window . draw ( ... ) window . pop_gl_states () # OpenGL code here... Note that this function is quite expensive: it saves all the possible OpenGL states and matrices, even the ones you don't care about. Therefore it should be used wisely. It is provided for convenience, but the best results will be achieved if you handle OpenGL states yourself (because you know which states have really changed, and need to be saved and restored). Take a look at the reset_gl_states function if you do so. See also: pop_gl_states [ View source ] #reset_gl_states # Reset the internal OpenGL states so that the target is ready for drawing This function can be used when you mix SFML drawing and direct OpenGL rendering, if you choose not to use push_gl_states/pop_gl_states. It makes sure that all OpenGL states needed by SFML are set, so that subsequent draw() calls will work as expected. Example: # OpenGL code here... glPushAttrib ( ... ) window . reset_gl_states () window . draw ( ... ) window . draw ( ... ) glPopAttrib ( ... ) # OpenGL code here... [ View source ] abstract #size : Vector2u # Return the size of the rendering region of the target Returns: Size in pixels [ View source ] #view : View # Get the view currently in use in the render target Returns: The view object that is currently used See also: view= , default_view [ View source ] #view= ( view : View ) # Change the current active view The view is like a 2D camera, it controls which part of the 2D scene is visible, and how it is viewed in the render target. The new view will affect everything that is drawn, until another view is set. The render target keeps its own copy of the view object, so it is not necessary to keep the original one alive after calling this function. To restore the original view of the target, you can pass the result of default_view() to this function. view - New view to use See also: view , default_view [ View source ]","title":"RenderTarget"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget","text":"Base module for all render targets (window, texture, ...) SF::RenderTarget defines the common behavior of all the 2D render targets usable in the graphics module. It makes it possible to draw 2D entities like sprites, shapes, text without using any OpenGL command directly. A SF::RenderTarget is also able to use views ( SF::View ), which are a kind of 2D cameras. With views you can globally scroll, rotate or zoom everything that is drawn, without having to transform every single entity. See the documentation of SF::View for more details and sample pieces of code about this module. On top of that, render targets are still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. When doing so, make sure that OpenGL states are not messed up by calling the push_gl_states/pop_gl_states functions. See also: SF::RenderWindow , SF::RenderTexture , SF::View","title":"RenderTarget"},{"location":"api/SF/RenderTarget.html#included-modules","text":"SF::NonCopyable","title":"Included modules"},{"location":"api/SF/RenderTarget.html#direct-including-types","text":"SF::RenderTexture SF::RenderWindow","title":"Direct including types"},{"location":"api/SF/RenderTarget.html#methods","text":"","title":"Methods"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#active=(active)","text":"Activate or deactivate the render target for rendering This function makes the render target's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff). A render target's context is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target don't forget to activate it again. Activating a render target will automatically deactivate the previously active context (if any). active - True to activate, false to deactivate Returns: True if operation was successful, false otherwise [ View source ]","title":"#active="},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#clear(color)","text":"Clear the entire target with a single color This function is usually called once every frame, to clear the previous contents of the target. color - Fill color to use to clear the render target [ View source ]","title":"#clear"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#default_view()","text":"Get the default view of the render target The default view has the initial size of the render target, and never changes after the target has been created. Returns: The default view of the render target See also: view= , view [ View source ]","title":"#default_view"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#draw(drawable,states)","text":"Draw a drawable object to the render target. Shorthand for Drawable#draw(self, states) drawable - Object to draw states - Render states to use for drawing [ View source ]","title":"#draw"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#get_viewport(view)","text":"Get the viewport of a view, applied to this render target The viewport is defined in the view as a ratio, this function simply applies this ratio to the current dimensions of the render target to calculate the pixels rectangle that the viewport actually covers in the target. view - The view for which we want to compute the viewport Returns: Viewport rectangle, expressed in pixels [ View source ]","title":"#get_viewport"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#map_coords_to_pixel(point,view)","text":"Convert a point from world coordinates to target coordinates This function finds the pixel of the render target that matches the given 2D point. In other words, it goes through the same process as the graphics card, to compute the final position of a rendered point. Initially, both coordinate systems (world units and target pixels) match perfectly. But if you define a custom view or resize your render target, this assertion is not true anymore, i.e. a point located at (150, 75) in your 2D world may map to the pixel (10, 50) of your render target -- if the view is translated by (140, 25). This version uses a custom view for calculations, see the other overload of the function if you want to use the current view of the render target. point - Point to convert view - The view to use for converting the point Returns: The converted point, in target coordinates (pixels) See also: map_pixel_to_coords [ View source ]","title":"#map_coords_to_pixel"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#map_pixel_to_coords(point)","text":"Convert a point from target coordinates to world coordinates, using the current view This function is an overload of the map_pixel_to_coords function that implicitly uses the current view. It is equivalent to: target . map_pixel_to_coords ( point , target . view ) point - Pixel to convert Returns: The converted point, in \"world\" coordinates See also: map_coords_to_pixel [ View source ]","title":"#map_pixel_to_coords"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#pop_gl_states()","text":"Restore the previously saved OpenGL render states and matrices See the description of push_gl_states to get a detailed description of these functions. See also: push_gl_states [ View source ]","title":"#pop_gl_states"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#push_gl_states()","text":"Save the current OpenGL render states and matrices This function can be used when you mix SFML drawing and direct OpenGL rendering. Combined with pop_gl_states, it ensures that: SFML's internal states are not messed up by your OpenGL code your OpenGL states are not modified by a call to a SFML function More specifically, it must be used around code that calls Draw functions. Example: # OpenGL code here... window . push_gl_states () window . draw ( ... ) window . draw ( ... ) window . pop_gl_states () # OpenGL code here... Note that this function is quite expensive: it saves all the possible OpenGL states and matrices, even the ones you don't care about. Therefore it should be used wisely. It is provided for convenience, but the best results will be achieved if you handle OpenGL states yourself (because you know which states have really changed, and need to be saved and restored). Take a look at the reset_gl_states function if you do so. See also: pop_gl_states [ View source ]","title":"#push_gl_states"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#reset_gl_states()","text":"Reset the internal OpenGL states so that the target is ready for drawing This function can be used when you mix SFML drawing and direct OpenGL rendering, if you choose not to use push_gl_states/pop_gl_states. It makes sure that all OpenGL states needed by SFML are set, so that subsequent draw() calls will work as expected. Example: # OpenGL code here... glPushAttrib ( ... ) window . reset_gl_states () window . draw ( ... ) window . draw ( ... ) glPopAttrib ( ... ) # OpenGL code here... [ View source ]","title":"#reset_gl_states"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#size()","text":"Return the size of the rendering region of the target Returns: Size in pixels [ View source ]","title":"#size"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#view()","text":"Get the view currently in use in the render target Returns: The view object that is currently used See also: view= , default_view [ View source ]","title":"#view"},{"location":"api/SF/RenderTarget.html#SF::RenderTarget#view=(view)","text":"Change the current active view The view is like a 2D camera, it controls which part of the 2D scene is visible, and how it is viewed in the render target. The new view will affect everything that is drawn, until another view is set. The render target keeps its own copy of the view object, so it is not necessary to keep the original one alive after calling this function. To restore the original view of the target, you can pass the result of default_view() to this function. view - New view to use See also: view , default_view [ View source ]","title":"#view="},{"location":"api/SF/RenderTexture.html","text":"class SF::RenderTexture inherits Reference # Target for off-screen 2D rendering into a texture SF::RenderTexture is the little brother of SF::RenderWindow . It implements the same 2D drawing and OpenGL-related functions (see their base class SF::RenderTarget for more details), the difference is that the result is stored in an off-screen texture rather than being show in a window. Rendering to a texture can be useful in a variety of situations: precomputing a complex static texture (like a level's background from multiple tiles) applying post-effects to the whole scene with shaders creating a sprite from a 3D object rendered with OpenGL etc. Usage example: # Create a new render-window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) # Create a new render-texture texture = SF :: RenderTexture . new ( 500 , 500 ) # The main loop while window . open? # Event processing # ... # Clear the whole texture with red color texture . clear ( SF :: Color :: Red ) # Draw stuff to the texture texture . draw ( sprite ) # sprite is a SF::Sprite texture . draw ( shape ) # shape is a SF::Shape texture . draw ( text ) # text is a SF::Text # We're done drawing to the texture texture . display () # Now we start rendering to the window, clear it first window . clear () # Draw the texture sprite = SF :: Sprite ( texture . texture ) window . draw ( sprite ) # End the current frame and display its contents on screen window . display () end Like SF::RenderWindow , SF::RenderTexture is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. If you need a depth buffer for 3D rendering, don't forget to request it when calling RenderTexture.create. See also: SF::RenderTarget , SF::RenderWindow , SF::View , SF::Texture Included modules # SF::RenderTarget Class methods # .maximum_antialiasing_level : Int32 # Get the maximum anti-aliasing level supported by the system Returns: The maximum anti-aliasing level supported by the system [ View source ] .new # Default constructor Constructs an empty, invalid render-texture. You must call create to have a valid render-texture. See also: create [ View source ] .new ( * args , ** kwargs ) : self # Shorthand for render_texture = RenderTexture.new; render_texture.create(...); render_texture Raises InitError on failure [ View source ] Methods # #active= ( active : Bool = true ) : Bool # Activate or deactivate the render-texture for rendering This function makes the render-texture's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff). Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target (like a RenderWindow) don't forget to activate it again. active - True to activate, false to deactivate Returns: True if operation was successful, false otherwise [ View source ] #create ( width : Int , height : Int , depth_buffer : Bool ) : Bool # Create the render-texture Before calling this function, the render-texture is in an invalid state, thus it is mandatory to call it before doing anything with the render-texture. The last parameter, depth_buffer, is useful if you want to use the render-texture for 3D OpenGL rendering that requires a depth buffer. Otherwise it is unnecessary, and you should leave this parameter to false (which is its default value). width - Width of the render-texture height - Height of the render-texture depth_buffer - Do you want this render-texture to have a depth buffer? Returns: True if creation has been successful DEPRECATED: Use create(unsigned int, unsigned int, const ContextSettings&) instead. [ View source ] #create ( width : Int , height : Int , settings : ContextSettings = ContextSettings . new ) : Bool # Create the render-texture Before calling this function, the render-texture is in an invalid state, thus it is mandatory to call it before doing anything with the render-texture. The last parameter, settings, is useful if you want to enable multi-sampling or use the render-texture for OpenGL rendering that requires a depth or stencil buffer. Otherwise it is unnecessary, and you should leave this parameter at its default value. width - Width of the render-texture height - Height of the render-texture settings - Additional settings for the underlying OpenGL texture and context Returns: True if creation has been successful [ View source ] #display # Update the contents of the target texture This function updates the target texture with what has been drawn so far. Like for windows, calling this function is mandatory at the end of rendering. Not calling it may leave the texture in an undefined state. [ View source ] #finalize # Destructor [ View source ] #generate_mipmap : Bool # Generate a mipmap using the current texture data This function is similar to Texture.generate_mipmap and operates on the texture used as the target for drawing. Be aware that any draw operation may modify the base level image data. For this reason, calling this function only makes sense after all drawing is completed and display has been called. Not calling display after subsequent drawing will lead to undefined behavior if a mipmap had been previously generated. Returns: True if mipmap generation was successful, false if unsuccessful [ View source ] #repeated= ( repeated : Bool ) # Enable or disable texture repeating This function is similar to Texture.repeated=. This parameter is disabled by default. repeated - True to enable repeating, false to disable it See also: repeated? [ View source ] #repeated? : Bool # Tell whether the texture is repeated or not Returns: True if texture is repeated See also: repeated= [ View source ] #size : Vector2u # Return the size of the rendering region of the texture The returned value is the size that you passed to the create function. Returns: Size in pixels [ View source ] #smooth= ( smooth : Bool ) # Enable or disable texture smoothing This function is similar to Texture.smooth=. This parameter is disabled by default. smooth - True to enable smoothing, false to disable it See also: smooth? [ View source ] #smooth? : Bool # Tell whether the smooth filtering is enabled or not Returns: True if texture smoothing is enabled See also: smooth= [ View source ] #texture : Texture # Get a read-only reference to the target texture After drawing to the render-texture and calling Display, you can retrieve the updated texture using this function, and draw it using a sprite (for example). The internal SF::Texture of a render-texture is always the same instance, so that it is possible to call this function once and keep a reference to the texture even after it is modified. Returns: Const reference to the texture [ View source ]","title":"RenderTexture"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture","text":"Target for off-screen 2D rendering into a texture SF::RenderTexture is the little brother of SF::RenderWindow . It implements the same 2D drawing and OpenGL-related functions (see their base class SF::RenderTarget for more details), the difference is that the result is stored in an off-screen texture rather than being show in a window. Rendering to a texture can be useful in a variety of situations: precomputing a complex static texture (like a level's background from multiple tiles) applying post-effects to the whole scene with shaders creating a sprite from a 3D object rendered with OpenGL etc. Usage example: # Create a new render-window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) # Create a new render-texture texture = SF :: RenderTexture . new ( 500 , 500 ) # The main loop while window . open? # Event processing # ... # Clear the whole texture with red color texture . clear ( SF :: Color :: Red ) # Draw stuff to the texture texture . draw ( sprite ) # sprite is a SF::Sprite texture . draw ( shape ) # shape is a SF::Shape texture . draw ( text ) # text is a SF::Text # We're done drawing to the texture texture . display () # Now we start rendering to the window, clear it first window . clear () # Draw the texture sprite = SF :: Sprite ( texture . texture ) window . draw ( sprite ) # End the current frame and display its contents on screen window . display () end Like SF::RenderWindow , SF::RenderTexture is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. If you need a depth buffer for 3D rendering, don't forget to request it when calling RenderTexture.create. See also: SF::RenderTarget , SF::RenderWindow , SF::View , SF::Texture","title":"RenderTexture"},{"location":"api/SF/RenderTexture.html#included-modules","text":"SF::RenderTarget","title":"Included modules"},{"location":"api/SF/RenderTexture.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture.maximum_antialiasing_level()","text":"Get the maximum anti-aliasing level supported by the system Returns: The maximum anti-aliasing level supported by the system [ View source ]","title":".maximum_antialiasing_level"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture.new()","text":"Default constructor Constructs an empty, invalid render-texture. You must call create to have a valid render-texture. See also: create [ View source ]","title":".new"},{"location":"api/SF/RenderTexture.html#methods","text":"","title":"Methods"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#active=(active)","text":"Activate or deactivate the render-texture for rendering This function makes the render-texture's context current for future OpenGL rendering operations (so you shouldn't care about it if you're not doing direct OpenGL stuff). Only one context can be current in a thread, so if you want to draw OpenGL geometry to another render target (like a RenderWindow) don't forget to activate it again. active - True to activate, false to deactivate Returns: True if operation was successful, false otherwise [ View source ]","title":"#active="},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#create(width,height,depth_buffer)","text":"Create the render-texture Before calling this function, the render-texture is in an invalid state, thus it is mandatory to call it before doing anything with the render-texture. The last parameter, depth_buffer, is useful if you want to use the render-texture for 3D OpenGL rendering that requires a depth buffer. Otherwise it is unnecessary, and you should leave this parameter to false (which is its default value). width - Width of the render-texture height - Height of the render-texture depth_buffer - Do you want this render-texture to have a depth buffer? Returns: True if creation has been successful DEPRECATED: Use create(unsigned int, unsigned int, const ContextSettings&) instead. [ View source ]","title":"#create"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#display()","text":"Update the contents of the target texture This function updates the target texture with what has been drawn so far. Like for windows, calling this function is mandatory at the end of rendering. Not calling it may leave the texture in an undefined state. [ View source ]","title":"#display"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#generate_mipmap()","text":"Generate a mipmap using the current texture data This function is similar to Texture.generate_mipmap and operates on the texture used as the target for drawing. Be aware that any draw operation may modify the base level image data. For this reason, calling this function only makes sense after all drawing is completed and display has been called. Not calling display after subsequent drawing will lead to undefined behavior if a mipmap had been previously generated. Returns: True if mipmap generation was successful, false if unsuccessful [ View source ]","title":"#generate_mipmap"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#repeated=(repeated)","text":"Enable or disable texture repeating This function is similar to Texture.repeated=. This parameter is disabled by default. repeated - True to enable repeating, false to disable it See also: repeated? [ View source ]","title":"#repeated="},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#repeated?()","text":"Tell whether the texture is repeated or not Returns: True if texture is repeated See also: repeated= [ View source ]","title":"#repeated?"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#size()","text":"Return the size of the rendering region of the texture The returned value is the size that you passed to the create function. Returns: Size in pixels [ View source ]","title":"#size"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#smooth=(smooth)","text":"Enable or disable texture smoothing This function is similar to Texture.smooth=. This parameter is disabled by default. smooth - True to enable smoothing, false to disable it See also: smooth? [ View source ]","title":"#smooth="},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#smooth?()","text":"Tell whether the smooth filtering is enabled or not Returns: True if texture smoothing is enabled See also: smooth= [ View source ]","title":"#smooth?"},{"location":"api/SF/RenderTexture.html#SF::RenderTexture#texture()","text":"Get a read-only reference to the target texture After drawing to the render-texture and calling Display, you can retrieve the updated texture using this function, and draw it using a sprite (for example). The internal SF::Texture of a render-texture is always the same instance, so that it is possible to call this function once and keep a reference to the texture even after it is modified. Returns: Const reference to the texture [ View source ]","title":"#texture"},{"location":"api/SF/RenderWindow.html","text":"class SF::RenderWindow inherits SF::Window # Window that can serve as a target for 2D drawing SF::RenderWindow is the main class of the Graphics module. It defines an OS window that can be painted using the other classes of the graphics module. SF::RenderWindow is derived from SF::Window , thus it inherits all its features: events, window management, OpenGL rendering, etc. See the documentation of SF::Window for a more complete description of all these features, as well as code examples. On top of that, SF::RenderWindow adds more features related to 2D drawing with the graphics module (see its base module SF::RenderTarget for more details). Here is a typical rendering and event loop with a SF::RenderWindow : # Declare and create a new render-window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) # Limit the framerate to 60 frames per second (this step is optional) window . framerate_limit = 60 # The main loop - ends as soon as the window is closed while window . open? # Event processing while ( event = window . poll_event ) # Request for closing the window if event . is_a? SF :: Event :: Closed window . close () end end # Clear the whole window before rendering a new frame window . clear () # Draw some graphical entities window . draw sprite window . draw circle window . draw text # End the current frame and display its contents on screen window . display () end Like SF::Window , SF::RenderWindow is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. # Create the render window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML OpenGL\" ) # Create a sprite and a text to display sprite = SF :: Sprite . new text = SF :: Text . new ... # Perform OpenGL initializations glMatrixMode ( GL_PROJECTION ) ... # Start the rendering loop while window . open? # Process events ... # Draw a background sprite window . push_gl_states () window . draw sprite window . pop_gl_states () # Draw a 3D object using OpenGL glBegin ( GL_QUADS ) glVertex3f ( ... ) ... glEnd () # Draw text on top of the 3D object window . push_gl_states () window . draw text window . pop_gl_states () # Finally, display the rendered frame on screen window . display () end See also: SF::Window , SF::RenderTarget , SF::RenderTexture , SF::View Included modules # SF::RenderTarget Class methods # .new ( mode : VideoMode , title : String , style : Style = Style :: Default , settings : ContextSettings = ContextSettings . new ) # Construct a new window This constructor creates the window with the size and pixel depth defined in mode. An optional style can be passed to customize the look and behavior of the window (borders, title bar, resizable, closable, ...). The fourth parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. You shouldn't care about these parameters for a regular usage of the graphics module. mode - Video mode to use (defines the width, height and depth of the rendering area of the window) title - Title of the window style - Window style, a bitwise OR combination of SF::Style enumerators settings - Additional settings for the underlying OpenGL context [ View source ] .new ( handle : WindowHandle , settings : ContextSettings = ContextSettings . new ) # Construct the window from an existing control Use this constructor if you want to create an SFML rendering area into an already existing control. The second parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. You shouldn't care about these parameters for a regular usage of the graphics module. handle - Platform-specific handle of the control ( hwnd on Windows, %window on Linux/FreeBSD, ns_window on OS X) settings - Additional settings for the underlying OpenGL context [ View source ] .new # Default constructor This constructor doesn't actually create the window, use the other constructors or call create() to do so. [ View source ] .new ( * args , ** kwargs ) : self # Shorthand for render_window = RenderWindow.new; render_window.create(...); render_window [ View source ] Methods # #active= ( active : Bool = true ) : Bool # Activate or deactivate the window as the current target for OpenGL rendering A window is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one window can be active on a thread at a time, thus the window previously active (if any) automatically gets deactivated. This is not to be confused with request_focus() . active - True to activate, false to deactivate Returns: True if operation was successful, false otherwise [ View source ] #capture : Image # Copy the current contents of the window to an image DEPRECATED: Use a SF::Texture and its SF::Texture#update(window) method and copy its contents into an SF::Image instead. texture = SF :: Texture . new ( window . size . x , window . size . y ) texture . update ( window ) screenshot = texture . copy_to_image () This is a slow operation, whose main purpose is to make screenshots of the application. If you want to update an image with the contents of the window and then use it for drawing, you should rather use a SF::Texture and its update(window) method. You can also draw things directly to a texture with the SF::RenderTexture class. Returns: Image containing the captured contents [ View source ] #finalize # Destructor Closes the window and frees all the resources attached to it. [ View source ] #size : Vector2u # Get the size of the rendering region of the window The size doesn't include the titlebar and borders of the window. Returns: Size in pixels [ View source ]","title":"RenderWindow"},{"location":"api/SF/RenderWindow.html#SF::RenderWindow","text":"Window that can serve as a target for 2D drawing SF::RenderWindow is the main class of the Graphics module. It defines an OS window that can be painted using the other classes of the graphics module. SF::RenderWindow is derived from SF::Window , thus it inherits all its features: events, window management, OpenGL rendering, etc. See the documentation of SF::Window for a more complete description of all these features, as well as code examples. On top of that, SF::RenderWindow adds more features related to 2D drawing with the graphics module (see its base module SF::RenderTarget for more details). Here is a typical rendering and event loop with a SF::RenderWindow : # Declare and create a new render-window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) # Limit the framerate to 60 frames per second (this step is optional) window . framerate_limit = 60 # The main loop - ends as soon as the window is closed while window . open? # Event processing while ( event = window . poll_event ) # Request for closing the window if event . is_a? SF :: Event :: Closed window . close () end end # Clear the whole window before rendering a new frame window . clear () # Draw some graphical entities window . draw sprite window . draw circle window . draw text # End the current frame and display its contents on screen window . display () end Like SF::Window , SF::RenderWindow is still able to render direct OpenGL stuff. It is even possible to mix together OpenGL calls and regular SFML drawing commands. # Create the render window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML OpenGL\" ) # Create a sprite and a text to display sprite = SF :: Sprite . new text = SF :: Text . new ... # Perform OpenGL initializations glMatrixMode ( GL_PROJECTION ) ... # Start the rendering loop while window . open? # Process events ... # Draw a background sprite window . push_gl_states () window . draw sprite window . pop_gl_states () # Draw a 3D object using OpenGL glBegin ( GL_QUADS ) glVertex3f ( ... ) ... glEnd () # Draw text on top of the 3D object window . push_gl_states () window . draw text window . pop_gl_states () # Finally, display the rendered frame on screen window . display () end See also: SF::Window , SF::RenderTarget , SF::RenderTexture , SF::View","title":"RenderWindow"},{"location":"api/SF/RenderWindow.html#included-modules","text":"SF::RenderTarget","title":"Included modules"},{"location":"api/SF/RenderWindow.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/RenderWindow.html#SF::RenderWindow.new(mode,title,style,settings)","text":"Construct a new window This constructor creates the window with the size and pixel depth defined in mode. An optional style can be passed to customize the look and behavior of the window (borders, title bar, resizable, closable, ...). The fourth parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. You shouldn't care about these parameters for a regular usage of the graphics module. mode - Video mode to use (defines the width, height and depth of the rendering area of the window) title - Title of the window style - Window style, a bitwise OR combination of SF::Style enumerators settings - Additional settings for the underlying OpenGL context [ View source ]","title":".new"},{"location":"api/SF/RenderWindow.html#methods","text":"","title":"Methods"},{"location":"api/SF/RenderWindow.html#SF::RenderWindow#active=(active)","text":"Activate or deactivate the window as the current target for OpenGL rendering A window is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one window can be active on a thread at a time, thus the window previously active (if any) automatically gets deactivated. This is not to be confused with request_focus() . active - True to activate, false to deactivate Returns: True if operation was successful, false otherwise [ View source ]","title":"#active="},{"location":"api/SF/RenderWindow.html#SF::RenderWindow#capture()","text":"Copy the current contents of the window to an image DEPRECATED: Use a SF::Texture and its SF::Texture#update(window) method and copy its contents into an SF::Image instead. texture = SF :: Texture . new ( window . size . x , window . size . y ) texture . update ( window ) screenshot = texture . copy_to_image () This is a slow operation, whose main purpose is to make screenshots of the application. If you want to update an image with the contents of the window and then use it for drawing, you should rather use a SF::Texture and its update(window) method. You can also draw things directly to a texture with the SF::RenderTexture class. Returns: Image containing the captured contents [ View source ]","title":"#capture"},{"location":"api/SF/RenderWindow.html#SF::RenderWindow#finalize()","text":"Destructor Closes the window and frees all the resources attached to it. [ View source ]","title":"#finalize"},{"location":"api/SF/RenderWindow.html#SF::RenderWindow#size()","text":"Get the size of the rendering region of the window The size doesn't include the titlebar and borders of the window. Returns: Size in pixels [ View source ]","title":"#size"},{"location":"api/SF/Sensor.html","text":"module SF::Sensor # Give access to the real-time state of the sensors SF::Sensor provides an interface to the state of the various sensors that a device provides. It only contains static functions, so it's not meant to be instantiated. This module allows users to query the sensors values at any time and directly, without having to deal with a window and its events. Compared to the SensorChanged event, SF::Sensor can retrieve the state of a sensor at any time (you don't need to store and update its current value on your side). Depending on the OS and hardware of the device (phone, tablet, ...), some sensor types may not be available. You should always check the availability of a sensor before trying to read it, with the SF::Sensor.available? function. You may wonder why some sensor types look so similar, for example Accelerometer and Gravity / UserAcceleration. The first one is the raw measurement of the acceleration, and takes into account both the earth gravity and the user movement. The others are more precise: they provide these components separately, which is usually more useful. In fact they are not direct sensors, they are computed internally based on the raw acceleration and other sensors. This is exactly the same for Gyroscope vs Orientation. Because sensors consume a non-negligible amount of current, they are all disabled by default. You must call SF::Sensor.enabled= for each sensor in which you are interested. Usage example: if SF :: Sensor . available? ( SF :: Sensor :: Gravity ) # gravity sensor is available end # enable the gravity sensor SF :: Sensor . set_enabled ( SF :: Sensor :: Gravity , true ) # get the current value of gravity gravity = SF :: Sensor . get_value ( SF :: Sensor :: Gravity ) Class methods # .available? ( sensor : Sensor :: Type ) : Bool # Check if a sensor is available on the underlying platform sensor - Sensor to check Returns: True if the sensor is available, false otherwise [ View source ] .get_value ( sensor : Sensor :: Type ) : Vector3f # Get the current sensor value sensor - Sensor to read Returns: The current sensor value [ View source ] .set_enabled ( sensor : Sensor :: Type , enabled : Bool ) # Enable or disable a sensor All sensors are disabled by default, to avoid consuming too much battery power. Once a sensor is enabled, it starts sending events of the corresponding type. This function does nothing if the sensor is unavailable. sensor - Sensor to enable enabled - True to enable, false to disable [ View source ]","title":"Sensor"},{"location":"api/SF/Sensor.html#SF::Sensor","text":"Give access to the real-time state of the sensors SF::Sensor provides an interface to the state of the various sensors that a device provides. It only contains static functions, so it's not meant to be instantiated. This module allows users to query the sensors values at any time and directly, without having to deal with a window and its events. Compared to the SensorChanged event, SF::Sensor can retrieve the state of a sensor at any time (you don't need to store and update its current value on your side). Depending on the OS and hardware of the device (phone, tablet, ...), some sensor types may not be available. You should always check the availability of a sensor before trying to read it, with the SF::Sensor.available? function. You may wonder why some sensor types look so similar, for example Accelerometer and Gravity / UserAcceleration. The first one is the raw measurement of the acceleration, and takes into account both the earth gravity and the user movement. The others are more precise: they provide these components separately, which is usually more useful. In fact they are not direct sensors, they are computed internally based on the raw acceleration and other sensors. This is exactly the same for Gyroscope vs Orientation. Because sensors consume a non-negligible amount of current, they are all disabled by default. You must call SF::Sensor.enabled= for each sensor in which you are interested. Usage example: if SF :: Sensor . available? ( SF :: Sensor :: Gravity ) # gravity sensor is available end # enable the gravity sensor SF :: Sensor . set_enabled ( SF :: Sensor :: Gravity , true ) # get the current value of gravity gravity = SF :: Sensor . get_value ( SF :: Sensor :: Gravity )","title":"Sensor"},{"location":"api/SF/Sensor.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Sensor.html#SF::Sensor.available?(sensor)","text":"Check if a sensor is available on the underlying platform sensor - Sensor to check Returns: True if the sensor is available, false otherwise [ View source ]","title":".available?"},{"location":"api/SF/Sensor.html#SF::Sensor.get_value(sensor)","text":"Get the current sensor value sensor - Sensor to read Returns: The current sensor value [ View source ]","title":".get_value"},{"location":"api/SF/Sensor.html#SF::Sensor.set_enabled(sensor,enabled)","text":"Enable or disable a sensor All sensors are disabled by default, to avoid consuming too much battery power. Once a sensor is enabled, it starts sending events of the corresponding type. This function does nothing if the sensor is unavailable. sensor - Sensor to enable enabled - True to enable, false to disable [ View source ]","title":".set_enabled"},{"location":"api/SF/Shader.html","text":"class SF::Shader inherits Reference # Shader class (vertex, geometry and fragment) Shaders are programs written using a specific language, executed directly by the graphics card and allowing to apply real-time operations to the rendered entities. There are three kinds of shaders: Vertex shaders, that process vertices Geometry shaders, that process primitives Fragment (pixel) shaders, that process pixels A SF::Shader can be composed of either a vertex shader alone, a geometry shader alone, a fragment shader alone, or any combination of them. (see the variants of the load functions). Shaders are written in GLSL, which is a C-like language dedicated to OpenGL shaders. You'll probably need to learn its basics before writing your own shaders for SFML. Like any C/C++ program, a GLSL shader has its own variables called uniforms that you can set from your C++ application. SF::Shader handles different types of uniforms: scalars: float , int , bool vectors (2, 3 or 4 components) matrices (3x3 or 4x4) samplers (textures) Some SFML-specific types can be converted: SF::Color as a 4D vector ( vec4 ) SF::Transform as matrices ( mat3 or mat4 ) Every uniform variable in a shader can be set through one of the set_parameter overloads, or through a shorthand. For example, if you have a shader with the following uniforms: uniform float offset ; uniform vec3 point ; uniform vec4 color ; uniform mat4 matrix ; uniform sampler2D overlay ; uniform sampler2D current ; You can set their values from Crystal code as follows: shader . offset 2.0 shader . point 0.5 , 0.8 , 0.3 shader . color color # color is a SF::Color shader . matrix transform # transform is a SF::Transform shader . overlay texture # texture is a SF::Texture shader . current SF :: Shader :: CurrentTexture The special Shader::CurrentTexture argument maps the given sampler2d uniform to the current texture of the object being drawn (which cannot be known in advance). To apply a shader to a drawable, you must pass it as an additional parameter to the Window.draw function: states = SF :: RenderStates . new ( shader ) window . draw ( sprite , states ) In the code above we pass a pointer to the shader, because it may be null (which means \"no shader\"). Shaders can be used on any drawable, but some combinations are not interesting. For example, using a vertex shader on a SF::Sprite is limited because there are only 4 vertices, the sprite would have to be subdivided in order to apply wave effects. Another bad example is a fragment shader with SF::Text : the texture of the text is not the actual text that you see on screen, it is a big texture containing all the characters of the font in an arbitrary order; thus, texture lookups on pixels other than the current one may not give you the expected result. Shaders can also be used to apply global post-effects to the current contents of the target. This can be done in two different ways: draw everything to a SF::RenderTexture , then draw it to the main target using the shader draw everything directly to the main target, then use SF::Texture.update(window) to copy its contents to a texture and draw it to the main target using the shader The first technique is more optimized because it doesn't involve retrieving the target's pixels to system memory, but the second one doesn't impact the rendering process and can be easily inserted anywhere without impacting all the code. Like SF::Texture that can be used as a raw OpenGL texture, SF::Shader can also be used directly as a raw shader for custom OpenGL geometry. SF :: Shader . bind shader ... render OpenGL geometry ... SF :: Shader . bind nil Included modules # SF::GlResource SF::NonCopyable Constants # CurrentTexture # Represents the texture of the object being drawn Class methods # .available? : Bool # Tell whether or not the system supports shaders This function should always be called before using the shader features. If it returns false, then any attempt to use SF::Shader will fail. Returns: True if shaders are supported, false otherwise [ View source ] .bind ( shader : Shader? ) # Bind a shader for rendering This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix SF::Shader with OpenGL code. s1 = SF :: Shader . new s2 = SF :: Shader . new ... SF :: Shader . bind s1 # draw OpenGL stuff that use s1... SF :: Shader . bind s2 # draw OpenGL stuff that use s2... SF :: Shader . bind nil # draw OpenGL stuff that use no shader... shader - Shader to bind, can be null to use no shader [ View source ] .geometry_available? : Bool # Tell whether or not the system supports geometry shaders This function should always be called before using the geometry shader features. If it returns false, then any attempt to use SF::Shader geometry shader features will fail. This function can only return true if available?() would also return true, since shaders in general have to be supported in order for geometry shaders to be supported as well. Note: The first call to this function, whether by your code or SFML will result in a context switch. Returns: True if geometry shaders are supported, false otherwise [ View source ] .from_file ( * args , ** kwargs ) : self # Shorthand for shader = Shader.new; shader.load_from_file(...); shader Raises InitError on failure [ View source ] .from_memory ( * args , ** kwargs ) : self # Shorthand for shader = Shader.new; shader.load_from_memory(...); shader Raises InitError on failure [ View source ] .from_stream ( * args , ** kwargs ) : self # Shorthand for shader = Shader.new; shader.load_from_stream(...); shader Raises InitError on failure [ View source ] .new # Default constructor This constructor creates an invalid shader. [ View source ] Methods # #finalize # Destructor [ View source ] #load_from_file ( vertex_shader_filename : String , geometry_shader_filename : String , fragment_shader_filename : String ) : Bool # Load the vertex, geometry and fragment shaders from files This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be text files containing valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader_filename - Path of the vertex shader file to load geometry_shader_filename - Path of the geometry shader file to load fragment_shader_filename - Path of the fragment shader file to load Returns: True if loading succeeded, false if it failed See also: load_from_memory , load_from_stream [ View source ] #load_from_file ( filename : String , type : Shader :: Type ) : Bool # Load the vertex, geometry or fragment shader from a file This function loads a single shader, vertex, geometry or fragment, identified by the second argument. The source must be a text file containing a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders. filename - Path of the vertex, geometry or fragment shader file to load type - Type of shader (vertex, geometry or fragment) Returns: True if loading succeeded, false if it failed See also: load_from_memory , load_from_stream [ View source ] #load_from_file ( vertex_shader_filename : String , fragment_shader_filename : String ) : Bool # Load both the vertex and fragment shaders from files This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be text files containing valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader_filename - Path of the vertex shader file to load fragment_shader_filename - Path of the fragment shader file to load Returns: True if loading succeeded, false if it failed See also: load_from_memory , load_from_stream [ View source ] #load_from_memory ( vertex_shader : String , geometry_shader : String , fragment_shader : String ) : Bool # Load the vertex, geometry and fragment shaders from source codes in memory This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader - String containing the source code of the vertex shader geometry_shader - String containing the source code of the geometry shader fragment_shader - String containing the source code of the fragment shader Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_stream [ View source ] #load_from_memory ( shader : String , type : Shader :: Type ) : Bool # Load the vertex, geometry or fragment shader from a source code in memory This function loads a single shader, vertex, geometry or fragment, identified by the second argument. The source code must be a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders you'll probably need to read a good documentation for it before writing your own shaders. shader - String containing the source code of the shader type - Type of shader (vertex, geometry or fragment) Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_stream [ View source ] #load_from_memory ( vertex_shader : String , fragment_shader : String ) : Bool # Load both the vertex and fragment shaders from source codes in memory This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader - String containing the source code of the vertex shader fragment_shader - String containing the source code of the fragment shader Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_stream [ View source ] #load_from_stream ( vertex_shader_stream : InputStream , geometry_shader_stream : InputStream , fragment_shader_stream : InputStream ) : Bool # Load the vertex, geometry and fragment shaders from custom streams This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The source codes must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader_stream - Source stream to read the vertex shader from geometry_shader_stream - Source stream to read the geometry shader from fragment_shader_stream - Source stream to read the fragment shader from Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory [ View source ] #load_from_stream ( stream : InputStream , type : Shader :: Type ) : Bool # Load the vertex, geometry or fragment shader from a custom stream This function loads a single shader, vertex, geometry or fragment, identified by the second argument. The source code must be a valid shader in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders you'll probably need to read a good documentation for it before writing your own shaders. stream - Source stream to read from type - Type of shader (vertex, geometry or fragment) Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory [ View source ] #load_from_stream ( vertex_shader_stream : InputStream , fragment_shader_stream : InputStream ) : Bool # Load both the vertex and fragment shaders from custom streams This function loads both the vertex and the fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The source codes must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader_stream - Source stream to read the vertex shader from fragment_shader_stream - Source stream to read the fragment shader from Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory [ View source ] #native_handle : Int32 # Get the underlying OpenGL handle of the shader. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed. Returns: OpenGL handle of the shader or 0 if not yet loaded [ View source ] #set_parameter ( name : String , x : Number , y : Number , z : Number ) # Change a 3-components vector parameter of the shader [ View source ] #set_parameter ( name : String , x : Number , y : Number ) # Change a 2-components vector parameter of the shader [ View source ] #set_parameter ( name : String , x : Number ) # Change a float parameter of the shader [ View source ] #set_parameter ( name : String , vector : Vector2 | Tuple ) # Change a 2-components vector parameter of the shader DEPRECATED: Use uniform=(const std::string&, const Glsl::Vec2&) instead. [ View source ] #set_parameter ( name : String , vector : Vector3f ) # Change a 3-components vector parameter of the shader [ View source ] #set_parameter ( name : String , color : Color ) # Change a color parameter of the shader [ View source ] #set_parameter ( name : String , transform : Transform ) # Change a matrix parameter of the shader [ View source ] #set_parameter ( name : String , texture : Texture ) # Change a texture parameter of the shader [ View source ] #set_parameter ( name : String , p1 : CurrentTextureType ) # Change a texture parameter of the shader [ View source ] #set_parameter ( name : String , x : Number , y : Number , z : Number , w : Number ) # Change a 4-components vector parameter of the shader [ View source ] Macros # method_missing ( call ) # Forwards calls like shader.param(arg1, arg2) to shader.set_parameter(\"param\", arg1, arg2) [ View source ]","title":"Shader"},{"location":"api/SF/Shader.html#SF::Shader","text":"Shader class (vertex, geometry and fragment) Shaders are programs written using a specific language, executed directly by the graphics card and allowing to apply real-time operations to the rendered entities. There are three kinds of shaders: Vertex shaders, that process vertices Geometry shaders, that process primitives Fragment (pixel) shaders, that process pixels A SF::Shader can be composed of either a vertex shader alone, a geometry shader alone, a fragment shader alone, or any combination of them. (see the variants of the load functions). Shaders are written in GLSL, which is a C-like language dedicated to OpenGL shaders. You'll probably need to learn its basics before writing your own shaders for SFML. Like any C/C++ program, a GLSL shader has its own variables called uniforms that you can set from your C++ application. SF::Shader handles different types of uniforms: scalars: float , int , bool vectors (2, 3 or 4 components) matrices (3x3 or 4x4) samplers (textures) Some SFML-specific types can be converted: SF::Color as a 4D vector ( vec4 ) SF::Transform as matrices ( mat3 or mat4 ) Every uniform variable in a shader can be set through one of the set_parameter overloads, or through a shorthand. For example, if you have a shader with the following uniforms: uniform float offset ; uniform vec3 point ; uniform vec4 color ; uniform mat4 matrix ; uniform sampler2D overlay ; uniform sampler2D current ; You can set their values from Crystal code as follows: shader . offset 2.0 shader . point 0.5 , 0.8 , 0.3 shader . color color # color is a SF::Color shader . matrix transform # transform is a SF::Transform shader . overlay texture # texture is a SF::Texture shader . current SF :: Shader :: CurrentTexture The special Shader::CurrentTexture argument maps the given sampler2d uniform to the current texture of the object being drawn (which cannot be known in advance). To apply a shader to a drawable, you must pass it as an additional parameter to the Window.draw function: states = SF :: RenderStates . new ( shader ) window . draw ( sprite , states ) In the code above we pass a pointer to the shader, because it may be null (which means \"no shader\"). Shaders can be used on any drawable, but some combinations are not interesting. For example, using a vertex shader on a SF::Sprite is limited because there are only 4 vertices, the sprite would have to be subdivided in order to apply wave effects. Another bad example is a fragment shader with SF::Text : the texture of the text is not the actual text that you see on screen, it is a big texture containing all the characters of the font in an arbitrary order; thus, texture lookups on pixels other than the current one may not give you the expected result. Shaders can also be used to apply global post-effects to the current contents of the target. This can be done in two different ways: draw everything to a SF::RenderTexture , then draw it to the main target using the shader draw everything directly to the main target, then use SF::Texture.update(window) to copy its contents to a texture and draw it to the main target using the shader The first technique is more optimized because it doesn't involve retrieving the target's pixels to system memory, but the second one doesn't impact the rendering process and can be easily inserted anywhere without impacting all the code. Like SF::Texture that can be used as a raw OpenGL texture, SF::Shader can also be used directly as a raw shader for custom OpenGL geometry. SF :: Shader . bind shader ... render OpenGL geometry ... SF :: Shader . bind nil","title":"Shader"},{"location":"api/SF/Shader.html#included-modules","text":"SF::GlResource SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Shader.html#constants","text":"","title":"Constants"},{"location":"api/SF/Shader.html#SF::Shader::CurrentTexture","text":"Represents the texture of the object being drawn","title":"CurrentTexture"},{"location":"api/SF/Shader.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Shader.html#SF::Shader.available?()","text":"Tell whether or not the system supports shaders This function should always be called before using the shader features. If it returns false, then any attempt to use SF::Shader will fail. Returns: True if shaders are supported, false otherwise [ View source ]","title":".available?"},{"location":"api/SF/Shader.html#SF::Shader.bind(shader)","text":"Bind a shader for rendering This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix SF::Shader with OpenGL code. s1 = SF :: Shader . new s2 = SF :: Shader . new ... SF :: Shader . bind s1 # draw OpenGL stuff that use s1... SF :: Shader . bind s2 # draw OpenGL stuff that use s2... SF :: Shader . bind nil # draw OpenGL stuff that use no shader... shader - Shader to bind, can be null to use no shader [ View source ]","title":".bind"},{"location":"api/SF/Shader.html#SF::Shader.geometry_available?()","text":"Tell whether or not the system supports geometry shaders This function should always be called before using the geometry shader features. If it returns false, then any attempt to use SF::Shader geometry shader features will fail. This function can only return true if available?() would also return true, since shaders in general have to be supported in order for geometry shaders to be supported as well. Note: The first call to this function, whether by your code or SFML will result in a context switch. Returns: True if geometry shaders are supported, false otherwise [ View source ]","title":".geometry_available?"},{"location":"api/SF/Shader.html#SF::Shader.from_file(*args,**kwargs)","text":"Shorthand for shader = Shader.new; shader.load_from_file(...); shader Raises InitError on failure [ View source ]","title":".from_file"},{"location":"api/SF/Shader.html#SF::Shader.from_memory(*args,**kwargs)","text":"Shorthand for shader = Shader.new; shader.load_from_memory(...); shader Raises InitError on failure [ View source ]","title":".from_memory"},{"location":"api/SF/Shader.html#SF::Shader.from_stream(*args,**kwargs)","text":"Shorthand for shader = Shader.new; shader.load_from_stream(...); shader Raises InitError on failure [ View source ]","title":".from_stream"},{"location":"api/SF/Shader.html#SF::Shader.new()","text":"Default constructor This constructor creates an invalid shader. [ View source ]","title":".new"},{"location":"api/SF/Shader.html#methods","text":"","title":"Methods"},{"location":"api/SF/Shader.html#SF::Shader#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Shader.html#SF::Shader#load_from_file(vertex_shader_filename,geometry_shader_filename,fragment_shader_filename)","text":"Load the vertex, geometry and fragment shaders from files This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be text files containing valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader_filename - Path of the vertex shader file to load geometry_shader_filename - Path of the geometry shader file to load fragment_shader_filename - Path of the fragment shader file to load Returns: True if loading succeeded, false if it failed See also: load_from_memory , load_from_stream [ View source ]","title":"#load_from_file"},{"location":"api/SF/Shader.html#SF::Shader#load_from_memory(vertex_shader,geometry_shader,fragment_shader)","text":"Load the vertex, geometry and fragment shaders from source codes in memory This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The sources must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders; you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader - String containing the source code of the vertex shader geometry_shader - String containing the source code of the geometry shader fragment_shader - String containing the source code of the fragment shader Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_stream [ View source ]","title":"#load_from_memory"},{"location":"api/SF/Shader.html#SF::Shader#load_from_stream(vertex_shader_stream,geometry_shader_stream,fragment_shader_stream)","text":"Load the vertex, geometry and fragment shaders from custom streams This function loads the vertex, geometry and fragment shaders. If one of them fails to load, the shader is left empty (the valid shader is unloaded). The source codes must be valid shaders in GLSL language. GLSL is a C-like language dedicated to OpenGL shaders you'll probably need to read a good documentation for it before writing your own shaders. vertex_shader_stream - Source stream to read the vertex shader from geometry_shader_stream - Source stream to read the geometry shader from fragment_shader_stream - Source stream to read the fragment shader from Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory [ View source ]","title":"#load_from_stream"},{"location":"api/SF/Shader.html#SF::Shader#native_handle()","text":"Get the underlying OpenGL handle of the shader. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed. Returns: OpenGL handle of the shader or 0 if not yet loaded [ View source ]","title":"#native_handle"},{"location":"api/SF/Shader.html#SF::Shader#set_parameter(name,x,y,z)","text":"Change a 3-components vector parameter of the shader [ View source ]","title":"#set_parameter"},{"location":"api/SF/Shader.html#macros","text":"","title":"Macros"},{"location":"api/SF/Shader.html#SF::Shader:method_missing(call)","text":"Forwards calls like shader.param(arg1, arg2) to shader.set_parameter(\"param\", arg1, arg2) [ View source ]","title":"method_missing"},{"location":"api/SF/Shape.html","text":"abstract class SF::Shape inherits SF::Transformable # Base class for textured shapes with outline SF::Shape is a drawable class that allows to define and display a custom convex shape on a render target. It's only an abstract base, it needs to be specialized for concrete types of shapes (circle, rectangle, convex polygon, star, ...). In addition to the attributes provided by the specialized shape classes, a shape always has the following attributes: a texture a texture rectangle a fill color an outline color an outline thickness Each feature is optional, and can be disabled easily: the texture can be null the fill/outline colors can be SF::Color::Transparent the outline thickness can be zero You can write your own derived shape class, there are only two virtual functions to override: point_count must return the number of points of the shape get_point must return the points of the shape See also: SF::RectangleShape , SF::CircleShape , SF::ConvexShape , SF::Transformable Included modules # SF::Drawable Direct known subclasses # SF::CircleShape SF::ConvexShape SF::RectangleShape Methods # #fill_color : Color # Get the fill color of the shape Returns: Fill color of the shape See also: fill_color= [ View source ] #fill_color= ( color : Color ) # Set the fill color of the shape This color is modulated (multiplied) with the shape's texture if any. It can be used to colorize the shape, or change its global opacity. You can use SF::Color::Transparent to make the inside of the shape transparent, and have the outline alone. By default, the shape's fill color is opaque white. color - New color of the shape See also: fill_color , outline_color= [ View source ] #finalize # Virtual destructor [ View source ] abstract #get_point ( index : Int ) : Vector2f # Get a point of the shape The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0 ... point_count Returns: index-th point of the shape See also: point_count [ View source ] #global_bounds : FloatRect # Get the global (non-minimal) bounding rectangle of the entity The returned rectangle is in global coordinates, which means that it takes into account the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the shape in the global 2D world's coordinate system. This function does not necessarily return the minimal bounding rectangle. It merely ensures that the returned rectangle covers all the vertices (but possibly more). This allows for a fast approximation of the bounds as a first check; you may want to use more precise checks on top of that. Returns: Global bounding rectangle of the entity [ View source ] #local_bounds : FloatRect # Get the local bounding rectangle of the entity The returned rectangle is in local coordinates, which means that it ignores the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the entity in the entity's coordinate system. Returns: Local bounding rectangle of the entity [ View source ] #outline_color : Color # Get the outline color of the shape Returns: Outline color of the shape See also: outline_color= [ View source ] #outline_color= ( color : Color ) # Set the outline color of the shape By default, the shape's outline color is opaque white. color - New outline color of the shape See also: outline_color , fill_color= [ View source ] #outline_thickness : Float32 # Get the outline thickness of the shape Returns: Outline thickness of the shape See also: outline_thickness= [ View source ] #outline_thickness= ( thickness : Number ) # Set the thickness of the shape's outline Note that negative values are allowed (so that the outline expands towards the center of the shape), and using zero disables the outline. By default, the outline thickness is 0. thickness - New outline thickness See also: outline_thickness [ View source ] abstract #point_count : Int32 # Get the total number of points of the shape Returns: Number of points of the shape See also: point [ View source ] #set_texture ( texture : Texture? , reset_rect : Bool = false ) # Change the source texture of the shape The texture argument refers to a texture that must exist as long as the shape uses it. Indeed, the shape doesn't store its own copy of the texture, but rather keeps a pointer to the one that you passed to this function. If the source texture is destroyed and the shape tries to use it, the behavior is undefined. texture can be NULL to disable texturing. If reset_rect is true, the TextureRect property of the shape is automatically adjusted to the size of the new texture. If it is false, the texture rect is left unchanged. texture - New texture reset_rect - Should the texture rect be reset to the size of the new texture? See also: texture , texture_rect= [ View source ] #texture= ( texture : Texture ) # Shorthand for set_texture [ View source ] #texture_rect : IntRect # Get the sub-rectangle of the texture displayed by the shape Returns: Texture rectangle of the shape See also: texture_rect= [ View source ] #texture_rect= ( rect : IntRect ) # Set the sub-rectangle of the texture that the shape will display The texture rect is useful when you don't want to display the whole texture, but rather a part of it. By default, the texture rect covers the entire texture. rect - Rectangle defining the region of the texture to display See also: texture_rect , texture= [ View source ] #update # Recompute the internal geometry of the shape This function must be called by the derived class everytime the shape's points change (i.e. the result of either point_count or get_point is different). [ View source ]","title":"Shape"},{"location":"api/SF/Shape.html#SF::Shape","text":"Base class for textured shapes with outline SF::Shape is a drawable class that allows to define and display a custom convex shape on a render target. It's only an abstract base, it needs to be specialized for concrete types of shapes (circle, rectangle, convex polygon, star, ...). In addition to the attributes provided by the specialized shape classes, a shape always has the following attributes: a texture a texture rectangle a fill color an outline color an outline thickness Each feature is optional, and can be disabled easily: the texture can be null the fill/outline colors can be SF::Color::Transparent the outline thickness can be zero You can write your own derived shape class, there are only two virtual functions to override: point_count must return the number of points of the shape get_point must return the points of the shape See also: SF::RectangleShape , SF::CircleShape , SF::ConvexShape , SF::Transformable","title":"Shape"},{"location":"api/SF/Shape.html#included-modules","text":"SF::Drawable","title":"Included modules"},{"location":"api/SF/Shape.html#direct-known-subclasses","text":"SF::CircleShape SF::ConvexShape SF::RectangleShape","title":"Direct known subclasses"},{"location":"api/SF/Shape.html#methods","text":"","title":"Methods"},{"location":"api/SF/Shape.html#SF::Shape#fill_color()","text":"Get the fill color of the shape Returns: Fill color of the shape See also: fill_color= [ View source ]","title":"#fill_color"},{"location":"api/SF/Shape.html#SF::Shape#fill_color=(color)","text":"Set the fill color of the shape This color is modulated (multiplied) with the shape's texture if any. It can be used to colorize the shape, or change its global opacity. You can use SF::Color::Transparent to make the inside of the shape transparent, and have the outline alone. By default, the shape's fill color is opaque white. color - New color of the shape See also: fill_color , outline_color= [ View source ]","title":"#fill_color="},{"location":"api/SF/Shape.html#SF::Shape#finalize()","text":"Virtual destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Shape.html#SF::Shape#get_point(index)","text":"Get a point of the shape The returned point is in local coordinates, that is, the shape's transforms (position, rotation, scale) are not taken into account. The result is undefined if index is out of the valid range. index - Index of the point to get, in range 0 ... point_count Returns: index-th point of the shape See also: point_count [ View source ]","title":"#get_point"},{"location":"api/SF/Shape.html#SF::Shape#global_bounds()","text":"Get the global (non-minimal) bounding rectangle of the entity The returned rectangle is in global coordinates, which means that it takes into account the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the shape in the global 2D world's coordinate system. This function does not necessarily return the minimal bounding rectangle. It merely ensures that the returned rectangle covers all the vertices (but possibly more). This allows for a fast approximation of the bounds as a first check; you may want to use more precise checks on top of that. Returns: Global bounding rectangle of the entity [ View source ]","title":"#global_bounds"},{"location":"api/SF/Shape.html#SF::Shape#local_bounds()","text":"Get the local bounding rectangle of the entity The returned rectangle is in local coordinates, which means that it ignores the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the entity in the entity's coordinate system. Returns: Local bounding rectangle of the entity [ View source ]","title":"#local_bounds"},{"location":"api/SF/Shape.html#SF::Shape#outline_color()","text":"Get the outline color of the shape Returns: Outline color of the shape See also: outline_color= [ View source ]","title":"#outline_color"},{"location":"api/SF/Shape.html#SF::Shape#outline_color=(color)","text":"Set the outline color of the shape By default, the shape's outline color is opaque white. color - New outline color of the shape See also: outline_color , fill_color= [ View source ]","title":"#outline_color="},{"location":"api/SF/Shape.html#SF::Shape#outline_thickness()","text":"Get the outline thickness of the shape Returns: Outline thickness of the shape See also: outline_thickness= [ View source ]","title":"#outline_thickness"},{"location":"api/SF/Shape.html#SF::Shape#outline_thickness=(thickness)","text":"Set the thickness of the shape's outline Note that negative values are allowed (so that the outline expands towards the center of the shape), and using zero disables the outline. By default, the outline thickness is 0. thickness - New outline thickness See also: outline_thickness [ View source ]","title":"#outline_thickness="},{"location":"api/SF/Shape.html#SF::Shape#point_count()","text":"Get the total number of points of the shape Returns: Number of points of the shape See also: point [ View source ]","title":"#point_count"},{"location":"api/SF/Shape.html#SF::Shape#set_texture(texture,reset_rect)","text":"Change the source texture of the shape The texture argument refers to a texture that must exist as long as the shape uses it. Indeed, the shape doesn't store its own copy of the texture, but rather keeps a pointer to the one that you passed to this function. If the source texture is destroyed and the shape tries to use it, the behavior is undefined. texture can be NULL to disable texturing. If reset_rect is true, the TextureRect property of the shape is automatically adjusted to the size of the new texture. If it is false, the texture rect is left unchanged. texture - New texture reset_rect - Should the texture rect be reset to the size of the new texture? See also: texture , texture_rect= [ View source ]","title":"#set_texture"},{"location":"api/SF/Shape.html#SF::Shape#texture=(texture)","text":"Shorthand for set_texture [ View source ]","title":"#texture="},{"location":"api/SF/Shape.html#SF::Shape#texture_rect()","text":"Get the sub-rectangle of the texture displayed by the shape Returns: Texture rectangle of the shape See also: texture_rect= [ View source ]","title":"#texture_rect"},{"location":"api/SF/Shape.html#SF::Shape#texture_rect=(rect)","text":"Set the sub-rectangle of the texture that the shape will display The texture rect is useful when you don't want to display the whole texture, but rather a part of it. By default, the texture rect covers the entire texture. rect - Rectangle defining the region of the texture to display See also: texture_rect , texture= [ View source ]","title":"#texture_rect="},{"location":"api/SF/Shape.html#SF::Shape#update()","text":"Recompute the internal geometry of the shape This function must be called by the derived class everytime the shape's points change (i.e. the result of either point_count or get_point is different). [ View source ]","title":"#update"},{"location":"api/SF/Socket.html","text":"class SF::Socket inherits Reference # Base class for all the socket types This class mainly defines internal stuff to be used by derived classes. The only public features that it defines, and which is therefore common to all the socket classes, is the blocking state. All sockets can be set as blocking or non-blocking. In blocking mode, socket functions will hang until the operation completes, which means that the entire program (well, in fact the current thread if you use multiple ones) will be stuck waiting for your socket operation to complete. In non-blocking mode, all the socket functions will return immediately. If the socket is not ready to complete the requested operation, the function simply returns the proper status code (Socket::NotReady). The default mode, which is blocking, is the one that is generally used, in combination with threads or selectors. The non-blocking mode is rather used in real-time applications that run an endless loop that can poll the socket often enough, and cannot afford blocking this loop. See also: SF::TcpListener , SF::TcpSocket , SF::UdpSocket Included modules # SF::NonCopyable Direct known subclasses # SF::TcpListener SF::TcpSocket SF::UdpSocket Constants # AnyPort # Special value that tells the system to pick any available port Methods # #blocking= ( blocking : Bool ) # Set the blocking state of the socket In blocking mode, calls will not return until they have completed their task. For example, a call to Receive in blocking mode won't return until some data was actually received. In non-blocking mode, calls will always return immediately, using the return code to signal whether there was data available or not. By default, all sockets are blocking. blocking - True to set the socket as blocking, false for non-blocking See also: blocking? [ View source ] #blocking? : Bool # Tell whether the socket is in blocking or non-blocking mode Returns: True if the socket is blocking, false otherwise See also: blocking= [ View source ] #finalize # Destructor [ View source ]","title":"Socket"},{"location":"api/SF/Socket.html#SF::Socket","text":"Base class for all the socket types This class mainly defines internal stuff to be used by derived classes. The only public features that it defines, and which is therefore common to all the socket classes, is the blocking state. All sockets can be set as blocking or non-blocking. In blocking mode, socket functions will hang until the operation completes, which means that the entire program (well, in fact the current thread if you use multiple ones) will be stuck waiting for your socket operation to complete. In non-blocking mode, all the socket functions will return immediately. If the socket is not ready to complete the requested operation, the function simply returns the proper status code (Socket::NotReady). The default mode, which is blocking, is the one that is generally used, in combination with threads or selectors. The non-blocking mode is rather used in real-time applications that run an endless loop that can poll the socket often enough, and cannot afford blocking this loop. See also: SF::TcpListener , SF::TcpSocket , SF::UdpSocket","title":"Socket"},{"location":"api/SF/Socket.html#included-modules","text":"SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Socket.html#direct-known-subclasses","text":"SF::TcpListener SF::TcpSocket SF::UdpSocket","title":"Direct known subclasses"},{"location":"api/SF/Socket.html#constants","text":"","title":"Constants"},{"location":"api/SF/Socket.html#SF::Socket::AnyPort","text":"Special value that tells the system to pick any available port","title":"AnyPort"},{"location":"api/SF/Socket.html#methods","text":"","title":"Methods"},{"location":"api/SF/Socket.html#SF::Socket#blocking=(blocking)","text":"Set the blocking state of the socket In blocking mode, calls will not return until they have completed their task. For example, a call to Receive in blocking mode won't return until some data was actually received. In non-blocking mode, calls will always return immediately, using the return code to signal whether there was data available or not. By default, all sockets are blocking. blocking - True to set the socket as blocking, false for non-blocking See also: blocking? [ View source ]","title":"#blocking="},{"location":"api/SF/Socket.html#SF::Socket#blocking?()","text":"Tell whether the socket is in blocking or non-blocking mode Returns: True if the socket is blocking, false otherwise See also: blocking= [ View source ]","title":"#blocking?"},{"location":"api/SF/Socket.html#SF::Socket#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/SocketSelector.html","text":"class SF::SocketSelector inherits Reference # Multiplexer that allows to read from multiple sockets Socket selectors provide a way to wait until some data is available on a set of sockets, instead of just one. This is convenient when you have multiple sockets that may possibly receive data, but you don't know which one will be ready first. In particular, it avoids to use a thread for each socket; with selectors, a single thread can handle all the sockets. All types of sockets can be used in a selector: SF::TcpListener SF::TcpSocket SF::UdpSocket A selector doesn't store its own copies of the sockets (socket classes are not copyable anyway), it simply keeps a reference to the original sockets that you pass to the \"add\" function. Therefore, you can't use the selector as a socket container, you must store them outside and make sure that they are alive as long as they are used in the selector. Using a selector is simple: populate the selector with all the sockets that you want to observe make it wait until there is data available on any of the sockets test each socket to find out which ones are ready Usage example: # Create a socket to listen to new connections listener = SF :: TcpListener . new listener . listen ( 55001 ) # Create an array to store the future clients clients = [] of SF :: TcpSocket # Create a selector selector = SF :: SocketSelector . new # Add the listener to the selector selector . add listener # Endless loop that waits for new connections while running # Make the selector wait for data on any socket if selector . wait () # Test the listener if selector . ready? ( listener ) # The listener is ready: there is a pending connection client = SF :: TcpSocket . new if listener . accept ( client ) == SF :: Socket :: Done # Add the new client to the clients list clients << client # Add the new client to the selector so that we will # be notified when he sends something selector . add client end else # The listener socket is not ready, test all other sockets (the clients) clients . each do | client | if selector . ready? ( client ) # The client has sent some data, we can receive it packet = SF :: Packet . new if client . receive ( packet ) == SF :: Socket :: Done ... end end end end end end See also: SF::Socket Class methods # .new # Default constructor [ View source ] Methods # #add ( socket : Socket ) # Add a new socket to the selector This function keeps a weak reference to the socket, so you have to make sure that the socket is not destroyed while it is stored in the selector. This function does nothing if the socket is not valid. socket - Reference to the socket to add See also: remove , clear [ View source ] #clear # Remove all the sockets stored in the selector This function doesn't destroy any instance, it simply removes all the references that the selector has to external sockets. See also: add , remove [ View source ] #dup : SocketSelector # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Destructor [ View source ] #ready? ( socket : Socket ) : Bool # Test a socket to know if it is ready to receive data This function must be used after a call to Wait, to know which sockets are ready to receive data. If a socket is ready, a call to receive will never block because we know that there is data available to read. Note that if this function returns true for a TcpListener, this means that it is ready to accept a new connection. socket - Socket to test Returns: True if the socket is ready to read, false otherwise See also: ready? [ View source ] #remove ( socket : Socket ) # Remove a socket from the selector This function doesn't destroy the socket, it simply removes the reference that the selector has to it. socket - Reference to the socket to remove See also: add , clear [ View source ] #wait ( timeout : Time = Time :: Zero ) : Bool # Wait until one or more sockets are ready to receive This function returns as soon as at least one socket has some data available to be received. To know which sockets are ready, use the ready? function. If you use a timeout and no socket is ready before the timeout is over, the function returns false. timeout - Maximum time to wait, (use Time::Zero for infinity) Returns: True if there are sockets ready, false otherwise See also: ready? [ View source ]","title":"SocketSelector"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector","text":"Multiplexer that allows to read from multiple sockets Socket selectors provide a way to wait until some data is available on a set of sockets, instead of just one. This is convenient when you have multiple sockets that may possibly receive data, but you don't know which one will be ready first. In particular, it avoids to use a thread for each socket; with selectors, a single thread can handle all the sockets. All types of sockets can be used in a selector: SF::TcpListener SF::TcpSocket SF::UdpSocket A selector doesn't store its own copies of the sockets (socket classes are not copyable anyway), it simply keeps a reference to the original sockets that you pass to the \"add\" function. Therefore, you can't use the selector as a socket container, you must store them outside and make sure that they are alive as long as they are used in the selector. Using a selector is simple: populate the selector with all the sockets that you want to observe make it wait until there is data available on any of the sockets test each socket to find out which ones are ready Usage example: # Create a socket to listen to new connections listener = SF :: TcpListener . new listener . listen ( 55001 ) # Create an array to store the future clients clients = [] of SF :: TcpSocket # Create a selector selector = SF :: SocketSelector . new # Add the listener to the selector selector . add listener # Endless loop that waits for new connections while running # Make the selector wait for data on any socket if selector . wait () # Test the listener if selector . ready? ( listener ) # The listener is ready: there is a pending connection client = SF :: TcpSocket . new if listener . accept ( client ) == SF :: Socket :: Done # Add the new client to the clients list clients << client # Add the new client to the selector so that we will # be notified when he sends something selector . add client end else # The listener socket is not ready, test all other sockets (the clients) clients . each do | client | if selector . ready? ( client ) # The client has sent some data, we can receive it packet = SF :: Packet . new if client . receive ( packet ) == SF :: Socket :: Done ... end end end end end end See also: SF::Socket","title":"SocketSelector"},{"location":"api/SF/SocketSelector.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/SocketSelector.html#methods","text":"","title":"Methods"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector#add(socket)","text":"Add a new socket to the selector This function keeps a weak reference to the socket, so you have to make sure that the socket is not destroyed while it is stored in the selector. This function does nothing if the socket is not valid. socket - Reference to the socket to add See also: remove , clear [ View source ]","title":"#add"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector#clear()","text":"Remove all the sockets stored in the selector This function doesn't destroy any instance, it simply removes all the references that the selector has to external sockets. See also: add , remove [ View source ]","title":"#clear"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector#ready?(socket)","text":"Test a socket to know if it is ready to receive data This function must be used after a call to Wait, to know which sockets are ready to receive data. If a socket is ready, a call to receive will never block because we know that there is data available to read. Note that if this function returns true for a TcpListener, this means that it is ready to accept a new connection. socket - Socket to test Returns: True if the socket is ready to read, false otherwise See also: ready? [ View source ]","title":"#ready?"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector#remove(socket)","text":"Remove a socket from the selector This function doesn't destroy the socket, it simply removes the reference that the selector has to it. socket - Reference to the socket to remove See also: add , clear [ View source ]","title":"#remove"},{"location":"api/SF/SocketSelector.html#SF::SocketSelector#wait(timeout)","text":"Wait until one or more sockets are ready to receive This function returns as soon as at least one socket has some data available to be received. To know which sockets are ready, use the ready? function. If you use a timeout and no socket is ready before the timeout is over, the function returns false. timeout - Maximum time to wait, (use Time::Zero for infinity) Returns: True if there are sockets ready, false otherwise See also: ready? [ View source ]","title":"#wait"},{"location":"api/SF/Sound.html","text":"class SF::Sound inherits SF::SoundSource # Regular sound that can be played in the audio environment SF::Sound is the class to use to play sounds. It provides: Control (play, pause, stop) Ability to modify output parameters in real-time (pitch, volume, ...) 3D spatial features (position, attenuation, ...). SF::Sound is perfect for playing short sounds that can fit in memory and require no latency, like foot steps or gun shots. For longer sounds, like background musics or long speeches, rather see SF::Music (which is based on streaming). In order to work, a sound must be given a buffer of audio data to play. Audio data (samples) is stored in SF::SoundBuffer , and attached to a sound with the buffer=() function. The buffer object attached to a sound must remain alive as long as the sound uses it. Note that multiple sounds can use the same sound buffer at the same time. Usage example: buffer = SF :: SoundBuffer . from_file ( \"sound.wav\" ) sound = SF :: Sound . new sound . buffer = buffer sound . play () See also: SF::SoundBuffer , SF::Music Class methods # .new ( buffer : SoundBuffer ) # Construct the sound with a buffer buffer - Sound buffer containing the audio data to play with the sound [ View source ] .new # Default constructor [ View source ] Methods # #buffer= ( buffer : SoundBuffer ) # Set the source buffer containing the audio data to play It is important to note that the sound buffer is not copied, thus the SF::SoundBuffer instance must remain alive as long as it is attached to the sound. buffer - Sound buffer to attach to the sound See also: buffer [ View source ] #finalize # Destructor [ View source ] #loop : Bool # Tell whether or not the sound is in loop mode Returns: True if the sound is looping, false otherwise See also: loop= [ View source ] #loop= ( loop : Bool ) # Set whether or not the sound should loop after reaching the end If set, the sound will restart from beginning after reaching the end and so on, until it is stopped or loop=(false) is called. The default looping state for sound is false. loop - True to play in loop, false to play once See also: loop [ View source ] #pause # Pause the sound This function pauses the sound if it was playing, otherwise (sound already paused or stopped) it has no effect. See also: play , stop [ View source ] #play # Start or resume playing the sound This function starts the stream if it was stopped, resumes it if it was paused, and restarts it from beginning if it was it already playing. This function uses its own thread so that it doesn't block the rest of the program while the sound is played. See also: pause , stop [ View source ] #playing_offset : Time # Get the current playing position of the sound Returns: Current playing position, from the beginning of the sound See also: playing_offset= [ View source ] #playing_offset= ( time_offset : Time ) # Change the current playing position of the sound The playing position can be changed when the sound is either paused or playing. Changing the playing position when the sound is stopped has no effect, since playing the sound will reset its position. time_offset - New playing position, from the beginning of the sound See also: playing_offset [ View source ] #reset_buffer # Reset the internal buffer of the sound This function is for internal use only, you don't have to use it. It is called by the SF::SoundBuffer that this sound uses, when it is destroyed in order to prevent the sound from using a dead buffer. [ View source ] #status : SoundSource :: Status # Get the current status of the sound (stopped, paused, playing) Returns: Current status of the sound [ View source ] #stop # stop playing the sound This function stops the sound if it was playing or paused, and does nothing if it was already stopped. It also resets the playing position (unlike pause() ). See also: play , pause [ View source ]","title":"Sound"},{"location":"api/SF/Sound.html#SF::Sound","text":"Regular sound that can be played in the audio environment SF::Sound is the class to use to play sounds. It provides: Control (play, pause, stop) Ability to modify output parameters in real-time (pitch, volume, ...) 3D spatial features (position, attenuation, ...). SF::Sound is perfect for playing short sounds that can fit in memory and require no latency, like foot steps or gun shots. For longer sounds, like background musics or long speeches, rather see SF::Music (which is based on streaming). In order to work, a sound must be given a buffer of audio data to play. Audio data (samples) is stored in SF::SoundBuffer , and attached to a sound with the buffer=() function. The buffer object attached to a sound must remain alive as long as the sound uses it. Note that multiple sounds can use the same sound buffer at the same time. Usage example: buffer = SF :: SoundBuffer . from_file ( \"sound.wav\" ) sound = SF :: Sound . new sound . buffer = buffer sound . play () See also: SF::SoundBuffer , SF::Music","title":"Sound"},{"location":"api/SF/Sound.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Sound.html#SF::Sound.new(buffer)","text":"Construct the sound with a buffer buffer - Sound buffer containing the audio data to play with the sound [ View source ]","title":".new"},{"location":"api/SF/Sound.html#methods","text":"","title":"Methods"},{"location":"api/SF/Sound.html#SF::Sound#buffer=(buffer)","text":"Set the source buffer containing the audio data to play It is important to note that the sound buffer is not copied, thus the SF::SoundBuffer instance must remain alive as long as it is attached to the sound. buffer - Sound buffer to attach to the sound See also: buffer [ View source ]","title":"#buffer="},{"location":"api/SF/Sound.html#SF::Sound#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Sound.html#SF::Sound#loop()","text":"Tell whether or not the sound is in loop mode Returns: True if the sound is looping, false otherwise See also: loop= [ View source ]","title":"#loop"},{"location":"api/SF/Sound.html#SF::Sound#loop=(loop)","text":"Set whether or not the sound should loop after reaching the end If set, the sound will restart from beginning after reaching the end and so on, until it is stopped or loop=(false) is called. The default looping state for sound is false. loop - True to play in loop, false to play once See also: loop [ View source ]","title":"#loop="},{"location":"api/SF/Sound.html#SF::Sound#pause()","text":"Pause the sound This function pauses the sound if it was playing, otherwise (sound already paused or stopped) it has no effect. See also: play , stop [ View source ]","title":"#pause"},{"location":"api/SF/Sound.html#SF::Sound#play()","text":"Start or resume playing the sound This function starts the stream if it was stopped, resumes it if it was paused, and restarts it from beginning if it was it already playing. This function uses its own thread so that it doesn't block the rest of the program while the sound is played. See also: pause , stop [ View source ]","title":"#play"},{"location":"api/SF/Sound.html#SF::Sound#playing_offset()","text":"Get the current playing position of the sound Returns: Current playing position, from the beginning of the sound See also: playing_offset= [ View source ]","title":"#playing_offset"},{"location":"api/SF/Sound.html#SF::Sound#playing_offset=(time_offset)","text":"Change the current playing position of the sound The playing position can be changed when the sound is either paused or playing. Changing the playing position when the sound is stopped has no effect, since playing the sound will reset its position. time_offset - New playing position, from the beginning of the sound See also: playing_offset [ View source ]","title":"#playing_offset="},{"location":"api/SF/Sound.html#SF::Sound#reset_buffer()","text":"Reset the internal buffer of the sound This function is for internal use only, you don't have to use it. It is called by the SF::SoundBuffer that this sound uses, when it is destroyed in order to prevent the sound from using a dead buffer. [ View source ]","title":"#reset_buffer"},{"location":"api/SF/Sound.html#SF::Sound#status()","text":"Get the current status of the sound (stopped, paused, playing) Returns: Current status of the sound [ View source ]","title":"#status"},{"location":"api/SF/Sound.html#SF::Sound#stop()","text":"stop playing the sound This function stops the sound if it was playing or paused, and does nothing if it was already stopped. It also resets the playing position (unlike pause() ). See also: play , pause [ View source ]","title":"#stop"},{"location":"api/SF/SoundBuffer.html","text":"class SF::SoundBuffer inherits Reference # Storage for audio samples defining a sound A sound buffer holds the data of a sound, which is an array of audio samples. A sample is a 16 bits signed integer that defines the amplitude of the sound at a given time. The sound is then reconstituted by playing these samples at a high rate (for example, 44100 samples per second is the standard rate used for playing CDs). In short, audio samples are like texture pixels, and a SF::SoundBuffer is similar to a SF::Texture . A sound buffer can be loaded from a file (see load_from_file() for the complete list of supported formats), from memory, from a custom stream (see SF::InputStream ) or directly from an array of samples. It can also be saved back to a file. Sound buffers alone are not very useful: they hold the audio data but cannot be played. To do so, you need to use the SF::Sound class, which provides functions to play/pause/stop the sound as well as changing the way it is outputted (volume, pitch, 3D position, ...). This separation allows more flexibility and better performances: indeed a SF::SoundBuffer is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a SF::Sound is a lightweight object, which can use the audio data of a sound buffer and change the way it is played without actually modifying that data. Note that it is also possible to bind several SF::Sound instances to the same SF::SoundBuffer . It is important to note that the SF::Sound instance doesn't copy the buffer that it uses, it only keeps a reference to it. Thus, a SF::SoundBuffer must not be destructed while it is used by a SF::Sound (i.e. never write a function that uses a local SF::SoundBuffer instance for loading a sound). Usage example: # Load a new sound buffer from a file buffer = SF :: SoundBuffer . from_file ( \"sound.wav\" ) # Create a sound source and bind it to the buffer sound1 = SF :: Sound . new sound1 . buffer = buffer # Play the sound sound1 . play () # Create another sound source bound to the same buffer sound2 = SF :: Sound . new sound2 . buffer = buffer # Play it with a higher pitch -- the first sound remains unchanged sound2 . pitch = 2 sound2 . play () See also: SF::Sound , SF::SoundBufferRecorder Included modules # SF::AlResource Class methods # .from_file ( * args , ** kwargs ) : self # Shorthand for sound_buffer = SoundBuffer.new; sound_buffer.load_from_file(...); sound_buffer Raises InitError on failure [ View source ] .from_memory ( * args , ** kwargs ) : self # Shorthand for sound_buffer = SoundBuffer.new; sound_buffer.load_from_memory(...); sound_buffer Raises InitError on failure [ View source ] .from_samples ( * args , ** kwargs ) : self # Shorthand for sound_buffer = SoundBuffer.new; sound_buffer.load_from_samples(...); sound_buffer Raises InitError on failure [ View source ] .from_stream ( * args , ** kwargs ) : self # Shorthand for sound_buffer = SoundBuffer.new; sound_buffer.load_from_stream(...); sound_buffer Raises InitError on failure [ View source ] .new # Default constructor [ View source ] Methods # #channel_count : Int32 # Get the number of channels used by the sound If the sound is mono then the number of channels will be 1, 2 for stereo, etc. Returns: Number of channels See also: sample_rate , duration [ View source ] #duration : Time # Get the total duration of the sound Returns: Sound duration See also: sample_rate , channel_count [ View source ] #finalize # Destructor [ View source ] #load_from_file ( filename : String ) : Bool # Load the sound buffer from a file See the documentation of SF::InputSoundFile for the list of supported formats. filename - Path of the sound file to load Returns: True if loading succeeded, false if it failed See also: load_from_memory , load_from_stream , load_from_samples , save_to_file [ View source ] #load_from_memory ( data : Slice ) : Bool # Load the sound buffer from a file in memory See the documentation of SF::InputSoundFile for the list of supported formats. data - Slice containing the file data in memory Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_stream , load_from_samples [ View source ] #load_from_samples ( samples : Array ( Int16 ) | Slice ( Int16 ), channel_count : Int , sample_rate : Int ) : Bool # Load the sound buffer from an array of audio samples The assumed format of the audio samples is 16 bits signed integer ( SF::Int16 ). samples - Pointer to the array of samples in memory sample_count - Number of samples in the array channel_count - Number of channels (1 = mono, 2 = stereo, ...) sample_rate - Sample rate (number of samples to play per second) Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory , save_to_file [ View source ] #load_from_stream ( stream : InputStream ) : Bool # Load the sound buffer from a custom stream See the documentation of SF::InputSoundFile for the list of supported formats. stream - Source stream to read from Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory , load_from_samples [ View source ] #sample_count : UInt64 # Get the number of samples stored in the buffer The array of samples can be accessed with the samples() function. Returns: Number of samples See also: samples [ View source ] #sample_rate : Int32 # Get the sample rate of the sound The sample rate is the number of samples played per second. The higher, the better the quality (for example, 44100 samples/s is CD quality). Returns: Sample rate (number of samples per second) See also: channel_count , duration [ View source ] #samples : Pointer ( Int16 ) # Get the array of audio samples stored in the buffer The format of the returned samples is 16 bits signed integer ( SF::Int16 ). The total number of samples in this array is given by the sample_count() function. Returns: Read-only pointer to the array of sound samples See also: sample_count [ View source ] #save_to_file ( filename : String ) : Bool # Save the sound buffer to an audio file See the documentation of SF::OutputSoundFile for the list of supported formats. filename - Path of the sound file to write Returns: True if saving succeeded, false if it failed See also: load_from_file , load_from_memory , load_from_samples [ View source ]","title":"SoundBuffer"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer","text":"Storage for audio samples defining a sound A sound buffer holds the data of a sound, which is an array of audio samples. A sample is a 16 bits signed integer that defines the amplitude of the sound at a given time. The sound is then reconstituted by playing these samples at a high rate (for example, 44100 samples per second is the standard rate used for playing CDs). In short, audio samples are like texture pixels, and a SF::SoundBuffer is similar to a SF::Texture . A sound buffer can be loaded from a file (see load_from_file() for the complete list of supported formats), from memory, from a custom stream (see SF::InputStream ) or directly from an array of samples. It can also be saved back to a file. Sound buffers alone are not very useful: they hold the audio data but cannot be played. To do so, you need to use the SF::Sound class, which provides functions to play/pause/stop the sound as well as changing the way it is outputted (volume, pitch, 3D position, ...). This separation allows more flexibility and better performances: indeed a SF::SoundBuffer is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a SF::Sound is a lightweight object, which can use the audio data of a sound buffer and change the way it is played without actually modifying that data. Note that it is also possible to bind several SF::Sound instances to the same SF::SoundBuffer . It is important to note that the SF::Sound instance doesn't copy the buffer that it uses, it only keeps a reference to it. Thus, a SF::SoundBuffer must not be destructed while it is used by a SF::Sound (i.e. never write a function that uses a local SF::SoundBuffer instance for loading a sound). Usage example: # Load a new sound buffer from a file buffer = SF :: SoundBuffer . from_file ( \"sound.wav\" ) # Create a sound source and bind it to the buffer sound1 = SF :: Sound . new sound1 . buffer = buffer # Play the sound sound1 . play () # Create another sound source bound to the same buffer sound2 = SF :: Sound . new sound2 . buffer = buffer # Play it with a higher pitch -- the first sound remains unchanged sound2 . pitch = 2 sound2 . play () See also: SF::Sound , SF::SoundBufferRecorder","title":"SoundBuffer"},{"location":"api/SF/SoundBuffer.html#included-modules","text":"SF::AlResource","title":"Included modules"},{"location":"api/SF/SoundBuffer.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer.from_file(*args,**kwargs)","text":"Shorthand for sound_buffer = SoundBuffer.new; sound_buffer.load_from_file(...); sound_buffer Raises InitError on failure [ View source ]","title":".from_file"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer.from_memory(*args,**kwargs)","text":"Shorthand for sound_buffer = SoundBuffer.new; sound_buffer.load_from_memory(...); sound_buffer Raises InitError on failure [ View source ]","title":".from_memory"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer.from_samples(*args,**kwargs)","text":"Shorthand for sound_buffer = SoundBuffer.new; sound_buffer.load_from_samples(...); sound_buffer Raises InitError on failure [ View source ]","title":".from_samples"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer.from_stream(*args,**kwargs)","text":"Shorthand for sound_buffer = SoundBuffer.new; sound_buffer.load_from_stream(...); sound_buffer Raises InitError on failure [ View source ]","title":".from_stream"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/SoundBuffer.html#methods","text":"","title":"Methods"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#channel_count()","text":"Get the number of channels used by the sound If the sound is mono then the number of channels will be 1, 2 for stereo, etc. Returns: Number of channels See also: sample_rate , duration [ View source ]","title":"#channel_count"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#duration()","text":"Get the total duration of the sound Returns: Sound duration See also: sample_rate , channel_count [ View source ]","title":"#duration"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#load_from_file(filename)","text":"Load the sound buffer from a file See the documentation of SF::InputSoundFile for the list of supported formats. filename - Path of the sound file to load Returns: True if loading succeeded, false if it failed See also: load_from_memory , load_from_stream , load_from_samples , save_to_file [ View source ]","title":"#load_from_file"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#load_from_memory(data)","text":"Load the sound buffer from a file in memory See the documentation of SF::InputSoundFile for the list of supported formats. data - Slice containing the file data in memory Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_stream , load_from_samples [ View source ]","title":"#load_from_memory"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#load_from_samples(samples,channel_count,sample_rate)","text":"Load the sound buffer from an array of audio samples The assumed format of the audio samples is 16 bits signed integer ( SF::Int16 ). samples - Pointer to the array of samples in memory sample_count - Number of samples in the array channel_count - Number of channels (1 = mono, 2 = stereo, ...) sample_rate - Sample rate (number of samples to play per second) Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory , save_to_file [ View source ]","title":"#load_from_samples"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#load_from_stream(stream)","text":"Load the sound buffer from a custom stream See the documentation of SF::InputSoundFile for the list of supported formats. stream - Source stream to read from Returns: True if loading succeeded, false if it failed See also: load_from_file , load_from_memory , load_from_samples [ View source ]","title":"#load_from_stream"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#sample_count()","text":"Get the number of samples stored in the buffer The array of samples can be accessed with the samples() function. Returns: Number of samples See also: samples [ View source ]","title":"#sample_count"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#sample_rate()","text":"Get the sample rate of the sound The sample rate is the number of samples played per second. The higher, the better the quality (for example, 44100 samples/s is CD quality). Returns: Sample rate (number of samples per second) See also: channel_count , duration [ View source ]","title":"#sample_rate"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#samples()","text":"Get the array of audio samples stored in the buffer The format of the returned samples is 16 bits signed integer ( SF::Int16 ). The total number of samples in this array is given by the sample_count() function. Returns: Read-only pointer to the array of sound samples See also: sample_count [ View source ]","title":"#samples"},{"location":"api/SF/SoundBuffer.html#SF::SoundBuffer#save_to_file(filename)","text":"Save the sound buffer to an audio file See the documentation of SF::OutputSoundFile for the list of supported formats. filename - Path of the sound file to write Returns: True if saving succeeded, false if it failed See also: load_from_file , load_from_memory , load_from_samples [ View source ]","title":"#save_to_file"},{"location":"api/SF/SoundBufferRecorder.html","text":"class SF::SoundBufferRecorder inherits SF::SoundRecorder # Specialized SoundRecorder which stores the captured audio data into a sound buffer SF::SoundBufferRecorder allows to access a recorded sound through a SF::SoundBuffer , so that it can be played, saved to a file, etc. It has the same simple interface as its base class (start(), stop() ) and adds a function to retrieve the recorded sound buffer (buffer()). As usual, don't forget to call the available?() function before using this class (see SF::SoundRecorder for more details about this). Usage example: if SF :: SoundBufferRecorder . available? # Record some audio data recorder = SF :: SoundBufferRecorder . new recorder . start () ... recorder . stop () # Get the buffer containing the captured audio data buffer = recorder . buffer # Save it to a file (for example...) buffer . save_to_file ( \"my_record.ogg\" ) end See also: SF::SoundRecorder Class methods # .new # [ View source ] Methods # #buffer : SoundBuffer # Get the sound buffer containing the captured audio data The sound buffer is valid only after the capture has ended. This function provides a read-only access to the internal sound buffer, but it can be copied if you need to make any modification to it. Returns: Read-only access to the sound buffer [ View source ] #finalize # destructor [ View source ] #on_process_samples ( samples : Array ( Int16 ) | Slice ( Int16 )) : Bool # Process a new chunk of recorded samples samples - Pointer to the new chunk of recorded samples sample_count - Number of samples pointed by samples Returns: True to continue the capture, or false to stop it [ View source ] #on_start : Bool # Start capturing audio data Returns: True to start the capture, or false to abort it [ View source ] #on_stop # Stop capturing audio data [ View source ]","title":"SoundBufferRecorder"},{"location":"api/SF/SoundBufferRecorder.html#SF::SoundBufferRecorder","text":"Specialized SoundRecorder which stores the captured audio data into a sound buffer SF::SoundBufferRecorder allows to access a recorded sound through a SF::SoundBuffer , so that it can be played, saved to a file, etc. It has the same simple interface as its base class (start(), stop() ) and adds a function to retrieve the recorded sound buffer (buffer()). As usual, don't forget to call the available?() function before using this class (see SF::SoundRecorder for more details about this). Usage example: if SF :: SoundBufferRecorder . available? # Record some audio data recorder = SF :: SoundBufferRecorder . new recorder . start () ... recorder . stop () # Get the buffer containing the captured audio data buffer = recorder . buffer # Save it to a file (for example...) buffer . save_to_file ( \"my_record.ogg\" ) end See also: SF::SoundRecorder","title":"SoundBufferRecorder"},{"location":"api/SF/SoundBufferRecorder.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/SoundBufferRecorder.html#SF::SoundBufferRecorder.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/SoundBufferRecorder.html#methods","text":"","title":"Methods"},{"location":"api/SF/SoundBufferRecorder.html#SF::SoundBufferRecorder#buffer()","text":"Get the sound buffer containing the captured audio data The sound buffer is valid only after the capture has ended. This function provides a read-only access to the internal sound buffer, but it can be copied if you need to make any modification to it. Returns: Read-only access to the sound buffer [ View source ]","title":"#buffer"},{"location":"api/SF/SoundBufferRecorder.html#SF::SoundBufferRecorder#finalize()","text":"destructor [ View source ]","title":"#finalize"},{"location":"api/SF/SoundBufferRecorder.html#SF::SoundBufferRecorder#on_process_samples(samples)","text":"Process a new chunk of recorded samples samples - Pointer to the new chunk of recorded samples sample_count - Number of samples pointed by samples Returns: True to continue the capture, or false to stop it [ View source ]","title":"#on_process_samples"},{"location":"api/SF/SoundBufferRecorder.html#SF::SoundBufferRecorder#on_start()","text":"Start capturing audio data Returns: True to start the capture, or false to abort it [ View source ]","title":"#on_start"},{"location":"api/SF/SoundBufferRecorder.html#SF::SoundBufferRecorder#on_stop()","text":"Stop capturing audio data [ View source ]","title":"#on_stop"},{"location":"api/SF/SoundRecorder.html","text":"abstract class SF::SoundRecorder inherits Reference # Abstract base class for capturing sound data SF::SoundBuffer provides a simple interface to access the audio recording capabilities of the computer (the microphone). As an abstract base class, it only cares about capturing sound samples, the task of making something useful with them is left to the derived class. Note that SFML provides a built-in specialization for saving the captured data to a sound buffer (see SF::SoundBufferRecorder ). A derived class has only one virtual function to override: on_process_samples provides the new chunks of audio samples while the capture happens Moreover, two additional virtual functions can be overridden as well if necessary: on_start is called before the capture happens, to perform custom initializations on_stop is called after the capture ends, to perform custom cleanup A derived class can also control the frequency of the on_process_samples calls, with the processing_interval= protected function. The default interval is chosen so that recording thread doesn't consume too much CPU, but it can be changed to a smaller value if you need to process the recorded data in real time, for example. The audio capture feature may not be supported or activated on every platform, thus it is recommended to check its availability with the available?() function. If it returns false, then any attempt to use an audio recorder will fail. If you have multiple sound input devices connected to your computer (for example: microphone, external soundcard, webcam mic, ...) you can get a list of all available devices through the available_devices() function. You can then select a device by calling device=() with the appropriate device. Otherwise the default capturing device will be used. By default the recording is in 16-bit mono. Using the channel_count= method you can change the number of channels used by the audio capture device to record. Note that you have to decide whether you want to record in mono or stereo before starting the recording. It is important to note that the audio capture happens in a separate thread, so that it doesn't block the rest of the program. In particular, the on_process_samples virtual function (but not on_start and not on_stop) will be called from this separate thread. It is important to keep this in mind, because you may have to take care of synchronization issues if you share data between threads. Another thing to bear in mind is that you must call stop() in the destructor of your derived class, so that the recording thread finishes before your object is destroyed. Usage example: class CustomRecorder < SF :: SoundRecorder def finalize # Make sure to stop the recording thread stop () end def on_start () # optional # Initialize whatever has to be done before the capture starts ... # Return true to start playing true end def on_process_samples ( samples ) # Do something with the new chunk of samples (store them, send them, ...) ... # Return true to continue playing true end def on_stop () # optional # Clean up whatever has to be done after the capture ends ... end end # Usage if ( CustomRecorder . isAvailable ()) CustomRecorder recorder if ( ! recorder . start ()) return - 1 ... recorder . stop () end See also: SF::SoundBufferRecorder Included modules # SF::AlResource Direct known subclasses # SF::SoundBufferRecorder Class methods # .available? : Bool # Check if the system supports audio capture This function should always be called before using the audio capture features. If it returns false, then any attempt to use SF::SoundRecorder or one of its derived classes will fail. Returns: True if audio capture is supported, false otherwise [ View source ] .available_devices : Array ( String ) # Get a list of the names of all available audio capture devices This function returns a vector of strings, containing the names of all available audio capture devices. Returns: A vector of strings containing the names [ View source ] .default_device : String # Get the name of the default audio capture device This function returns the name of the default audio capture device. If none is available, an empty string is returned. Returns: The name of the default audio capture device [ View source ] Methods # #channel_count : Int32 # Get the number of channels used by this recorder Currently only mono and stereo are supported, so the value is either 1 (for mono) or 2 (for stereo). Returns: Number of channels See also: channel_count= [ View source ] #channel_count= ( channel_count : Int ) # Set the channel count of the audio capture device This method allows you to specify the number of channels used for recording. Currently only 16-bit mono and 16-bit stereo are supported. channel_count - Number of channels. Currently only mono (1) and stereo (2) are supported. See also: channel_count [ View source ] #device : String # Get the name of the current audio capture device Returns: The name of the current audio capture device [ View source ] #device= ( name : String ) : Bool # Set the audio capture device This function sets the audio capture device to the device with the given name. It can be called on the fly (i.e: while recording). If you do so while recording and opening the device fails, it stops the recording. name - The name of the audio capture device Returns: True, if it was able to set the requested device See also: available_devices , default_device [ View source ] #finalize # destructor [ View source ] abstract #on_process_samples ( samples : Array ( Int16 ) | Slice ( Int16 )) : Bool # Process a new chunk of recorded samples This virtual function is called every time a new chunk of recorded data is available. The derived class can then do whatever it wants with it (storing it, playing it, sending it over the network, etc.). samples - Pointer to the new chunk of recorded samples sample_count - Number of samples pointed by samples Returns: True to continue the capture, or false to stop it [ View source ] #on_start : Bool # Start capturing audio data This virtual function may be overridden by a derived class if something has to be done every time a new capture starts. If not, this function can be ignored; the default implementation does nothing. Returns: True to start the capture, or false to abort it [ View source ] #on_stop # Stop capturing audio data This virtual function may be overridden by a derived class if something has to be done every time the capture ends. If not, this function can be ignored; the default implementation does nothing. [ View source ] #processing_interval= ( interval : Time ) # Set the processing interval The processing interval controls the period between calls to the on_process_samples function. You may want to use a small interval if you want to process the recorded data in real time, for example. Note: this is only a hint, the actual period may vary. So don't rely on this parameter to implement precise timing. The default processing interval is 100 ms. interval - Processing interval [ View source ] #sample_rate : Int32 # Get the sample rate The sample rate defines the number of audio samples captured per second. The higher, the better the quality (for example, 44100 samples/sec is CD quality). Returns: Sample rate, in samples per second [ View source ] #start ( sample_rate : Int = 44100 ) : Bool # Start the capture The sample_rate parameter defines the number of audio samples captured per second. The higher, the better the quality (for example, 44100 samples/sec is CD quality). This function uses its own thread so that it doesn't block the rest of the program while the capture runs. Please note that only one capture can happen at the same time. You can select which capture device will be used, by passing the name to the device=() method. If none was selected before, the default capture device will be used. You can get a list of the names of all available capture devices by calling available_devices(). sample_rate - Desired capture rate, in number of samples per second Returns: True, if start of capture was successful See also: stop , available_devices [ View source ] #stop # Stop the capture See also: start [ View source ]","title":"SoundRecorder"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder","text":"Abstract base class for capturing sound data SF::SoundBuffer provides a simple interface to access the audio recording capabilities of the computer (the microphone). As an abstract base class, it only cares about capturing sound samples, the task of making something useful with them is left to the derived class. Note that SFML provides a built-in specialization for saving the captured data to a sound buffer (see SF::SoundBufferRecorder ). A derived class has only one virtual function to override: on_process_samples provides the new chunks of audio samples while the capture happens Moreover, two additional virtual functions can be overridden as well if necessary: on_start is called before the capture happens, to perform custom initializations on_stop is called after the capture ends, to perform custom cleanup A derived class can also control the frequency of the on_process_samples calls, with the processing_interval= protected function. The default interval is chosen so that recording thread doesn't consume too much CPU, but it can be changed to a smaller value if you need to process the recorded data in real time, for example. The audio capture feature may not be supported or activated on every platform, thus it is recommended to check its availability with the available?() function. If it returns false, then any attempt to use an audio recorder will fail. If you have multiple sound input devices connected to your computer (for example: microphone, external soundcard, webcam mic, ...) you can get a list of all available devices through the available_devices() function. You can then select a device by calling device=() with the appropriate device. Otherwise the default capturing device will be used. By default the recording is in 16-bit mono. Using the channel_count= method you can change the number of channels used by the audio capture device to record. Note that you have to decide whether you want to record in mono or stereo before starting the recording. It is important to note that the audio capture happens in a separate thread, so that it doesn't block the rest of the program. In particular, the on_process_samples virtual function (but not on_start and not on_stop) will be called from this separate thread. It is important to keep this in mind, because you may have to take care of synchronization issues if you share data between threads. Another thing to bear in mind is that you must call stop() in the destructor of your derived class, so that the recording thread finishes before your object is destroyed. Usage example: class CustomRecorder < SF :: SoundRecorder def finalize # Make sure to stop the recording thread stop () end def on_start () # optional # Initialize whatever has to be done before the capture starts ... # Return true to start playing true end def on_process_samples ( samples ) # Do something with the new chunk of samples (store them, send them, ...) ... # Return true to continue playing true end def on_stop () # optional # Clean up whatever has to be done after the capture ends ... end end # Usage if ( CustomRecorder . isAvailable ()) CustomRecorder recorder if ( ! recorder . start ()) return - 1 ... recorder . stop () end See also: SF::SoundBufferRecorder","title":"SoundRecorder"},{"location":"api/SF/SoundRecorder.html#included-modules","text":"SF::AlResource","title":"Included modules"},{"location":"api/SF/SoundRecorder.html#direct-known-subclasses","text":"SF::SoundBufferRecorder","title":"Direct known subclasses"},{"location":"api/SF/SoundRecorder.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder.available?()","text":"Check if the system supports audio capture This function should always be called before using the audio capture features. If it returns false, then any attempt to use SF::SoundRecorder or one of its derived classes will fail. Returns: True if audio capture is supported, false otherwise [ View source ]","title":".available?"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder.available_devices()","text":"Get a list of the names of all available audio capture devices This function returns a vector of strings, containing the names of all available audio capture devices. Returns: A vector of strings containing the names [ View source ]","title":".available_devices"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder.default_device()","text":"Get the name of the default audio capture device This function returns the name of the default audio capture device. If none is available, an empty string is returned. Returns: The name of the default audio capture device [ View source ]","title":".default_device"},{"location":"api/SF/SoundRecorder.html#methods","text":"","title":"Methods"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#channel_count()","text":"Get the number of channels used by this recorder Currently only mono and stereo are supported, so the value is either 1 (for mono) or 2 (for stereo). Returns: Number of channels See also: channel_count= [ View source ]","title":"#channel_count"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#channel_count=(channel_count)","text":"Set the channel count of the audio capture device This method allows you to specify the number of channels used for recording. Currently only 16-bit mono and 16-bit stereo are supported. channel_count - Number of channels. Currently only mono (1) and stereo (2) are supported. See also: channel_count [ View source ]","title":"#channel_count="},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#device()","text":"Get the name of the current audio capture device Returns: The name of the current audio capture device [ View source ]","title":"#device"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#device=(name)","text":"Set the audio capture device This function sets the audio capture device to the device with the given name. It can be called on the fly (i.e: while recording). If you do so while recording and opening the device fails, it stops the recording. name - The name of the audio capture device Returns: True, if it was able to set the requested device See also: available_devices , default_device [ View source ]","title":"#device="},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#finalize()","text":"destructor [ View source ]","title":"#finalize"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#on_process_samples(samples)","text":"Process a new chunk of recorded samples This virtual function is called every time a new chunk of recorded data is available. The derived class can then do whatever it wants with it (storing it, playing it, sending it over the network, etc.). samples - Pointer to the new chunk of recorded samples sample_count - Number of samples pointed by samples Returns: True to continue the capture, or false to stop it [ View source ]","title":"#on_process_samples"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#on_start()","text":"Start capturing audio data This virtual function may be overridden by a derived class if something has to be done every time a new capture starts. If not, this function can be ignored; the default implementation does nothing. Returns: True to start the capture, or false to abort it [ View source ]","title":"#on_start"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#on_stop()","text":"Stop capturing audio data This virtual function may be overridden by a derived class if something has to be done every time the capture ends. If not, this function can be ignored; the default implementation does nothing. [ View source ]","title":"#on_stop"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#processing_interval=(interval)","text":"Set the processing interval The processing interval controls the period between calls to the on_process_samples function. You may want to use a small interval if you want to process the recorded data in real time, for example. Note: this is only a hint, the actual period may vary. So don't rely on this parameter to implement precise timing. The default processing interval is 100 ms. interval - Processing interval [ View source ]","title":"#processing_interval="},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#sample_rate()","text":"Get the sample rate The sample rate defines the number of audio samples captured per second. The higher, the better the quality (for example, 44100 samples/sec is CD quality). Returns: Sample rate, in samples per second [ View source ]","title":"#sample_rate"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#start(sample_rate)","text":"Start the capture The sample_rate parameter defines the number of audio samples captured per second. The higher, the better the quality (for example, 44100 samples/sec is CD quality). This function uses its own thread so that it doesn't block the rest of the program while the capture runs. Please note that only one capture can happen at the same time. You can select which capture device will be used, by passing the name to the device=() method. If none was selected before, the default capture device will be used. You can get a list of the names of all available capture devices by calling available_devices(). sample_rate - Desired capture rate, in number of samples per second Returns: True, if start of capture was successful See also: stop , available_devices [ View source ]","title":"#start"},{"location":"api/SF/SoundRecorder.html#SF::SoundRecorder#stop()","text":"Stop the capture See also: start [ View source ]","title":"#stop"},{"location":"api/SF/SoundSource.html","text":"abstract class SF::SoundSource inherits Reference # Base class defining a sound's properties SF::SoundSource is not meant to be used directly, it only serves as a common base for all audio objects that can live in the audio environment. It defines several properties for the sound: pitch, volume, position, attenuation, etc. All of them can be changed at any time with no impact on performances. See also: SF::Sound , SF::SoundStream Included modules # SF::AlResource Direct known subclasses # SF::Sound SF::SoundStream Methods # #attenuation : Float32 # Get the attenuation factor of the sound Returns: Attenuation factor of the sound See also: attenuation= , min_distance [ View source ] #attenuation= ( attenuation : Number ) # Set the attenuation factor of the sound The attenuation is a multiplicative factor which makes the sound more or less loud according to its distance from the listener. An attenuation of 0 will produce a non-attenuated sound, i.e. its volume will always be the same whether it is heard from near or from far. On the other hand, an attenuation value such as 100 will make the sound fade out very quickly as it gets further from the listener. The default value of the attenuation is 1. attenuation - New attenuation factor of the sound See also: attenuation , min_distance= [ View source ] #finalize # Destructor [ View source ] #min_distance : Float32 # Get the minimum distance of the sound Returns: Minimum distance of the sound See also: min_distance= , attenuation [ View source ] #min_distance= ( distance : Number ) # Set the minimum distance of the sound The \"minimum distance\" of a sound is the maximum distance at which it is heard at its maximum volume. Further than the minimum distance, it will start to fade out according to its attenuation factor. A value of 0 (\"inside the head of the listener\") is an invalid value and is forbidden. The default value of the minimum distance is 1. distance - New minimum distance of the sound See also: min_distance , attenuation= [ View source ] abstract #pause # Pause the sound source This function pauses the source if it was playing, otherwise (source already paused or stopped) it has no effect. See also: play , stop [ View source ] #pitch : Float32 # Get the pitch of the sound Returns: Pitch of the sound See also: pitch= [ View source ] #pitch= ( pitch : Number ) # Set the pitch of the sound The pitch represents the perceived fundamental frequency of a sound; thus you can make a sound more acute or grave by changing its pitch. A side effect of changing the pitch is to modify the playing speed of the sound as well. The default value for the pitch is 1. pitch - New pitch to apply to the sound See also: pitch [ View source ] abstract #play # Start or resume playing the sound source This function starts the source if it was stopped, resumes it if it was paused, and restarts it from the beginning if it was already playing. See also: pause , stop [ View source ] #position : Vector3f # Get the 3D position of the sound in the audio scene Returns: Position of the sound See also: position= [ View source ] #position= ( position : Vector3f ) # Set the 3D position of the sound in the audio scene Only sounds with one channel (mono sounds) can be spatialized. The default position of a sound is (0, 0, 0). position - Position of the sound in the scene See also: position [ View source ] #relative_to_listener= ( relative : Bool ) # Make the sound's position relative to the listener or absolute Making a sound relative to the listener will ensure that it will always be played the same way regardless of the position of the listener. This can be useful for non-spatialized sounds, sounds that are produced by the listener, or sounds attached to it. The default value is false (position is absolute). relative - True to set the position relative, false to set it absolute See also: relative_to_listener? [ View source ] #relative_to_listener? : Bool # Tell whether the sound's position is relative to the listener or is absolute Returns: True if the position is relative, false if it's absolute See also: relative_to_listener= [ View source ] #set_position ( x : Number , y : Number , z : Number ) # Set the 3D position of the sound in the audio scene Only sounds with one channel (mono sounds) can be spatialized. The default position of a sound is (0, 0, 0). x - X coordinate of the position of the sound in the scene y - Y coordinate of the position of the sound in the scene z - Z coordinate of the position of the sound in the scene See also: position [ View source ] #status : SoundSource :: Status # Get the current status of the sound (stopped, paused, playing) Returns: Current status of the sound [ View source ] abstract #stop # Stop playing the sound source This function stops the source if it was playing or paused, and does nothing if it was already stopped. It also resets the playing position (unlike pause() ). See also: play , pause [ View source ] #volume : Float32 # Get the volume of the sound Returns: Volume of the sound, in the range 0..100 See also: volume= [ View source ] #volume= ( volume : Number ) # Set the volume of the sound The volume is a value between 0 (mute) and 100 (full volume). The default value for the volume is 100. volume - Volume of the sound See also: volume [ View source ]","title":"SoundSource"},{"location":"api/SF/SoundSource.html#SF::SoundSource","text":"Base class defining a sound's properties SF::SoundSource is not meant to be used directly, it only serves as a common base for all audio objects that can live in the audio environment. It defines several properties for the sound: pitch, volume, position, attenuation, etc. All of them can be changed at any time with no impact on performances. See also: SF::Sound , SF::SoundStream","title":"SoundSource"},{"location":"api/SF/SoundSource.html#included-modules","text":"SF::AlResource","title":"Included modules"},{"location":"api/SF/SoundSource.html#direct-known-subclasses","text":"SF::Sound SF::SoundStream","title":"Direct known subclasses"},{"location":"api/SF/SoundSource.html#methods","text":"","title":"Methods"},{"location":"api/SF/SoundSource.html#SF::SoundSource#attenuation()","text":"Get the attenuation factor of the sound Returns: Attenuation factor of the sound See also: attenuation= , min_distance [ View source ]","title":"#attenuation"},{"location":"api/SF/SoundSource.html#SF::SoundSource#attenuation=(attenuation)","text":"Set the attenuation factor of the sound The attenuation is a multiplicative factor which makes the sound more or less loud according to its distance from the listener. An attenuation of 0 will produce a non-attenuated sound, i.e. its volume will always be the same whether it is heard from near or from far. On the other hand, an attenuation value such as 100 will make the sound fade out very quickly as it gets further from the listener. The default value of the attenuation is 1. attenuation - New attenuation factor of the sound See also: attenuation , min_distance= [ View source ]","title":"#attenuation="},{"location":"api/SF/SoundSource.html#SF::SoundSource#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/SoundSource.html#SF::SoundSource#min_distance()","text":"Get the minimum distance of the sound Returns: Minimum distance of the sound See also: min_distance= , attenuation [ View source ]","title":"#min_distance"},{"location":"api/SF/SoundSource.html#SF::SoundSource#min_distance=(distance)","text":"Set the minimum distance of the sound The \"minimum distance\" of a sound is the maximum distance at which it is heard at its maximum volume. Further than the minimum distance, it will start to fade out according to its attenuation factor. A value of 0 (\"inside the head of the listener\") is an invalid value and is forbidden. The default value of the minimum distance is 1. distance - New minimum distance of the sound See also: min_distance , attenuation= [ View source ]","title":"#min_distance="},{"location":"api/SF/SoundSource.html#SF::SoundSource#pause()","text":"Pause the sound source This function pauses the source if it was playing, otherwise (source already paused or stopped) it has no effect. See also: play , stop [ View source ]","title":"#pause"},{"location":"api/SF/SoundSource.html#SF::SoundSource#pitch()","text":"Get the pitch of the sound Returns: Pitch of the sound See also: pitch= [ View source ]","title":"#pitch"},{"location":"api/SF/SoundSource.html#SF::SoundSource#pitch=(pitch)","text":"Set the pitch of the sound The pitch represents the perceived fundamental frequency of a sound; thus you can make a sound more acute or grave by changing its pitch. A side effect of changing the pitch is to modify the playing speed of the sound as well. The default value for the pitch is 1. pitch - New pitch to apply to the sound See also: pitch [ View source ]","title":"#pitch="},{"location":"api/SF/SoundSource.html#SF::SoundSource#play()","text":"Start or resume playing the sound source This function starts the source if it was stopped, resumes it if it was paused, and restarts it from the beginning if it was already playing. See also: pause , stop [ View source ]","title":"#play"},{"location":"api/SF/SoundSource.html#SF::SoundSource#position()","text":"Get the 3D position of the sound in the audio scene Returns: Position of the sound See also: position= [ View source ]","title":"#position"},{"location":"api/SF/SoundSource.html#SF::SoundSource#position=(position)","text":"Set the 3D position of the sound in the audio scene Only sounds with one channel (mono sounds) can be spatialized. The default position of a sound is (0, 0, 0). position - Position of the sound in the scene See also: position [ View source ]","title":"#position="},{"location":"api/SF/SoundSource.html#SF::SoundSource#relative_to_listener=(relative)","text":"Make the sound's position relative to the listener or absolute Making a sound relative to the listener will ensure that it will always be played the same way regardless of the position of the listener. This can be useful for non-spatialized sounds, sounds that are produced by the listener, or sounds attached to it. The default value is false (position is absolute). relative - True to set the position relative, false to set it absolute See also: relative_to_listener? [ View source ]","title":"#relative_to_listener="},{"location":"api/SF/SoundSource.html#SF::SoundSource#relative_to_listener?()","text":"Tell whether the sound's position is relative to the listener or is absolute Returns: True if the position is relative, false if it's absolute See also: relative_to_listener= [ View source ]","title":"#relative_to_listener?"},{"location":"api/SF/SoundSource.html#SF::SoundSource#set_position(x,y,z)","text":"Set the 3D position of the sound in the audio scene Only sounds with one channel (mono sounds) can be spatialized. The default position of a sound is (0, 0, 0). x - X coordinate of the position of the sound in the scene y - Y coordinate of the position of the sound in the scene z - Z coordinate of the position of the sound in the scene See also: position [ View source ]","title":"#set_position"},{"location":"api/SF/SoundSource.html#SF::SoundSource#status()","text":"Get the current status of the sound (stopped, paused, playing) Returns: Current status of the sound [ View source ]","title":"#status"},{"location":"api/SF/SoundSource.html#SF::SoundSource#stop()","text":"Stop playing the sound source This function stops the source if it was playing or paused, and does nothing if it was already stopped. It also resets the playing position (unlike pause() ). See also: play , pause [ View source ]","title":"#stop"},{"location":"api/SF/SoundSource.html#SF::SoundSource#volume()","text":"Get the volume of the sound Returns: Volume of the sound, in the range 0..100 See also: volume= [ View source ]","title":"#volume"},{"location":"api/SF/SoundSource.html#SF::SoundSource#volume=(volume)","text":"Set the volume of the sound The volume is a value between 0 (mute) and 100 (full volume). The default value for the volume is 100. volume - Volume of the sound See also: volume [ View source ]","title":"#volume="},{"location":"api/SF/SoundStream.html","text":"abstract class SF::SoundStream inherits SF::SoundSource # Abstract base class for streamed audio sources Unlike audio buffers (see SF::SoundBuffer ), audio streams are never completely loaded in memory. Instead, the audio data is acquired continuously while the stream is playing. This behavior allows to play a sound with no loading delay, and keeps the memory consumption very low. Sound sources that need to be streamed are usually big files (compressed audio musics that would eat hundreds of MB in memory) or files that would take a lot of time to be received (sounds played over the network). SF::SoundStream is a base class that doesn't care about the stream source, which is left to the derived class. SFML provides a built-in specialization for big files (see SF::Music ). No network stream source is provided, but you can write your own by combining this class with the network module. A derived class has to override two virtual functions: on_get_data fills a new chunk of audio data to be played on_seek changes the current playing position in the source It is important to note that each SoundStream is played in its own separate thread, so that the streaming loop doesn't block the rest of the program. In particular, the OnGetData and OnSeek virtual functions may sometimes be called from this separate thread. It is important to keep this in mind, because you may have to take care of synchronization issues if you share data between threads. Usage example: class CustomStream < SF :: SoundStream def initialize ( location : String ) # Open the source and get audio settings ... # Initialize the stream -- important! super ( channel_count , sample_rate ) end def on_get_data () # Return a slice with audio data from the stream source # (note: must not be empty if you want to continue playing) Slice . new ( samples . to_unsafe , samples . size ) end def on_seek ( time_offset ) # Change the current position in the stream source end end # Usage stream = CustomStream . new ( \"path/to/stream\" ) stream . play () See also: SF::Music Direct known subclasses # SF::Music Constants # NoLoop # \"Invalid\" end_seeks value, telling us to continue uninterrupted Class methods # .new ( channel_count : Int , sample_rate : Int ) # Define the audio stream parameters This function must be called by derived classes as soon as they know the audio settings of the stream to play. Any attempt to manipulate the stream (play(), ...) before calling this function will fail. It can be called multiple times if the settings of the audio stream change, but only when the stream is stopped. channel_count - Number of channels of the stream sample_rate - Sample rate, in samples per second [ View source ] Methods # #channel_count : Int32 # Return the number of channels of the stream 1 channel means a mono sound, 2 means stereo, etc. Returns: Number of channels [ View source ] #finalize # Destructor [ View source ] #loop : Bool # Tell whether or not the stream is in loop mode Returns: True if the stream is looping, false otherwise See also: loop= [ View source ] #loop= ( loop : Bool ) # Set whether or not the stream should loop after reaching the end If set, the stream will restart from beginning after reaching the end and so on, until it is stopped or loop=(false) is called. The default looping state for streams is false. loop - True to play in loop, false to play once See also: loop [ View source ] abstract #on_get_data : Slice ( Int16 )? # Request a new chunk of audio samples from the stream source This function must be overridden by derived classes to provide the audio samples to play. It is called continuously by the streaming loop, in a separate thread. The source can choose to stop the streaming loop at any time, by returning false to the caller. If you return true (i.e. continue streaming) it is important that the returned array of samples is not empty; this would stop the stream due to an internal limitation. data - Chunk of data to fill Returns: True to continue playback, false to stop [ View source ] #on_loop : Int64 # Change the current playing position in the stream source to the beginning of the loop This function can be overridden by derived classes to allow implementation of custom loop points. Otherwise, it just calls on_seek(Time::Zero) and returns 0. Returns: The seek position after looping (or -1 if there's no loop) [ View source ] abstract #on_seek ( time_offset : Time ) # Change the current playing position in the stream source This function must be overridden by derived classes to allow random seeking into the stream source. time_offset - New playing position, relative to the beginning of the stream [ View source ] #pause # Pause the audio stream This function pauses the stream if it was playing, otherwise (stream already paused or stopped) it has no effect. See also: play , stop [ View source ] #play # Start or resume playing the audio stream This function starts the stream if it was stopped, resumes it if it was paused, and restarts it from the beginning if it was already playing. This function uses its own thread so that it doesn't block the rest of the program while the stream is played. See also: pause , stop [ View source ] #playing_offset : Time # Get the current playing position of the stream Returns: Current playing position, from the beginning of the stream See also: playing_offset= [ View source ] #playing_offset= ( time_offset : Time ) # Change the current playing position of the stream The playing position can be changed when the stream is either paused or playing. Changing the playing position when the stream is stopped has no effect, since playing the stream would reset its position. time_offset - New playing position, from the beginning of the stream See also: playing_offset [ View source ] #sample_rate : Int32 # Get the stream sample rate of the stream The sample rate is the number of audio samples played per second. The higher, the better the quality. Returns: Sample rate, in number of samples per second [ View source ] #status : SoundSource :: Status # Get the current status of the stream (stopped, paused, playing) Returns: Current status [ View source ] #stop # Stop playing the audio stream This function stops the stream if it was playing or paused, and does nothing if it was already stopped. It also resets the playing position (unlike pause() ). See also: play , pause [ View source ]","title":"SoundStream"},{"location":"api/SF/SoundStream.html#SF::SoundStream","text":"Abstract base class for streamed audio sources Unlike audio buffers (see SF::SoundBuffer ), audio streams are never completely loaded in memory. Instead, the audio data is acquired continuously while the stream is playing. This behavior allows to play a sound with no loading delay, and keeps the memory consumption very low. Sound sources that need to be streamed are usually big files (compressed audio musics that would eat hundreds of MB in memory) or files that would take a lot of time to be received (sounds played over the network). SF::SoundStream is a base class that doesn't care about the stream source, which is left to the derived class. SFML provides a built-in specialization for big files (see SF::Music ). No network stream source is provided, but you can write your own by combining this class with the network module. A derived class has to override two virtual functions: on_get_data fills a new chunk of audio data to be played on_seek changes the current playing position in the source It is important to note that each SoundStream is played in its own separate thread, so that the streaming loop doesn't block the rest of the program. In particular, the OnGetData and OnSeek virtual functions may sometimes be called from this separate thread. It is important to keep this in mind, because you may have to take care of synchronization issues if you share data between threads. Usage example: class CustomStream < SF :: SoundStream def initialize ( location : String ) # Open the source and get audio settings ... # Initialize the stream -- important! super ( channel_count , sample_rate ) end def on_get_data () # Return a slice with audio data from the stream source # (note: must not be empty if you want to continue playing) Slice . new ( samples . to_unsafe , samples . size ) end def on_seek ( time_offset ) # Change the current position in the stream source end end # Usage stream = CustomStream . new ( \"path/to/stream\" ) stream . play () See also: SF::Music","title":"SoundStream"},{"location":"api/SF/SoundStream.html#direct-known-subclasses","text":"SF::Music","title":"Direct known subclasses"},{"location":"api/SF/SoundStream.html#constants","text":"","title":"Constants"},{"location":"api/SF/SoundStream.html#SF::SoundStream::NoLoop","text":"\"Invalid\" end_seeks value, telling us to continue uninterrupted","title":"NoLoop"},{"location":"api/SF/SoundStream.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/SoundStream.html#SF::SoundStream.new(channel_count,sample_rate)","text":"Define the audio stream parameters This function must be called by derived classes as soon as they know the audio settings of the stream to play. Any attempt to manipulate the stream (play(), ...) before calling this function will fail. It can be called multiple times if the settings of the audio stream change, but only when the stream is stopped. channel_count - Number of channels of the stream sample_rate - Sample rate, in samples per second [ View source ]","title":".new"},{"location":"api/SF/SoundStream.html#methods","text":"","title":"Methods"},{"location":"api/SF/SoundStream.html#SF::SoundStream#channel_count()","text":"Return the number of channels of the stream 1 channel means a mono sound, 2 means stereo, etc. Returns: Number of channels [ View source ]","title":"#channel_count"},{"location":"api/SF/SoundStream.html#SF::SoundStream#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/SoundStream.html#SF::SoundStream#loop()","text":"Tell whether or not the stream is in loop mode Returns: True if the stream is looping, false otherwise See also: loop= [ View source ]","title":"#loop"},{"location":"api/SF/SoundStream.html#SF::SoundStream#loop=(loop)","text":"Set whether or not the stream should loop after reaching the end If set, the stream will restart from beginning after reaching the end and so on, until it is stopped or loop=(false) is called. The default looping state for streams is false. loop - True to play in loop, false to play once See also: loop [ View source ]","title":"#loop="},{"location":"api/SF/SoundStream.html#SF::SoundStream#on_get_data()","text":"Request a new chunk of audio samples from the stream source This function must be overridden by derived classes to provide the audio samples to play. It is called continuously by the streaming loop, in a separate thread. The source can choose to stop the streaming loop at any time, by returning false to the caller. If you return true (i.e. continue streaming) it is important that the returned array of samples is not empty; this would stop the stream due to an internal limitation. data - Chunk of data to fill Returns: True to continue playback, false to stop [ View source ]","title":"#on_get_data"},{"location":"api/SF/SoundStream.html#SF::SoundStream#on_loop()","text":"Change the current playing position in the stream source to the beginning of the loop This function can be overridden by derived classes to allow implementation of custom loop points. Otherwise, it just calls on_seek(Time::Zero) and returns 0. Returns: The seek position after looping (or -1 if there's no loop) [ View source ]","title":"#on_loop"},{"location":"api/SF/SoundStream.html#SF::SoundStream#on_seek(time_offset)","text":"Change the current playing position in the stream source This function must be overridden by derived classes to allow random seeking into the stream source. time_offset - New playing position, relative to the beginning of the stream [ View source ]","title":"#on_seek"},{"location":"api/SF/SoundStream.html#SF::SoundStream#pause()","text":"Pause the audio stream This function pauses the stream if it was playing, otherwise (stream already paused or stopped) it has no effect. See also: play , stop [ View source ]","title":"#pause"},{"location":"api/SF/SoundStream.html#SF::SoundStream#play()","text":"Start or resume playing the audio stream This function starts the stream if it was stopped, resumes it if it was paused, and restarts it from the beginning if it was already playing. This function uses its own thread so that it doesn't block the rest of the program while the stream is played. See also: pause , stop [ View source ]","title":"#play"},{"location":"api/SF/SoundStream.html#SF::SoundStream#playing_offset()","text":"Get the current playing position of the stream Returns: Current playing position, from the beginning of the stream See also: playing_offset= [ View source ]","title":"#playing_offset"},{"location":"api/SF/SoundStream.html#SF::SoundStream#playing_offset=(time_offset)","text":"Change the current playing position of the stream The playing position can be changed when the stream is either paused or playing. Changing the playing position when the stream is stopped has no effect, since playing the stream would reset its position. time_offset - New playing position, from the beginning of the stream See also: playing_offset [ View source ]","title":"#playing_offset="},{"location":"api/SF/SoundStream.html#SF::SoundStream#sample_rate()","text":"Get the stream sample rate of the stream The sample rate is the number of audio samples played per second. The higher, the better the quality. Returns: Sample rate, in number of samples per second [ View source ]","title":"#sample_rate"},{"location":"api/SF/SoundStream.html#SF::SoundStream#status()","text":"Get the current status of the stream (stopped, paused, playing) Returns: Current status [ View source ]","title":"#status"},{"location":"api/SF/SoundStream.html#SF::SoundStream#stop()","text":"Stop playing the audio stream This function stops the stream if it was playing or paused, and does nothing if it was already stopped. It also resets the playing position (unlike pause() ). See also: play , pause [ View source ]","title":"#stop"},{"location":"api/SF/Sprite.html","text":"class SF::Sprite inherits SF::Transformable # Drawable representation of a texture, with its own transformations, color, etc. SF::Sprite is a drawable class that allows to easily display a texture (or a part of it) on a render target. It inherits all the functions from SF::Transformable : position, rotation, scale, origin. It also adds sprite-specific properties such as the texture to use, the part of it to display, and some convenience functions to change the overall color of the sprite, or to get its bounding rectangle. SF::Sprite works in combination with the SF::Texture class, which loads and provides the pixel data of a given texture. The separation of SF::Sprite and SF::Texture allows more flexibility and better performances: indeed a SF::Texture is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a SF::Sprite is a lightweight object which can use the pixel data of a SF::Texture and draw it with its own transformation/color/blending attributes. It is important to note that the SF::Sprite instance doesn't copy the texture that it uses, it only keeps a reference to it. Thus, a SF::Texture must not be destroyed while it is used by a SF::Sprite (i.e. never write a function that uses a local SF::Texture instance for creating a sprite). See also the note on coordinates and undistorted rendering in SF::Transformable . Usage example: # Declare and load a texture texture = SF :: Texture . from_file ( \"texture.png\" ) # Create a sprite sprite = SF :: Sprite . new sprite . texture = texture sprite . texture_rect = SF . int_rect ( 10 , 10 , 50 , 30 ) sprite . color = SF . color ( 255 , 255 , 255 , 200 ) sprite . position = { 100 , 25 } # Draw it window . draw sprite See also: SF::Texture , SF::Transformable Included modules # SF::Drawable Class methods # .new ( texture : Texture , rectangle : IntRect ) # Construct the sprite from a sub-rectangle of a source texture texture - Source texture rectangle - Sub-rectangle of the texture to assign to the sprite See also: texture= , texture_rect= [ View source ] .new ( texture : Texture ) # Construct the sprite from a source texture texture - Source texture See also: texture= [ View source ] .new # Default constructor Creates an empty sprite with no source texture. [ View source ] Methods # #color : Color # Get the global color of the sprite Returns: Global color of the sprite See also: color= [ View source ] #color= ( color : Color ) # Set the global color of the sprite This color is modulated (multiplied) with the sprite's texture. It can be used to colorize the sprite, or change its global opacity. By default, the sprite's color is opaque white. color - New color of the sprite See also: color [ View source ] #dup : Sprite # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Virtual destructor [ View source ] #global_bounds : FloatRect # Get the global bounding rectangle of the entity The returned rectangle is in global coordinates, which means that it takes into account the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the sprite in the global 2D world's coordinate system. Returns: Global bounding rectangle of the entity [ View source ] #local_bounds : FloatRect # Get the local bounding rectangle of the entity The returned rectangle is in local coordinates, which means that it ignores the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the entity in the entity's coordinate system. Returns: Local bounding rectangle of the entity [ View source ] #set_texture ( texture : Texture , reset_rect : Bool = false ) # Change the source texture of the sprite The texture argument refers to a texture that must exist as long as the sprite uses it. Indeed, the sprite doesn't store its own copy of the texture, but rather keeps a pointer to the one that you passed to this function. If the source texture is destroyed and the sprite tries to use it, the behavior is undefined. If reset_rect is true, the TextureRect property of the sprite is automatically adjusted to the size of the new texture. If it is false, the texture rect is left unchanged. texture - New texture reset_rect - Should the texture rect be reset to the size of the new texture? See also: texture , texture_rect= [ View source ] #texture= ( texture : Texture ) # Shorthand for #set_texture [ View source ] #texture_rect : IntRect # Get the sub-rectangle of the texture displayed by the sprite Returns: Texture rectangle of the sprite See also: texture_rect= [ View source ] #texture_rect= ( rectangle : IntRect ) # Set the sub-rectangle of the texture that the sprite will display The texture rect is useful when you don't want to display the whole texture, but rather a part of it. By default, the texture rect covers the entire texture. rectangle - Rectangle defining the region of the texture to display See also: texture_rect , texture= [ View source ]","title":"Sprite"},{"location":"api/SF/Sprite.html#SF::Sprite","text":"Drawable representation of a texture, with its own transformations, color, etc. SF::Sprite is a drawable class that allows to easily display a texture (or a part of it) on a render target. It inherits all the functions from SF::Transformable : position, rotation, scale, origin. It also adds sprite-specific properties such as the texture to use, the part of it to display, and some convenience functions to change the overall color of the sprite, or to get its bounding rectangle. SF::Sprite works in combination with the SF::Texture class, which loads and provides the pixel data of a given texture. The separation of SF::Sprite and SF::Texture allows more flexibility and better performances: indeed a SF::Texture is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a SF::Sprite is a lightweight object which can use the pixel data of a SF::Texture and draw it with its own transformation/color/blending attributes. It is important to note that the SF::Sprite instance doesn't copy the texture that it uses, it only keeps a reference to it. Thus, a SF::Texture must not be destroyed while it is used by a SF::Sprite (i.e. never write a function that uses a local SF::Texture instance for creating a sprite). See also the note on coordinates and undistorted rendering in SF::Transformable . Usage example: # Declare and load a texture texture = SF :: Texture . from_file ( \"texture.png\" ) # Create a sprite sprite = SF :: Sprite . new sprite . texture = texture sprite . texture_rect = SF . int_rect ( 10 , 10 , 50 , 30 ) sprite . color = SF . color ( 255 , 255 , 255 , 200 ) sprite . position = { 100 , 25 } # Draw it window . draw sprite See also: SF::Texture , SF::Transformable","title":"Sprite"},{"location":"api/SF/Sprite.html#included-modules","text":"SF::Drawable","title":"Included modules"},{"location":"api/SF/Sprite.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Sprite.html#SF::Sprite.new(texture,rectangle)","text":"Construct the sprite from a sub-rectangle of a source texture texture - Source texture rectangle - Sub-rectangle of the texture to assign to the sprite See also: texture= , texture_rect= [ View source ]","title":".new"},{"location":"api/SF/Sprite.html#methods","text":"","title":"Methods"},{"location":"api/SF/Sprite.html#SF::Sprite#color()","text":"Get the global color of the sprite Returns: Global color of the sprite See also: color= [ View source ]","title":"#color"},{"location":"api/SF/Sprite.html#SF::Sprite#color=(color)","text":"Set the global color of the sprite This color is modulated (multiplied) with the sprite's texture. It can be used to colorize the sprite, or change its global opacity. By default, the sprite's color is opaque white. color - New color of the sprite See also: color [ View source ]","title":"#color="},{"location":"api/SF/Sprite.html#SF::Sprite#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Sprite.html#SF::Sprite#finalize()","text":"Virtual destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Sprite.html#SF::Sprite#global_bounds()","text":"Get the global bounding rectangle of the entity The returned rectangle is in global coordinates, which means that it takes into account the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the sprite in the global 2D world's coordinate system. Returns: Global bounding rectangle of the entity [ View source ]","title":"#global_bounds"},{"location":"api/SF/Sprite.html#SF::Sprite#local_bounds()","text":"Get the local bounding rectangle of the entity The returned rectangle is in local coordinates, which means that it ignores the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the entity in the entity's coordinate system. Returns: Local bounding rectangle of the entity [ View source ]","title":"#local_bounds"},{"location":"api/SF/Sprite.html#SF::Sprite#set_texture(texture,reset_rect)","text":"Change the source texture of the sprite The texture argument refers to a texture that must exist as long as the sprite uses it. Indeed, the sprite doesn't store its own copy of the texture, but rather keeps a pointer to the one that you passed to this function. If the source texture is destroyed and the sprite tries to use it, the behavior is undefined. If reset_rect is true, the TextureRect property of the sprite is automatically adjusted to the size of the new texture. If it is false, the texture rect is left unchanged. texture - New texture reset_rect - Should the texture rect be reset to the size of the new texture? See also: texture , texture_rect= [ View source ]","title":"#set_texture"},{"location":"api/SF/Sprite.html#SF::Sprite#texture=(texture)","text":"Shorthand for #set_texture [ View source ]","title":"#texture="},{"location":"api/SF/Sprite.html#SF::Sprite#texture_rect()","text":"Get the sub-rectangle of the texture displayed by the sprite Returns: Texture rectangle of the sprite See also: texture_rect= [ View source ]","title":"#texture_rect"},{"location":"api/SF/Sprite.html#SF::Sprite#texture_rect=(rectangle)","text":"Set the sub-rectangle of the texture that the sprite will display The texture rect is useful when you don't want to display the whole texture, but rather a part of it. By default, the texture rect covers the entire texture. rectangle - Rectangle defining the region of the texture to display See also: texture_rect , texture= [ View source ]","title":"#texture_rect="},{"location":"api/SF/Style.html","text":"enum SF::Style # Enumeration of the window styles Members # Titlebar # Title bar + fixed border Resize # Title bar + resizable border + maximize button Close # Title bar + close button Fullscreen # Fullscreen mode (this flag and all others are mutually exclusive) Default # Default window style Methods # #close? # [ View source ] #default? # [ View source ] #fullscreen? # [ View source ] #none? # [ View source ] #resize? # [ View source ] #titlebar? # [ View source ]","title":"Style"},{"location":"api/SF/Style.html#SF::Style","text":"Enumeration of the window styles","title":"Style"},{"location":"api/SF/Style.html#members","text":"","title":"Members"},{"location":"api/SF/Style.html#SF::Style::Titlebar","text":"Title bar + fixed border","title":"Titlebar"},{"location":"api/SF/Style.html#SF::Style::Resize","text":"Title bar + resizable border + maximize button","title":"Resize"},{"location":"api/SF/Style.html#SF::Style::Close","text":"Title bar + close button","title":"Close"},{"location":"api/SF/Style.html#SF::Style::Fullscreen","text":"Fullscreen mode (this flag and all others are mutually exclusive)","title":"Fullscreen"},{"location":"api/SF/Style.html#SF::Style::Default","text":"Default window style","title":"Default"},{"location":"api/SF/Style.html#methods","text":"","title":"Methods"},{"location":"api/SF/Style.html#SF::Style#close?()","text":"[ View source ]","title":"#close?"},{"location":"api/SF/Style.html#SF::Style#default?()","text":"[ View source ]","title":"#default?"},{"location":"api/SF/Style.html#SF::Style#fullscreen?()","text":"[ View source ]","title":"#fullscreen?"},{"location":"api/SF/Style.html#SF::Style#none?()","text":"[ View source ]","title":"#none?"},{"location":"api/SF/Style.html#SF::Style#resize?()","text":"[ View source ]","title":"#resize?"},{"location":"api/SF/Style.html#SF::Style#titlebar?()","text":"[ View source ]","title":"#titlebar?"},{"location":"api/SF/TcpListener.html","text":"class SF::TcpListener inherits SF::Socket # Socket that listens to new TCP connections A listener socket is a special type of socket that listens to a given port and waits for connections on that port. This is all it can do. When a new connection is received, you must call accept and the listener returns a new instance of SF::TcpSocket that is properly initialized and can be used to communicate with the new client. Listener sockets are specific to the TCP protocol, UDP sockets are connectionless and can therefore communicate directly. As a consequence, a listener socket will always return the new connections as SF::TcpSocket instances. A listener is automatically closed on destruction, like all other types of socket. However if you want to stop listening before the socket is destroyed, you can call its close() function. Usage example: # Create a listener socket and make it wait for new # connections on port 55001 listener = SF :: TcpListener . new listener . listen ( 55001 ) # Endless loop that waits for new connections while running client = SF :: TcpSocket . new if listener . accept ( client ) == SF :: Socket :: Done # A new client just connected! puts \"New connection received from #{ client . remote_address } \" do_something_with client end end See also: SF::TcpSocket , SF::Socket Class methods # .new # Default constructor [ View source ] Methods # #accept ( socket : TcpSocket ) : Socket :: Status # Accept a new connection If the socket is in blocking mode, this function will not return until a connection is actually received. socket - Socket that will hold the new connection Returns: Status code See also: listen [ View source ] #close # Stop listening and close the socket This function gracefully stops the listener. If the socket is not listening, this function has no effect. See also: listen [ View source ] #finalize # Destructor [ View source ] #listen ( port : Int , address : IpAddress = IpAddress :: Any ) : Socket :: Status # Start listening for incoming connection attempts This function makes the socket start listening on the specified port, waiting for incoming connection attempts. If the socket is already listening on a port when this function is called, it will stop listening on the old port before starting to listen on the new port. port - Port to listen on for incoming connection attempts address - Address of the interface to listen on Returns: Status code See also: accept , close [ View source ] #local_port : UInt16 # Get the port to which the socket is bound locally If the socket is not listening to a port, this function returns 0. Returns: Port to which the socket is bound See also: listen [ View source ]","title":"TcpListener"},{"location":"api/SF/TcpListener.html#SF::TcpListener","text":"Socket that listens to new TCP connections A listener socket is a special type of socket that listens to a given port and waits for connections on that port. This is all it can do. When a new connection is received, you must call accept and the listener returns a new instance of SF::TcpSocket that is properly initialized and can be used to communicate with the new client. Listener sockets are specific to the TCP protocol, UDP sockets are connectionless and can therefore communicate directly. As a consequence, a listener socket will always return the new connections as SF::TcpSocket instances. A listener is automatically closed on destruction, like all other types of socket. However if you want to stop listening before the socket is destroyed, you can call its close() function. Usage example: # Create a listener socket and make it wait for new # connections on port 55001 listener = SF :: TcpListener . new listener . listen ( 55001 ) # Endless loop that waits for new connections while running client = SF :: TcpSocket . new if listener . accept ( client ) == SF :: Socket :: Done # A new client just connected! puts \"New connection received from #{ client . remote_address } \" do_something_with client end end See also: SF::TcpSocket , SF::Socket","title":"TcpListener"},{"location":"api/SF/TcpListener.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/TcpListener.html#SF::TcpListener.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/TcpListener.html#methods","text":"","title":"Methods"},{"location":"api/SF/TcpListener.html#SF::TcpListener#accept(socket)","text":"Accept a new connection If the socket is in blocking mode, this function will not return until a connection is actually received. socket - Socket that will hold the new connection Returns: Status code See also: listen [ View source ]","title":"#accept"},{"location":"api/SF/TcpListener.html#SF::TcpListener#close()","text":"Stop listening and close the socket This function gracefully stops the listener. If the socket is not listening, this function has no effect. See also: listen [ View source ]","title":"#close"},{"location":"api/SF/TcpListener.html#SF::TcpListener#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/TcpListener.html#SF::TcpListener#listen(port,address)","text":"Start listening for incoming connection attempts This function makes the socket start listening on the specified port, waiting for incoming connection attempts. If the socket is already listening on a port when this function is called, it will stop listening on the old port before starting to listen on the new port. port - Port to listen on for incoming connection attempts address - Address of the interface to listen on Returns: Status code See also: accept , close [ View source ]","title":"#listen"},{"location":"api/SF/TcpListener.html#SF::TcpListener#local_port()","text":"Get the port to which the socket is bound locally If the socket is not listening to a port, this function returns 0. Returns: Port to which the socket is bound See also: listen [ View source ]","title":"#local_port"},{"location":"api/SF/TcpSocket.html","text":"class SF::TcpSocket inherits SF::Socket # Specialized socket using the TCP protocol TCP is a connected protocol, which means that a TCP socket can only communicate with the host it is connected to. It can't send or receive anything if it is not connected. The TCP protocol is reliable but adds a slight overhead. It ensures that your data will always be received in order and without errors (no data corrupted, lost or duplicated). When a socket is connected to a remote host, you can retrieve informations about this host with the remote_address and remote_port functions. You can also get the local port to which the socket is bound (which is automatically chosen when the socket is connected), with the local_port function. Sending and receiving data can use either the low-level or the high-level functions. The low-level functions process a raw sequence of bytes, and cannot ensure that one call to Send will exactly match one call to Receive at the other end of the socket. The high-level interface uses packets (see SF::Packet ), which are easier to use and provide more safety regarding the data that is exchanged. You can look at the SF::Packet class to get more details about how they work. The socket is automatically disconnected when it is destroyed, but if you want to explicitly close the connection while the socket instance is still alive, you can call disconnect. Usage example: # ----- The client ----- # Create a socket and connect it to 192.168.1.50 on port 55001 socket = SF :: TcpSocket . new socket . connect ( \"192.168.1.50\" , 55001 ) # Send a message to the connected host message = \"Hi, I am a client\" socket . send ( message . to_slice ) # Receive an answer from the server buffer = Slice ( UInt8 ) . new ( 1024 ) status , received = socket . receive ( buffer ) puts \"The server said: #{ buffer } \" # ----- The server ----- # Create a listener to wait for incoming connections on port 55001 listener = SF :: TcpListener . new listener . listen ( 55001 ) # Wait for a connection socket = SF :: TcpSocket . new listener . accept ( socket ) puts \"New client connected: #{ socket . remote_address } \" # Receive a message from the client buffer = Slice ( UInt8 ) . new ( 1024 ) status , received = socket . receive ( buffer ) puts \"The client said: #{ buffer } \" # Send an answer message = \"Welcome, client\" socket . send ( message . to_slice ) See also: SF::Socket , SF::UdpSocket , SF::Packet Class methods # .new # Default constructor [ View source ] Methods # #connect ( remote_address : IpAddress , remote_port : Int , timeout : Time = Time :: Zero ) : Socket :: Status # Connect the socket to a remote peer In blocking mode, this function may take a while, especially if the remote peer is not reachable. The last parameter allows you to stop trying to connect after a given timeout. If the socket is already connected, the connection is forcibly disconnected before attempting to connect again. remote_address - Address of the remote peer remote_port - Port of the remote peer timeout - Optional maximum time to wait Returns: Status code See also: disconnect [ View source ] #disconnect # Disconnect the socket from its remote peer This function gracefully closes the connection. If the socket is not connected, this function has no effect. See also: connect [ View source ] #finalize # Destructor [ View source ] #local_port : UInt16 # Get the port to which the socket is bound locally If the socket is not connected, this function returns 0. Returns: Port to which the socket is bound See also: connect , remote_port [ View source ] #receive ( data : Slice ) : Tuple ( Socket :: Status , Int32 ) # Receive raw data from the remote peer In blocking mode, this function will wait until some bytes are actually received. This function will fail if the socket is not connected. data - The slice to fill with the received bytes Returns: Status code The actual number of bytes received See also: send [ View source ] #receive ( packet : Packet ) : Socket :: Status # Receive a formatted packet of data from the remote peer In blocking mode, this function will wait until the whole packet has been received. This function will fail if the socket is not connected. packet - Packet to fill with the received data Returns: Status code See also: send [ View source ] #remote_address : IpAddress # Get the address of the connected peer It the socket is not connected, this function returns SF::IpAddress::None . Returns: Address of the remote peer See also: remote_port [ View source ] #remote_port : UInt16 # Get the port of the connected peer to which the socket is connected If the socket is not connected, this function returns 0. Returns: Remote port to which the socket is connected See also: remote_address [ View source ] #send ( data : Slice ) : Tuple ( Socket :: Status , Int32 ) # Send raw data to the remote peer This function will fail if the socket is not connected. data - Slice containing the bytes to send Returns: Status code The number of bytes sent See also: receive [ View source ] #send ( packet : Packet ) : Socket :: Status # Send a formatted packet of data to the remote peer In non-blocking mode, if this function returns SF::Socket::Partial , you must retry sending the same unmodified packet before sending anything else in order to guarantee the packet arrives at the remote peer uncorrupted. This function will fail if the socket is not connected. packet - Packet to send Returns: Status code See also: receive [ View source ]","title":"TcpSocket"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket","text":"Specialized socket using the TCP protocol TCP is a connected protocol, which means that a TCP socket can only communicate with the host it is connected to. It can't send or receive anything if it is not connected. The TCP protocol is reliable but adds a slight overhead. It ensures that your data will always be received in order and without errors (no data corrupted, lost or duplicated). When a socket is connected to a remote host, you can retrieve informations about this host with the remote_address and remote_port functions. You can also get the local port to which the socket is bound (which is automatically chosen when the socket is connected), with the local_port function. Sending and receiving data can use either the low-level or the high-level functions. The low-level functions process a raw sequence of bytes, and cannot ensure that one call to Send will exactly match one call to Receive at the other end of the socket. The high-level interface uses packets (see SF::Packet ), which are easier to use and provide more safety regarding the data that is exchanged. You can look at the SF::Packet class to get more details about how they work. The socket is automatically disconnected when it is destroyed, but if you want to explicitly close the connection while the socket instance is still alive, you can call disconnect. Usage example: # ----- The client ----- # Create a socket and connect it to 192.168.1.50 on port 55001 socket = SF :: TcpSocket . new socket . connect ( \"192.168.1.50\" , 55001 ) # Send a message to the connected host message = \"Hi, I am a client\" socket . send ( message . to_slice ) # Receive an answer from the server buffer = Slice ( UInt8 ) . new ( 1024 ) status , received = socket . receive ( buffer ) puts \"The server said: #{ buffer } \" # ----- The server ----- # Create a listener to wait for incoming connections on port 55001 listener = SF :: TcpListener . new listener . listen ( 55001 ) # Wait for a connection socket = SF :: TcpSocket . new listener . accept ( socket ) puts \"New client connected: #{ socket . remote_address } \" # Receive a message from the client buffer = Slice ( UInt8 ) . new ( 1024 ) status , received = socket . receive ( buffer ) puts \"The client said: #{ buffer } \" # Send an answer message = \"Welcome, client\" socket . send ( message . to_slice ) See also: SF::Socket , SF::UdpSocket , SF::Packet","title":"TcpSocket"},{"location":"api/SF/TcpSocket.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/TcpSocket.html#methods","text":"","title":"Methods"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket#connect(remote_address,remote_port,timeout)","text":"Connect the socket to a remote peer In blocking mode, this function may take a while, especially if the remote peer is not reachable. The last parameter allows you to stop trying to connect after a given timeout. If the socket is already connected, the connection is forcibly disconnected before attempting to connect again. remote_address - Address of the remote peer remote_port - Port of the remote peer timeout - Optional maximum time to wait Returns: Status code See also: disconnect [ View source ]","title":"#connect"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket#disconnect()","text":"Disconnect the socket from its remote peer This function gracefully closes the connection. If the socket is not connected, this function has no effect. See also: connect [ View source ]","title":"#disconnect"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket#local_port()","text":"Get the port to which the socket is bound locally If the socket is not connected, this function returns 0. Returns: Port to which the socket is bound See also: connect , remote_port [ View source ]","title":"#local_port"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket#receive(data)","text":"Receive raw data from the remote peer In blocking mode, this function will wait until some bytes are actually received. This function will fail if the socket is not connected. data - The slice to fill with the received bytes Returns: Status code The actual number of bytes received See also: send [ View source ]","title":"#receive"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket#remote_address()","text":"Get the address of the connected peer It the socket is not connected, this function returns SF::IpAddress::None . Returns: Address of the remote peer See also: remote_port [ View source ]","title":"#remote_address"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket#remote_port()","text":"Get the port of the connected peer to which the socket is connected If the socket is not connected, this function returns 0. Returns: Remote port to which the socket is connected See also: remote_address [ View source ]","title":"#remote_port"},{"location":"api/SF/TcpSocket.html#SF::TcpSocket#send(data)","text":"Send raw data to the remote peer This function will fail if the socket is not connected. data - Slice containing the bytes to send Returns: Status code The number of bytes sent See also: receive [ View source ]","title":"#send"},{"location":"api/SF/Text.html","text":"class SF::Text inherits SF::Transformable # Graphical text that can be drawn to a render target SF::Text is a drawable class that allows to easily display some text with custom style and color on a render target. It inherits all the functions from SF::Transformable : position, rotation, scale, origin. It also adds text-specific properties such as the font to use, the character size, the font style (bold, italic, underlined and strike through), the text color, the outline thickness, the outline color, the character spacing, the line spacing and the text to display of course. It also provides convenience functions to calculate the graphical size of the text, or to get the global position of a given character. SF::Text works in combination with the SF::Font class, which loads and provides the glyphs (visual characters) of a given font. The separation of SF::Font and SF::Text allows more flexibility and better performances: indeed a SF::Font is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a SF::Text is a lightweight object which can combine the glyphs data and metrics of a SF::Font to display any text on a render target. It is important to note that the SF::Text instance doesn't copy the font that it uses, it only keeps a reference to it. Thus, a SF::Font must not be destructed while it is used by a SF::Text (i.e. never write a function that uses a local SF::Font instance for creating a text). See also the note on coordinates and undistorted rendering in SF::Transformable . Usage example: # Declare and load a font font = SF :: Font . from_file ( \"arial.ttf\" ) # Create a text text = SF :: Text . new ( \"hello\" , font ) text . character_size = 30 text . style = SF :: Text :: Bold text . color = SF :: Color :: Red # Draw it window . draw text See also: SF::Font , SF::Transformable Included modules # SF::Drawable Class methods # .new ( string : String , font : Font , character_size : Int = 30 ) # Construct the text from a string, font and size Note that if the used font is a bitmap font, it is not scalable, thus not all requested sizes will be available to use. This needs to be taken into consideration when setting the character size. If you need to display text of a certain size, make sure the corresponding bitmap font that supports that size is used. string - Text assigned to the string font - Font used to draw the string character_size - Base size of characters, in pixels [ View source ] .new # Default constructor Creates an empty text. [ View source ] Methods # #character_size : Int32 # Get the character size Returns: Size of the characters, in pixels See also: character_size= [ View source ] #character_size= ( size : Int ) # Set the character size The default size is 30. Note that if the used font is a bitmap font, it is not scalable, thus not all requested sizes will be available to use. This needs to be taken into consideration when setting the character size. If you need to display text of a certain size, make sure the corresponding bitmap font that supports that size is used. size - New character size, in pixels See also: character_size [ View source ] #color : Color # Get the fill color of the text Returns: Fill color of the text See also: fill_color= DEPRECATED: There is now fill and outline colors instead of a single global color. Use fill_color() or outline_color() instead. [ View source ] #color= ( color : Color ) # Set the fill color of the text By default, the text's fill color is opaque white. Setting the fill color to a transparent color with an outline will cause the outline to be displayed in the fill area of the text. color - New fill color of the text See also: fill_color DEPRECATED: There is now fill and outline colors instead of a single global color. Use fill_color=() or outline_color=() instead. [ View source ] #dup : Text # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #fill_color : Color # Get the fill color of the text Returns: Fill color of the text See also: fill_color= [ View source ] #fill_color= ( color : Color ) # Set the fill color of the text By default, the text's fill color is opaque white. Setting the fill color to a transparent color with an outline will cause the outline to be displayed in the fill area of the text. color - New fill color of the text See also: fill_color [ View source ] #finalize # Virtual destructor [ View source ] #find_character_pos ( index : Int ) : Vector2f # Return the position of the index-th character This function computes the visual position of a character from its index in the string. The returned position is in global coordinates (translation, rotation, scale and origin are applied). If index is out of range, the position of the end of the string is returned. index - Index of the character Returns: Position of the character [ View source ] #font= ( font : Font ) # Set the text's font The font argument refers to a font that must exist as long as the text uses it. Indeed, the text doesn't store its own copy of the font, but rather keeps a pointer to the one that you passed to this function. If the font is destroyed and the text tries to use it, the behavior is undefined. font - New font See also: font [ View source ] #global_bounds : FloatRect # Get the global bounding rectangle of the entity The returned rectangle is in global coordinates, which means that it takes into account the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the text in the global 2D world's coordinate system. Returns: Global bounding rectangle of the entity [ View source ] #letter_spacing : Float32 # Get the size of the letter spacing factor Returns: Size of the letter spacing factor See also: letter_spacing= [ View source ] #letter_spacing= ( spacing_factor : Number ) # Set the letter spacing factor The default spacing between letters is defined by the font. This factor doesn't directly apply to the existing spacing between each character, it rather adds a fixed space between them which is calculated from the font metrics and the character size. Note that factors below 1 (including negative numbers) bring characters closer to each other. By default the letter spacing factor is 1. spacing_factor - New letter spacing factor See also: letter_spacing [ View source ] #line_spacing : Float32 # Get the size of the line spacing factor Returns: Size of the line spacing factor See also: line_spacing= [ View source ] #line_spacing= ( spacing_factor : Number ) # Set the line spacing factor The default spacing between lines is defined by the font. This method enables you to set a factor for the spacing between lines. By default the line spacing factor is 1. spacing_factor - New line spacing factor See also: line_spacing [ View source ] #local_bounds : FloatRect # Get the local bounding rectangle of the entity The returned rectangle is in local coordinates, which means that it ignores the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the entity in the entity's coordinate system. Returns: Local bounding rectangle of the entity [ View source ] #outline_color : Color # Get the outline color of the text Returns: Outline color of the text See also: outline_color= [ View source ] #outline_color= ( color : Color ) # Set the outline color of the text By default, the text's outline color is opaque black. color - New outline color of the text See also: outline_color [ View source ] #outline_thickness : Float32 # Get the outline thickness of the text Returns: Outline thickness of the text, in pixels See also: outline_thickness= [ View source ] #outline_thickness= ( thickness : Number ) # Set the thickness of the text's outline By default, the outline thickness is 0. Be aware that using a negative value for the outline thickness will cause distorted rendering. thickness - New outline thickness, in pixels See also: outline_thickness [ View source ] #string : String # Get the text's string Returns: Text's string See also: string= [ View source ] #string= ( string : String ) # Set the text's string A text's string is empty by default. string - New string See also: string [ View source ] #style : UInt32 # Get the text's style Returns: Text's style See also: style= [ View source ] #style= ( style : Text :: Style ) # Set the text's style You can pass a combination of one or more styles, for example SF::Text::Bold | SF::Text::Italic . The default style is SF::Text::Regular . style - New style See also: style [ View source ]","title":"Text"},{"location":"api/SF/Text.html#SF::Text","text":"Graphical text that can be drawn to a render target SF::Text is a drawable class that allows to easily display some text with custom style and color on a render target. It inherits all the functions from SF::Transformable : position, rotation, scale, origin. It also adds text-specific properties such as the font to use, the character size, the font style (bold, italic, underlined and strike through), the text color, the outline thickness, the outline color, the character spacing, the line spacing and the text to display of course. It also provides convenience functions to calculate the graphical size of the text, or to get the global position of a given character. SF::Text works in combination with the SF::Font class, which loads and provides the glyphs (visual characters) of a given font. The separation of SF::Font and SF::Text allows more flexibility and better performances: indeed a SF::Font is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a SF::Text is a lightweight object which can combine the glyphs data and metrics of a SF::Font to display any text on a render target. It is important to note that the SF::Text instance doesn't copy the font that it uses, it only keeps a reference to it. Thus, a SF::Font must not be destructed while it is used by a SF::Text (i.e. never write a function that uses a local SF::Font instance for creating a text). See also the note on coordinates and undistorted rendering in SF::Transformable . Usage example: # Declare and load a font font = SF :: Font . from_file ( \"arial.ttf\" ) # Create a text text = SF :: Text . new ( \"hello\" , font ) text . character_size = 30 text . style = SF :: Text :: Bold text . color = SF :: Color :: Red # Draw it window . draw text See also: SF::Font , SF::Transformable","title":"Text"},{"location":"api/SF/Text.html#included-modules","text":"SF::Drawable","title":"Included modules"},{"location":"api/SF/Text.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Text.html#SF::Text.new(string,font,character_size)","text":"Construct the text from a string, font and size Note that if the used font is a bitmap font, it is not scalable, thus not all requested sizes will be available to use. This needs to be taken into consideration when setting the character size. If you need to display text of a certain size, make sure the corresponding bitmap font that supports that size is used. string - Text assigned to the string font - Font used to draw the string character_size - Base size of characters, in pixels [ View source ]","title":".new"},{"location":"api/SF/Text.html#methods","text":"","title":"Methods"},{"location":"api/SF/Text.html#SF::Text#character_size()","text":"Get the character size Returns: Size of the characters, in pixels See also: character_size= [ View source ]","title":"#character_size"},{"location":"api/SF/Text.html#SF::Text#character_size=(size)","text":"Set the character size The default size is 30. Note that if the used font is a bitmap font, it is not scalable, thus not all requested sizes will be available to use. This needs to be taken into consideration when setting the character size. If you need to display text of a certain size, make sure the corresponding bitmap font that supports that size is used. size - New character size, in pixels See also: character_size [ View source ]","title":"#character_size="},{"location":"api/SF/Text.html#SF::Text#color()","text":"Get the fill color of the text Returns: Fill color of the text See also: fill_color= DEPRECATED: There is now fill and outline colors instead of a single global color. Use fill_color() or outline_color() instead. [ View source ]","title":"#color"},{"location":"api/SF/Text.html#SF::Text#color=(color)","text":"Set the fill color of the text By default, the text's fill color is opaque white. Setting the fill color to a transparent color with an outline will cause the outline to be displayed in the fill area of the text. color - New fill color of the text See also: fill_color DEPRECATED: There is now fill and outline colors instead of a single global color. Use fill_color=() or outline_color=() instead. [ View source ]","title":"#color="},{"location":"api/SF/Text.html#SF::Text#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Text.html#SF::Text#fill_color()","text":"Get the fill color of the text Returns: Fill color of the text See also: fill_color= [ View source ]","title":"#fill_color"},{"location":"api/SF/Text.html#SF::Text#fill_color=(color)","text":"Set the fill color of the text By default, the text's fill color is opaque white. Setting the fill color to a transparent color with an outline will cause the outline to be displayed in the fill area of the text. color - New fill color of the text See also: fill_color [ View source ]","title":"#fill_color="},{"location":"api/SF/Text.html#SF::Text#finalize()","text":"Virtual destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Text.html#SF::Text#find_character_pos(index)","text":"Return the position of the index-th character This function computes the visual position of a character from its index in the string. The returned position is in global coordinates (translation, rotation, scale and origin are applied). If index is out of range, the position of the end of the string is returned. index - Index of the character Returns: Position of the character [ View source ]","title":"#find_character_pos"},{"location":"api/SF/Text.html#SF::Text#font=(font)","text":"Set the text's font The font argument refers to a font that must exist as long as the text uses it. Indeed, the text doesn't store its own copy of the font, but rather keeps a pointer to the one that you passed to this function. If the font is destroyed and the text tries to use it, the behavior is undefined. font - New font See also: font [ View source ]","title":"#font="},{"location":"api/SF/Text.html#SF::Text#global_bounds()","text":"Get the global bounding rectangle of the entity The returned rectangle is in global coordinates, which means that it takes into account the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the text in the global 2D world's coordinate system. Returns: Global bounding rectangle of the entity [ View source ]","title":"#global_bounds"},{"location":"api/SF/Text.html#SF::Text#letter_spacing()","text":"Get the size of the letter spacing factor Returns: Size of the letter spacing factor See also: letter_spacing= [ View source ]","title":"#letter_spacing"},{"location":"api/SF/Text.html#SF::Text#letter_spacing=(spacing_factor)","text":"Set the letter spacing factor The default spacing between letters is defined by the font. This factor doesn't directly apply to the existing spacing between each character, it rather adds a fixed space between them which is calculated from the font metrics and the character size. Note that factors below 1 (including negative numbers) bring characters closer to each other. By default the letter spacing factor is 1. spacing_factor - New letter spacing factor See also: letter_spacing [ View source ]","title":"#letter_spacing="},{"location":"api/SF/Text.html#SF::Text#line_spacing()","text":"Get the size of the line spacing factor Returns: Size of the line spacing factor See also: line_spacing= [ View source ]","title":"#line_spacing"},{"location":"api/SF/Text.html#SF::Text#line_spacing=(spacing_factor)","text":"Set the line spacing factor The default spacing between lines is defined by the font. This method enables you to set a factor for the spacing between lines. By default the line spacing factor is 1. spacing_factor - New line spacing factor See also: line_spacing [ View source ]","title":"#line_spacing="},{"location":"api/SF/Text.html#SF::Text#local_bounds()","text":"Get the local bounding rectangle of the entity The returned rectangle is in local coordinates, which means that it ignores the transformations (translation, rotation, scale, ...) that are applied to the entity. In other words, this function returns the bounds of the entity in the entity's coordinate system. Returns: Local bounding rectangle of the entity [ View source ]","title":"#local_bounds"},{"location":"api/SF/Text.html#SF::Text#outline_color()","text":"Get the outline color of the text Returns: Outline color of the text See also: outline_color= [ View source ]","title":"#outline_color"},{"location":"api/SF/Text.html#SF::Text#outline_color=(color)","text":"Set the outline color of the text By default, the text's outline color is opaque black. color - New outline color of the text See also: outline_color [ View source ]","title":"#outline_color="},{"location":"api/SF/Text.html#SF::Text#outline_thickness()","text":"Get the outline thickness of the text Returns: Outline thickness of the text, in pixels See also: outline_thickness= [ View source ]","title":"#outline_thickness"},{"location":"api/SF/Text.html#SF::Text#outline_thickness=(thickness)","text":"Set the thickness of the text's outline By default, the outline thickness is 0. Be aware that using a negative value for the outline thickness will cause distorted rendering. thickness - New outline thickness, in pixels See also: outline_thickness [ View source ]","title":"#outline_thickness="},{"location":"api/SF/Text.html#SF::Text#string()","text":"Get the text's string Returns: Text's string See also: string= [ View source ]","title":"#string"},{"location":"api/SF/Text.html#SF::Text#string=(string)","text":"Set the text's string A text's string is empty by default. string - New string See also: string [ View source ]","title":"#string="},{"location":"api/SF/Text.html#SF::Text#style()","text":"Get the text's style Returns: Text's style See also: style= [ View source ]","title":"#style"},{"location":"api/SF/Text.html#SF::Text#style=(style)","text":"Set the text's style You can pass a combination of one or more styles, for example SF::Text::Bold | SF::Text::Italic . The default style is SF::Text::Regular . style - New style See also: style [ View source ]","title":"#style="},{"location":"api/SF/Texture.html","text":"class SF::Texture inherits Reference # Image living on the graphics card that can be used for drawing SF::Texture stores pixels that can be drawn, with a sprite for example. A texture lives in the graphics card memory, therefore it is very fast to draw a texture to a render target, or copy a render target to a texture (the graphics card can access both directly). Being stored in the graphics card memory has some drawbacks. A texture cannot be manipulated as freely as a SF::Image , you need to prepare the pixels first and then upload them to the texture in a single operation (see Texture.update). SF::Texture makes it easy to convert from/to SF::Image , but keep in mind that these calls require transfers between the graphics card and the central memory, therefore they are slow operations. A texture can be loaded from an image, but also directly from a file/memory/stream. The necessary shortcuts are defined so that you don't need an image first for the most common cases. However, if you want to perform some modifications on the pixels before creating the final texture, you can load your file to a SF::Image , do whatever you need with the pixels, and then call Texture.load_from_image. Since they live in the graphics card memory, the pixels of a texture cannot be accessed without a slow copy first. And they cannot be accessed individually. Therefore, if you need to read the texture's pixels (like for pixel-perfect collisions), it is recommended to store the collision information separately, for example in an array of booleans. Like SF::Image , SF::Texture can handle a unique internal representation of pixels, which is RGBA 32 bits. This means that a pixel must be composed of 8 bits red, green, blue and alpha channels -- just like a SF::Color . Usage example: # This example shows the most common use of SF::Texture: # drawing a sprite # Load a texture from a file texture = SF :: Texture . from_file ( \"texture.png\" ) # Assign it to a sprite sprite = SF :: Sprite . new ( texture ) # Draw the textured sprite window . draw sprite # This example shows another common use of SF::Texture: # streaming real-time data, like video frames # Create an empty texture texture = SF :: Texture . new ( 640 , 480 ) # Create a sprite that will display the texture sprite = SF :: Sprite . new ( texture ) loop do # the main loop ... # update the texture pixels = ( ... ) . to_unsafe # get a fresh chunk of pixels (the next frame of a movie, for example) texture . update ( pixels ) # draw it window . draw sprite ... end Like SF::Shader that can be used as a raw OpenGL shader, SF::Texture can also be used directly as a raw texture for custom OpenGL geometry. SF :: Texture . bind ( texture ) ... render OpenGL geometry ... SF :: Texture . bind ( nil ) See also: SF::Sprite , SF::Image , SF::RenderTexture Included modules # SF::GlResource Class methods # .bind ( texture : Texture? , coordinate_type : Texture :: CoordinateType = Normalized ) # Bind a texture for rendering This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix SF::Texture with OpenGL code. t1 = SF :: Texture . new t2 = SF :: Texture . new ... SF :: Texture . bind t1 # draw OpenGL stuff that use t1... SF :: Texture . bind t2 # draw OpenGL stuff that use t2... SF :: Texture . bind nil # draw OpenGL stuff that use no texture... The coordinate_type argument controls how texture coordinates will be interpreted. If Normalized (the default), they must be in range 0.0 .. 1.0 , which is the default way of handling texture coordinates with OpenGL. If Pixels, they must be given in pixels (range 0.0 .. size ). This mode is used internally by the graphics classes of SFML, it makes the definition of texture coordinates more intuitive for the high-level API, users don't need to compute normalized values. texture - Pointer to the texture to bind, can be null to use no texture coordinate_type - Type of texture coordinates to use [ View source ] .maximum_size : Int32 # Get the maximum texture size allowed This maximum size is defined by the graphics driver. You can expect a value of 512 pixels for low-end graphics card, and up to 8192 pixels or more for newer hardware. Returns: Maximum size allowed for textures, in pixels [ View source ] .from_file ( * args , ** kwargs ) : self # Shorthand for texture = Texture.new; texture.load_from_file(...); texture Raises InitError on failure [ View source ] .from_image ( * args , ** kwargs ) : self # Shorthand for texture = Texture.new; texture.load_from_image(...); texture Raises InitError on failure [ View source ] .from_memory ( * args , ** kwargs ) : self # Shorthand for texture = Texture.new; texture.load_from_memory(...); texture Raises InitError on failure [ View source ] .from_stream ( * args , ** kwargs ) : self # Shorthand for texture = Texture.new; texture.load_from_stream(...); texture Raises InitError on failure [ View source ] .new # Default constructor Creates an empty texture. [ View source ] .new ( * args , ** kwargs ) : self # Shorthand for texture = Texture.new; texture.create(...); texture Raises InitError on failure [ View source ] Methods # #copy_to_image : Image # Copy the texture pixels to an image This function performs a slow operation that downloads the texture's pixels from the graphics card and copies them to a new image, potentially applying transformations to pixels if necessary (texture may be padded or flipped). Returns: Image containing the texture's pixels See also: load_from_image [ View source ] #create ( width : Int , height : Int ) : Bool # Create the texture If this function fails, the texture is left unchanged. width - Width of the texture height - Height of the texture Returns: True if creation was successful [ View source ] #dup : Texture # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Destructor [ View source ] #generate_mipmap : Bool # Generate a mipmap using the current texture data Mipmaps are pre-computed chains of optimized textures. Each level of texture in a mipmap is generated by halving each of the previous level's dimensions. This is done until the final level has the size of 1x1. The textures generated in this process may make use of more advanced filters which might improve the visual quality of textures when they are applied to objects much smaller than they are. This is known as minification. Because fewer texels (texture elements) have to be sampled from when heavily minified, usage of mipmaps can also improve rendering performance in certain scenarios. Mipmap generation relies on the necessary OpenGL extension being available. If it is unavailable or generation fails due to another reason, this function will return false. Mipmap data is only valid from the time it is generated until the next time the base level image is modified, at which point this function will have to be called again to regenerate it. Returns: True if mipmap generation was successful, false if unsuccessful [ View source ] #load_from_file ( filename : String , area : IntRect = IntRect . new ) : Bool # Load the texture from a file on disk This function is a shortcut for the following code: image = SF :: Image . new image . load_from_file ( filename ) texture . load_from_image ( image , area ) The area argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the area rectangle crosses the bounds of the image, it is adjusted to fit the image size. The maximum size for a texture depends on the graphics driver and can be retrieved with the maximum_size function. If this function fails, the texture is left unchanged. filename - Path of the image file to load area - Area of the image to load Returns: True if loading was successful See also: load_from_memory , load_from_stream , load_from_image [ View source ] #load_from_image ( image : Image , area : IntRect = IntRect . new ) : Bool # Load the texture from an image The area argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the area rectangle crosses the bounds of the image, it is adjusted to fit the image size. The maximum size for a texture depends on the graphics driver and can be retrieved with the maximum_size function. If this function fails, the texture is left unchanged. image - Image to load into the texture area - Area of the image to load Returns: True if loading was successful See also: load_from_file , load_from_memory [ View source ] #load_from_memory ( data : Slice , area : IntRect = IntRect . new ) : Bool # Load the texture from a file in memory This function is a shortcut for the following code: image = SF :: Image . new image . load_from_memory ( data , size ) texture . load_from_image ( image , area ) The area argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the area rectangle crosses the bounds of the image, it is adjusted to fit the image size. The maximum size for a texture depends on the graphics driver and can be retrieved with the maximum_size function. If this function fails, the texture is left unchanged. data - Slice containing the file data in memory area - Area of the image to load Returns: True if loading was successful See also: load_from_file , load_from_stream , load_from_image [ View source ] #load_from_stream ( stream : InputStream , area : IntRect = IntRect . new ) : Bool # Load the texture from a custom stream This function is a shortcut for the following code: image = SF :: Image . new image . load_from_stream ( stream ) texture . load_from_image ( image , area ) The area argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the area rectangle crosses the bounds of the image, it is adjusted to fit the image size. The maximum size for a texture depends on the graphics driver and can be retrieved with the maximum_size function. If this function fails, the texture is left unchanged. stream - Source stream to read from area - Area of the image to load Returns: True if loading was successful See also: load_from_file , load_from_memory , load_from_image [ View source ] #native_handle : Int32 # Get the underlying OpenGL handle of the texture. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed. Returns: OpenGL handle of the texture or 0 if not yet created [ View source ] #repeated= ( repeated : Bool ) # Enable or disable repeating Repeating is involved when using texture coordinates outside the texture rectangle [0, 0, width, height]. In this case, if repeat mode is enabled, the whole texture will be repeated as many times as needed to reach the coordinate (for example, if the X texture coordinate is 3 * width, the texture will be repeated 3 times). If repeat mode is disabled, the \"extra space\" will instead be filled with border pixels. Warning: on very old graphics cards, white pixels may appear when the texture is repeated. With such cards, repeat mode can be used reliably only if the texture has power-of-two dimensions (such as 256x128). Repeating is disabled by default. repeated - True to repeat the texture, false to disable repeating See also: repeated? [ View source ] #repeated? : Bool # Tell whether the texture is repeated or not Returns: True if repeat mode is enabled, false if it is disabled See also: repeated= [ View source ] #size : Vector2u # Return the size of the texture Returns: Size in pixels [ View source ] #smooth= ( smooth : Bool ) # Enable or disable the smooth filter When the filter is activated, the texture appears smoother so that pixels are less noticeable. However if you want the texture to look exactly the same as its source file, you should leave it disabled. The smooth filter is disabled by default. smooth - True to enable smoothing, false to disable it See also: smooth? [ View source ] #smooth? : Bool # Tell whether the smooth filter is enabled or not Returns: True if smoothing is enabled, false if it is disabled See also: smooth= [ View source ] #srgb= ( s_rgb : Bool ) # Enable or disable conversion from sRGB When providing texture data from an image file or memory, it can either be stored in a linear color space or an sRGB color space. Most digital images account for gamma correction already, so they would need to be \"uncorrected\" back to linear color space before being processed by the hardware. The hardware can automatically convert it from the sRGB color space to a linear color space when it gets sampled. When the rendered image gets output to the final framebuffer, it gets converted back to sRGB. After enabling or disabling sRGB conversion, make sure to reload the texture data in order for the setting to take effect. This option is only useful in conjunction with an sRGB capable framebuffer. This can be requested during window creation. s_rgb - True to enable sRGB conversion, false to disable it See also: srgb? [ View source ] #srgb? : Bool # Tell whether the texture source is converted from sRGB or not Returns: True if the texture source is converted from sRGB, false if not See also: srgb= [ View source ] #swap ( right : Texture ) # Swap the contents of this texture with those of another right - Instance to swap with [ View source ] #update ( window : Window ) # Update the texture from the contents of a window Although the source window can be smaller than the texture, this function is usually used for updating the whole texture. The other overload, which has (x, y) additional arguments, is more convenient for updating a sub-area of the texture. No additional check is performed on the size of the window, passing a window bigger than the texture will lead to an undefined behavior. This function does nothing if either the texture or the window was not previously created. window - Window to copy to the texture [ View source ] #update ( image : Image ) # Update the texture from an image Although the source image can be smaller than the texture, this function is usually used for updating the whole texture. The other overload, which has (x, y) additional arguments, is more convenient for updating a sub-area of the texture. No additional check is performed on the size of the image, passing an image bigger than the texture will lead to an undefined behavior. This function does nothing if the texture was not previously created. image - Image to copy to the texture [ View source ] #update ( pixels : Pointer ( UInt8 )) # Update the whole texture from an array of pixels The pixel array is assumed to have the same size as the area rectangle, and to contain 32-bits RGBA pixels. No additional check is performed on the size of the pixel array, passing invalid arguments will lead to an undefined behavior. This function does nothing if pixels is null or if the texture was not previously created. pixels - Array of pixels to copy to the texture [ View source ] #update ( window : Window , x : Int , y : Int ) # Update a part of the texture from the contents of a window No additional check is performed on the size of the window, passing an invalid combination of window size and offset will lead to an undefined behavior. This function does nothing if either the texture or the window was not previously created. window - Window to copy to the texture x - X offset in the texture where to copy the source window y - Y offset in the texture where to copy the source window [ View source ] #update ( image : Image , x : Int , y : Int ) # Update a part of the texture from an image No additional check is performed on the size of the image, passing an invalid combination of image size and offset will lead to an undefined behavior. This function does nothing if the texture was not previously created. image - Image to copy to the texture x - X offset in the texture where to copy the source image y - Y offset in the texture where to copy the source image [ View source ] #update ( texture : Texture , x : Int , y : Int ) # Update a part of this texture from another texture No additional check is performed on the size of the texture, passing an invalid combination of texture size and offset will lead to an undefined behavior. This function does nothing if either texture was not previously created. texture - Source texture to copy to this texture x - X offset in this texture where to copy the source texture y - Y offset in this texture where to copy the source texture [ View source ] #update ( pixels : Pointer ( UInt8 ), width : Int , height : Int , x : Int , y : Int ) # Update a part of the texture from an array of pixels The size of the pixel array must match the width and height arguments, and it must contain 32-bits RGBA pixels. No additional check is performed on the size of the pixel array or the bounds of the area to update, passing invalid arguments will lead to an undefined behavior. This function does nothing if pixels is null or if the texture was not previously created. pixels - Array of pixels to copy to the texture width - Width of the pixel region contained in pixels height - Height of the pixel region contained in pixels x - X offset in the texture where to copy the source pixels y - Y offset in the texture where to copy the source pixels [ View source ] #update ( texture : Texture ) # Update a part of this texture from another texture Although the source texture can be smaller than this texture, this function is usually used for updating the whole texture. The other overload, which has (x, y) additional arguments, is more convenient for updating a sub-area of this texture. No additional check is performed on the size of the passed texture, passing a texture bigger than this texture will lead to an undefined behavior. This function does nothing if either texture was not previously created. texture - Source texture to copy to this texture [ View source ]","title":"Texture"},{"location":"api/SF/Texture.html#SF::Texture","text":"Image living on the graphics card that can be used for drawing SF::Texture stores pixels that can be drawn, with a sprite for example. A texture lives in the graphics card memory, therefore it is very fast to draw a texture to a render target, or copy a render target to a texture (the graphics card can access both directly). Being stored in the graphics card memory has some drawbacks. A texture cannot be manipulated as freely as a SF::Image , you need to prepare the pixels first and then upload them to the texture in a single operation (see Texture.update). SF::Texture makes it easy to convert from/to SF::Image , but keep in mind that these calls require transfers between the graphics card and the central memory, therefore they are slow operations. A texture can be loaded from an image, but also directly from a file/memory/stream. The necessary shortcuts are defined so that you don't need an image first for the most common cases. However, if you want to perform some modifications on the pixels before creating the final texture, you can load your file to a SF::Image , do whatever you need with the pixels, and then call Texture.load_from_image. Since they live in the graphics card memory, the pixels of a texture cannot be accessed without a slow copy first. And they cannot be accessed individually. Therefore, if you need to read the texture's pixels (like for pixel-perfect collisions), it is recommended to store the collision information separately, for example in an array of booleans. Like SF::Image , SF::Texture can handle a unique internal representation of pixels, which is RGBA 32 bits. This means that a pixel must be composed of 8 bits red, green, blue and alpha channels -- just like a SF::Color . Usage example: # This example shows the most common use of SF::Texture: # drawing a sprite # Load a texture from a file texture = SF :: Texture . from_file ( \"texture.png\" ) # Assign it to a sprite sprite = SF :: Sprite . new ( texture ) # Draw the textured sprite window . draw sprite # This example shows another common use of SF::Texture: # streaming real-time data, like video frames # Create an empty texture texture = SF :: Texture . new ( 640 , 480 ) # Create a sprite that will display the texture sprite = SF :: Sprite . new ( texture ) loop do # the main loop ... # update the texture pixels = ( ... ) . to_unsafe # get a fresh chunk of pixels (the next frame of a movie, for example) texture . update ( pixels ) # draw it window . draw sprite ... end Like SF::Shader that can be used as a raw OpenGL shader, SF::Texture can also be used directly as a raw texture for custom OpenGL geometry. SF :: Texture . bind ( texture ) ... render OpenGL geometry ... SF :: Texture . bind ( nil ) See also: SF::Sprite , SF::Image , SF::RenderTexture","title":"Texture"},{"location":"api/SF/Texture.html#included-modules","text":"SF::GlResource","title":"Included modules"},{"location":"api/SF/Texture.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Texture.html#SF::Texture.bind(texture,coordinate_type)","text":"Bind a texture for rendering This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix SF::Texture with OpenGL code. t1 = SF :: Texture . new t2 = SF :: Texture . new ... SF :: Texture . bind t1 # draw OpenGL stuff that use t1... SF :: Texture . bind t2 # draw OpenGL stuff that use t2... SF :: Texture . bind nil # draw OpenGL stuff that use no texture... The coordinate_type argument controls how texture coordinates will be interpreted. If Normalized (the default), they must be in range 0.0 .. 1.0 , which is the default way of handling texture coordinates with OpenGL. If Pixels, they must be given in pixels (range 0.0 .. size ). This mode is used internally by the graphics classes of SFML, it makes the definition of texture coordinates more intuitive for the high-level API, users don't need to compute normalized values. texture - Pointer to the texture to bind, can be null to use no texture coordinate_type - Type of texture coordinates to use [ View source ]","title":".bind"},{"location":"api/SF/Texture.html#SF::Texture.maximum_size()","text":"Get the maximum texture size allowed This maximum size is defined by the graphics driver. You can expect a value of 512 pixels for low-end graphics card, and up to 8192 pixels or more for newer hardware. Returns: Maximum size allowed for textures, in pixels [ View source ]","title":".maximum_size"},{"location":"api/SF/Texture.html#SF::Texture.from_file(*args,**kwargs)","text":"Shorthand for texture = Texture.new; texture.load_from_file(...); texture Raises InitError on failure [ View source ]","title":".from_file"},{"location":"api/SF/Texture.html#SF::Texture.from_image(*args,**kwargs)","text":"Shorthand for texture = Texture.new; texture.load_from_image(...); texture Raises InitError on failure [ View source ]","title":".from_image"},{"location":"api/SF/Texture.html#SF::Texture.from_memory(*args,**kwargs)","text":"Shorthand for texture = Texture.new; texture.load_from_memory(...); texture Raises InitError on failure [ View source ]","title":".from_memory"},{"location":"api/SF/Texture.html#SF::Texture.from_stream(*args,**kwargs)","text":"Shorthand for texture = Texture.new; texture.load_from_stream(...); texture Raises InitError on failure [ View source ]","title":".from_stream"},{"location":"api/SF/Texture.html#SF::Texture.new()","text":"Default constructor Creates an empty texture. [ View source ]","title":".new"},{"location":"api/SF/Texture.html#methods","text":"","title":"Methods"},{"location":"api/SF/Texture.html#SF::Texture#copy_to_image()","text":"Copy the texture pixels to an image This function performs a slow operation that downloads the texture's pixels from the graphics card and copies them to a new image, potentially applying transformations to pixels if necessary (texture may be padded or flipped). Returns: Image containing the texture's pixels See also: load_from_image [ View source ]","title":"#copy_to_image"},{"location":"api/SF/Texture.html#SF::Texture#create(width,height)","text":"Create the texture If this function fails, the texture is left unchanged. width - Width of the texture height - Height of the texture Returns: True if creation was successful [ View source ]","title":"#create"},{"location":"api/SF/Texture.html#SF::Texture#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Texture.html#SF::Texture#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Texture.html#SF::Texture#generate_mipmap()","text":"Generate a mipmap using the current texture data Mipmaps are pre-computed chains of optimized textures. Each level of texture in a mipmap is generated by halving each of the previous level's dimensions. This is done until the final level has the size of 1x1. The textures generated in this process may make use of more advanced filters which might improve the visual quality of textures when they are applied to objects much smaller than they are. This is known as minification. Because fewer texels (texture elements) have to be sampled from when heavily minified, usage of mipmaps can also improve rendering performance in certain scenarios. Mipmap generation relies on the necessary OpenGL extension being available. If it is unavailable or generation fails due to another reason, this function will return false. Mipmap data is only valid from the time it is generated until the next time the base level image is modified, at which point this function will have to be called again to regenerate it. Returns: True if mipmap generation was successful, false if unsuccessful [ View source ]","title":"#generate_mipmap"},{"location":"api/SF/Texture.html#SF::Texture#load_from_file(filename,area)","text":"Load the texture from a file on disk This function is a shortcut for the following code: image = SF :: Image . new image . load_from_file ( filename ) texture . load_from_image ( image , area ) The area argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the area rectangle crosses the bounds of the image, it is adjusted to fit the image size. The maximum size for a texture depends on the graphics driver and can be retrieved with the maximum_size function. If this function fails, the texture is left unchanged. filename - Path of the image file to load area - Area of the image to load Returns: True if loading was successful See also: load_from_memory , load_from_stream , load_from_image [ View source ]","title":"#load_from_file"},{"location":"api/SF/Texture.html#SF::Texture#load_from_image(image,area)","text":"Load the texture from an image The area argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the area rectangle crosses the bounds of the image, it is adjusted to fit the image size. The maximum size for a texture depends on the graphics driver and can be retrieved with the maximum_size function. If this function fails, the texture is left unchanged. image - Image to load into the texture area - Area of the image to load Returns: True if loading was successful See also: load_from_file , load_from_memory [ View source ]","title":"#load_from_image"},{"location":"api/SF/Texture.html#SF::Texture#load_from_memory(data,area)","text":"Load the texture from a file in memory This function is a shortcut for the following code: image = SF :: Image . new image . load_from_memory ( data , size ) texture . load_from_image ( image , area ) The area argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the area rectangle crosses the bounds of the image, it is adjusted to fit the image size. The maximum size for a texture depends on the graphics driver and can be retrieved with the maximum_size function. If this function fails, the texture is left unchanged. data - Slice containing the file data in memory area - Area of the image to load Returns: True if loading was successful See also: load_from_file , load_from_stream , load_from_image [ View source ]","title":"#load_from_memory"},{"location":"api/SF/Texture.html#SF::Texture#load_from_stream(stream,area)","text":"Load the texture from a custom stream This function is a shortcut for the following code: image = SF :: Image . new image . load_from_stream ( stream ) texture . load_from_image ( image , area ) The area argument can be used to load only a sub-rectangle of the whole image. If you want the entire image then leave the default value (which is an empty IntRect). If the area rectangle crosses the bounds of the image, it is adjusted to fit the image size. The maximum size for a texture depends on the graphics driver and can be retrieved with the maximum_size function. If this function fails, the texture is left unchanged. stream - Source stream to read from area - Area of the image to load Returns: True if loading was successful See also: load_from_file , load_from_memory , load_from_image [ View source ]","title":"#load_from_stream"},{"location":"api/SF/Texture.html#SF::Texture#native_handle()","text":"Get the underlying OpenGL handle of the texture. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed. Returns: OpenGL handle of the texture or 0 if not yet created [ View source ]","title":"#native_handle"},{"location":"api/SF/Texture.html#SF::Texture#repeated=(repeated)","text":"Enable or disable repeating Repeating is involved when using texture coordinates outside the texture rectangle [0, 0, width, height]. In this case, if repeat mode is enabled, the whole texture will be repeated as many times as needed to reach the coordinate (for example, if the X texture coordinate is 3 * width, the texture will be repeated 3 times). If repeat mode is disabled, the \"extra space\" will instead be filled with border pixels. Warning: on very old graphics cards, white pixels may appear when the texture is repeated. With such cards, repeat mode can be used reliably only if the texture has power-of-two dimensions (such as 256x128). Repeating is disabled by default. repeated - True to repeat the texture, false to disable repeating See also: repeated? [ View source ]","title":"#repeated="},{"location":"api/SF/Texture.html#SF::Texture#repeated?()","text":"Tell whether the texture is repeated or not Returns: True if repeat mode is enabled, false if it is disabled See also: repeated= [ View source ]","title":"#repeated?"},{"location":"api/SF/Texture.html#SF::Texture#size()","text":"Return the size of the texture Returns: Size in pixels [ View source ]","title":"#size"},{"location":"api/SF/Texture.html#SF::Texture#smooth=(smooth)","text":"Enable or disable the smooth filter When the filter is activated, the texture appears smoother so that pixels are less noticeable. However if you want the texture to look exactly the same as its source file, you should leave it disabled. The smooth filter is disabled by default. smooth - True to enable smoothing, false to disable it See also: smooth? [ View source ]","title":"#smooth="},{"location":"api/SF/Texture.html#SF::Texture#smooth?()","text":"Tell whether the smooth filter is enabled or not Returns: True if smoothing is enabled, false if it is disabled See also: smooth= [ View source ]","title":"#smooth?"},{"location":"api/SF/Texture.html#SF::Texture#srgb=(s_rgb)","text":"Enable or disable conversion from sRGB When providing texture data from an image file or memory, it can either be stored in a linear color space or an sRGB color space. Most digital images account for gamma correction already, so they would need to be \"uncorrected\" back to linear color space before being processed by the hardware. The hardware can automatically convert it from the sRGB color space to a linear color space when it gets sampled. When the rendered image gets output to the final framebuffer, it gets converted back to sRGB. After enabling or disabling sRGB conversion, make sure to reload the texture data in order for the setting to take effect. This option is only useful in conjunction with an sRGB capable framebuffer. This can be requested during window creation. s_rgb - True to enable sRGB conversion, false to disable it See also: srgb? [ View source ]","title":"#srgb="},{"location":"api/SF/Texture.html#SF::Texture#srgb?()","text":"Tell whether the texture source is converted from sRGB or not Returns: True if the texture source is converted from sRGB, false if not See also: srgb= [ View source ]","title":"#srgb?"},{"location":"api/SF/Texture.html#SF::Texture#swap(right)","text":"Swap the contents of this texture with those of another right - Instance to swap with [ View source ]","title":"#swap"},{"location":"api/SF/Texture.html#SF::Texture#update(window)","text":"Update the texture from the contents of a window Although the source window can be smaller than the texture, this function is usually used for updating the whole texture. The other overload, which has (x, y) additional arguments, is more convenient for updating a sub-area of the texture. No additional check is performed on the size of the window, passing a window bigger than the texture will lead to an undefined behavior. This function does nothing if either the texture or the window was not previously created. window - Window to copy to the texture [ View source ]","title":"#update"},{"location":"api/SF/Thread.html","text":"class SF::Thread inherits Reference # Utility class to manipulate threads Threads provide a way to run multiple parts of the code in parallel. When you launch a new thread, the execution is split and both the new thread and the caller run in parallel. To use a SF::Thread , you construct it directly with the function to execute as the entry point of the thread. SF::Thread has multiple template constructors, which means that you can use several types of entry points: non-member functions with no argument non-member functions with one argument of any type functors with no argument (this one is particularly useful for compatibility with boost/std::%bind) functors with one argument of any type member functions from any class with no argument The function argument, if any, is copied in the SF::Thread instance, as well as the functor (if the corresponding constructor is used). Class instances, however, are passed by pointer so you must make sure that the object won't be destroyed while the thread is still using it. The thread ends when its function is terminated. If the owner SF::Thread instance is destroyed before the thread is finished, the destructor will wait (see wait() ) Usage examples: # example 1: non member function with one argument void threadFunc ( int argument ) ... end thread = SF :: Thread . new ( & threadFunc , 5 ) thread . launch () # start the thread ( internally calls threadFunc ( 5 )) # example 2: member function class Task public : void run () ... end end Task task thread = SF :: Thread . new ( & Task . run , & task ) thread . launch () # start the thread ( internally calls task . run ()) # example 3: functor struct Task void operator ()() ... end end thread = SF :: Thread . new ( Task ()) thread . launch () # start the thread ( internally calls operator () on the Task instance ) Creating parallel threads of execution can be dangerous: all threads inside the same process share the same memory space, which means that you may end up accessing the same variable from multiple threads at the same time. To prevent this kind of situations, you can use mutexes (see SF::Mutex ). See also: SF::Mutex Included modules # SF::NonCopyable Class methods # .new ( function : -> ) # Construct the thread from a functor with an argument This constructor works for function objects, as well as free functions. It is a template, which means that the argument can have any type (int, std::string, void*, Toto, ...). Use this constructor for this kind of function: void function ( int arg ) # --- or ---- struct Functor void operator ()( std :: string arg ) end Note: this does not run the thread, use launch() . function - Functor or free function to use as the entry point of the thread argument - argument to forward to the function [ View source ] Methods # #finalize # Destructor This destructor calls wait() , so that the internal thread cannot survive after its SF::Thread instance is destroyed. [ View source ] #launch # Run the thread This function starts the entry point passed to the thread's constructor, and returns immediately. After this function returns, the thread's function is running in parallel to the calling code. [ View source ] #terminate # Terminate the thread This function immediately stops the thread, without waiting for its function to finish. Terminating a thread with this function is not safe, and can lead to local variables not being destroyed on some operating systems. You should rather try to make the thread function terminate by itself. [ View source ] #wait # Wait until the thread finishes This function will block the execution until the thread's function ends. Warning: if the thread function never ends, the calling thread will block forever. If this function is called from its owner thread, it returns without doing anything. [ View source ]","title":"Thread"},{"location":"api/SF/Thread.html#SF::Thread","text":"Utility class to manipulate threads Threads provide a way to run multiple parts of the code in parallel. When you launch a new thread, the execution is split and both the new thread and the caller run in parallel. To use a SF::Thread , you construct it directly with the function to execute as the entry point of the thread. SF::Thread has multiple template constructors, which means that you can use several types of entry points: non-member functions with no argument non-member functions with one argument of any type functors with no argument (this one is particularly useful for compatibility with boost/std::%bind) functors with one argument of any type member functions from any class with no argument The function argument, if any, is copied in the SF::Thread instance, as well as the functor (if the corresponding constructor is used). Class instances, however, are passed by pointer so you must make sure that the object won't be destroyed while the thread is still using it. The thread ends when its function is terminated. If the owner SF::Thread instance is destroyed before the thread is finished, the destructor will wait (see wait() ) Usage examples: # example 1: non member function with one argument void threadFunc ( int argument ) ... end thread = SF :: Thread . new ( & threadFunc , 5 ) thread . launch () # start the thread ( internally calls threadFunc ( 5 )) # example 2: member function class Task public : void run () ... end end Task task thread = SF :: Thread . new ( & Task . run , & task ) thread . launch () # start the thread ( internally calls task . run ()) # example 3: functor struct Task void operator ()() ... end end thread = SF :: Thread . new ( Task ()) thread . launch () # start the thread ( internally calls operator () on the Task instance ) Creating parallel threads of execution can be dangerous: all threads inside the same process share the same memory space, which means that you may end up accessing the same variable from multiple threads at the same time. To prevent this kind of situations, you can use mutexes (see SF::Mutex ). See also: SF::Mutex","title":"Thread"},{"location":"api/SF/Thread.html#included-modules","text":"SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Thread.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Thread.html#SF::Thread.new(function)","text":"Construct the thread from a functor with an argument This constructor works for function objects, as well as free functions. It is a template, which means that the argument can have any type (int, std::string, void*, Toto, ...). Use this constructor for this kind of function: void function ( int arg ) # --- or ---- struct Functor void operator ()( std :: string arg ) end Note: this does not run the thread, use launch() . function - Functor or free function to use as the entry point of the thread argument - argument to forward to the function [ View source ]","title":".new"},{"location":"api/SF/Thread.html#methods","text":"","title":"Methods"},{"location":"api/SF/Thread.html#SF::Thread#finalize()","text":"Destructor This destructor calls wait() , so that the internal thread cannot survive after its SF::Thread instance is destroyed. [ View source ]","title":"#finalize"},{"location":"api/SF/Thread.html#SF::Thread#launch()","text":"Run the thread This function starts the entry point passed to the thread's constructor, and returns immediately. After this function returns, the thread's function is running in parallel to the calling code. [ View source ]","title":"#launch"},{"location":"api/SF/Thread.html#SF::Thread#terminate()","text":"Terminate the thread This function immediately stops the thread, without waiting for its function to finish. Terminating a thread with this function is not safe, and can lead to local variables not being destroyed on some operating systems. You should rather try to make the thread function terminate by itself. [ View source ]","title":"#terminate"},{"location":"api/SF/Thread.html#SF::Thread#wait()","text":"Wait until the thread finishes This function will block the execution until the thread's function ends. Warning: if the thread function never ends, the calling thread will block forever. If this function is called from its owner thread, it returns without doing anything. [ View source ]","title":"#wait"},{"location":"api/SF/Time.html","text":"struct SF::Time inherits Struct # Represents a time value SF::Time encapsulates a time value in a flexible way. It allows to define a time value either as a number of seconds, milliseconds or microseconds. It also works the other way round: you can read a time value as either a number of seconds, milliseconds or microseconds. By using such a flexible interface, the API doesn't impose any fixed type or resolution for time values, and let the user choose its own favorite representation. Time values support the usual mathematical operations: you can add or subtract two times, multiply or divide a time by a number, compare two times, etc. Since they represent a time span and not an absolute time value, times can also be negative. Usage example: t1 = SF . seconds ( 0.1 ) milli = t1 . as_milliseconds # 100 t2 = SF . milliseconds ( 30 ) micro = t2 . as_microseconds # 30000 t3 = SF . microseconds ( - 800000 ) sec = t3 . as_seconds # -0.8 def update ( elapsed : SF :: Time ) @position += @speed * elapsed . as_seconds end update ( SF . milliseconds ( 100 )) See also: SF::Clock Constants # Zero # Predefined \"zero\" time value Class methods # .new # Default constructor Sets the time value to zero. [ View source ] Methods # #!= ( right : Time ) : Bool # Overload of != operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if both time values are different [ View source ] #% ( right : Time ) : Time # Overload of binary % operator to compute remainder of a time value left - Left operand (a time) right - Right operand (a time) Returns: left modulo right [ View source ] #* ( right : Number ) : Time # Overload of binary * operator to scale a time value left - Left operand (a time) right - Right operand (a number) Returns: left multiplied by right [ View source ] #* ( right : Int ) : Time # Overload of binary * operator to scale a time value left - Left operand (a time) right - Right operand (a number) Returns: left multiplied by right [ View source ] #+ ( right : Time ) : Time # Overload of binary + operator to add two time values left - Left operand (a time) right - Right operand (a time) Returns: Sum of the two times values [ View source ] #- ( right : Time ) : Time # Overload of binary - operator to subtract two time values left - Left operand (a time) right - Right operand (a time) Returns: Difference of the two times values [ View source ] #- : Time # Overload of unary - operator to negate a time value right - Right operand (a time) Returns: Opposite of the time value [ View source ] #/ ( right : Number ) : Time # Overload of binary / operator to scale a time value left - Left operand (a time) right - Right operand (a number) Returns: left divided by right [ View source ] #/ ( right : Int ) : Time # Overload of binary / operator to scale a time value left - Left operand (a time) right - Right operand (a number) Returns: left divided by right [ View source ] #/ ( right : Time ) : Float32 # Overload of binary / operator to compute the ratio of two time values left - Left operand (a time) right - Right operand (a time) Returns: left divided by right [ View source ] #< ( right : Time ) : Bool # Overload of < operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if left is lesser than right [ View source ] #<= ( right : Time ) : Bool # Overload of <= operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if left is lesser or equal than right [ View source ] #== ( right : Time ) : Bool # Overload of == operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if both time values are equal [ View source ] #> ( right : Time ) : Bool # Overload of > operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if left is greater than right [ View source ] #>= ( right : Time ) : Bool # Overload of >= operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if left is greater or equal than right [ View source ] #as_microseconds : Int64 # Return the time value as a number of microseconds Returns: Time in microseconds See also: as_seconds , as_milliseconds [ View source ] #as_milliseconds : Int32 # Return the time value as a number of milliseconds Returns: Time in milliseconds See also: as_seconds , as_microseconds [ View source ] #as_seconds : Float32 # Return the time value as a number of seconds Returns: Time in seconds See also: as_milliseconds , as_microseconds [ View source ] #dup : Time # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"Time"},{"location":"api/SF/Time.html#SF::Time","text":"Represents a time value SF::Time encapsulates a time value in a flexible way. It allows to define a time value either as a number of seconds, milliseconds or microseconds. It also works the other way round: you can read a time value as either a number of seconds, milliseconds or microseconds. By using such a flexible interface, the API doesn't impose any fixed type or resolution for time values, and let the user choose its own favorite representation. Time values support the usual mathematical operations: you can add or subtract two times, multiply or divide a time by a number, compare two times, etc. Since they represent a time span and not an absolute time value, times can also be negative. Usage example: t1 = SF . seconds ( 0.1 ) milli = t1 . as_milliseconds # 100 t2 = SF . milliseconds ( 30 ) micro = t2 . as_microseconds # 30000 t3 = SF . microseconds ( - 800000 ) sec = t3 . as_seconds # -0.8 def update ( elapsed : SF :: Time ) @position += @speed * elapsed . as_seconds end update ( SF . milliseconds ( 100 )) See also: SF::Clock","title":"Time"},{"location":"api/SF/Time.html#constants","text":"","title":"Constants"},{"location":"api/SF/Time.html#SF::Time::Zero","text":"Predefined \"zero\" time value","title":"Zero"},{"location":"api/SF/Time.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Time.html#SF::Time.new()","text":"Default constructor Sets the time value to zero. [ View source ]","title":".new"},{"location":"api/SF/Time.html#methods","text":"","title":"Methods"},{"location":"api/SF/Time.html#SF::Time#!=(right)","text":"Overload of != operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if both time values are different [ View source ]","title":"#!="},{"location":"api/SF/Time.html#SF::Time#%(right)","text":"Overload of binary % operator to compute remainder of a time value left - Left operand (a time) right - Right operand (a time) Returns: left modulo right [ View source ]","title":"#%"},{"location":"api/SF/Time.html#SF::Time#*(right)","text":"Overload of binary * operator to scale a time value left - Left operand (a time) right - Right operand (a number) Returns: left multiplied by right [ View source ]","title":"#*"},{"location":"api/SF/Time.html#SF::Time#*(right)","text":"Overload of binary * operator to scale a time value left - Left operand (a time) right - Right operand (a number) Returns: left multiplied by right [ View source ]","title":"#*"},{"location":"api/SF/Time.html#SF::Time#+(right)","text":"Overload of binary + operator to add two time values left - Left operand (a time) right - Right operand (a time) Returns: Sum of the two times values [ View source ]","title":"#+"},{"location":"api/SF/Time.html#SF::Time#-(right)","text":"Overload of binary - operator to subtract two time values left - Left operand (a time) right - Right operand (a time) Returns: Difference of the two times values [ View source ]","title":"#-"},{"location":"api/SF/Time.html#SF::Time#/(right)","text":"Overload of binary / operator to scale a time value left - Left operand (a time) right - Right operand (a number) Returns: left divided by right [ View source ]","title":"#/"},{"location":"api/SF/Time.html#SF::Time#/(right)","text":"Overload of binary / operator to scale a time value left - Left operand (a time) right - Right operand (a number) Returns: left divided by right [ View source ]","title":"#/"},{"location":"api/SF/Time.html#SF::Time#/(right)","text":"Overload of binary / operator to compute the ratio of two time values left - Left operand (a time) right - Right operand (a time) Returns: left divided by right [ View source ]","title":"#/"},{"location":"api/SF/Time.html#SF::Time#<(right)","text":"Overload of < operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if left is lesser than right [ View source ]","title":"#&lt;"},{"location":"api/SF/Time.html#SF::Time#<=(right)","text":"Overload of <= operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if left is lesser or equal than right [ View source ]","title":"#&lt;="},{"location":"api/SF/Time.html#SF::Time#==(right)","text":"Overload of == operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if both time values are equal [ View source ]","title":"#=="},{"location":"api/SF/Time.html#SF::Time#>(right)","text":"Overload of > operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if left is greater than right [ View source ]","title":"#&gt;"},{"location":"api/SF/Time.html#SF::Time#>=(right)","text":"Overload of >= operator to compare two time values left - Left operand (a time) right - Right operand (a time) Returns: True if left is greater or equal than right [ View source ]","title":"#&gt;="},{"location":"api/SF/Time.html#SF::Time#as_microseconds()","text":"Return the time value as a number of microseconds Returns: Time in microseconds See also: as_seconds , as_milliseconds [ View source ]","title":"#as_microseconds"},{"location":"api/SF/Time.html#SF::Time#as_milliseconds()","text":"Return the time value as a number of milliseconds Returns: Time in milliseconds See also: as_seconds , as_microseconds [ View source ]","title":"#as_milliseconds"},{"location":"api/SF/Time.html#SF::Time#as_seconds()","text":"Return the time value as a number of seconds Returns: Time in seconds See also: as_milliseconds , as_microseconds [ View source ]","title":"#as_seconds"},{"location":"api/SF/Time.html#SF::Time#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Touch.html","text":"module SF::Touch # Give access to the real-time state of the touches SF::Touch provides an interface to the state of the touches. It only contains static functions, so it's not meant to be instantiated. This module allows users to query the touches state at any time and directly, without having to deal with a window and its events. Compared to the TouchBegan, TouchMoved and TouchEnded events, SF::Touch can retrieve the state of the touches at any time (you don't need to store and update a boolean on your side in order to know if a touch is down), and you always get the real state of the touches, even if they happen when your window is out of focus and no event is triggered. The position function can be used to retrieve the current position of a touch. There are two versions: one that operates in global coordinates (relative to the desktop) and one that operates in window coordinates (relative to a specific window). Touches are identified by an index (the \"finger\"), so that in multi-touch events, individual touches can be tracked correctly. As long as a finger touches the screen, it will keep the same index even if other fingers start or stop touching the screen in the meantime. As a consequence, active touch indices may not always be sequential (i.e. touch number 0 may be released while touch number 1 is still down). Usage example: if SF :: Touch . down? ( 0 ) # touch 0 is down end # get global position of touch 1 global_pos = SF :: Touch . get_position ( 1 ) # get position of touch 1 relative to a window relative_pos = SF :: Touch . get_position ( 1 , window ) See also: SF::Joystick , SF::Keyboard , SF::Mouse Class methods # .down? ( finger : Int ) : Bool # Check if a touch event is currently down finger - Finger index Returns: True if finger is currently touching the screen, false otherwise [ View source ] .get_position ( finger : Int , relative_to : Window ) : Vector2i # Get the current position of a touch in window coordinates This function returns the current touch position relative to the given window. finger - Finger index relative_to - Reference window Returns: Current position of finger, or undefined if it's not down [ View source ] .get_position ( finger : Int ) : Vector2i # Get the current position of a touch in desktop coordinates This function returns the current touch position in global (desktop) coordinates. finger - Finger index Returns: Current position of finger, or undefined if it's not down [ View source ]","title":"Touch"},{"location":"api/SF/Touch.html#SF::Touch","text":"Give access to the real-time state of the touches SF::Touch provides an interface to the state of the touches. It only contains static functions, so it's not meant to be instantiated. This module allows users to query the touches state at any time and directly, without having to deal with a window and its events. Compared to the TouchBegan, TouchMoved and TouchEnded events, SF::Touch can retrieve the state of the touches at any time (you don't need to store and update a boolean on your side in order to know if a touch is down), and you always get the real state of the touches, even if they happen when your window is out of focus and no event is triggered. The position function can be used to retrieve the current position of a touch. There are two versions: one that operates in global coordinates (relative to the desktop) and one that operates in window coordinates (relative to a specific window). Touches are identified by an index (the \"finger\"), so that in multi-touch events, individual touches can be tracked correctly. As long as a finger touches the screen, it will keep the same index even if other fingers start or stop touching the screen in the meantime. As a consequence, active touch indices may not always be sequential (i.e. touch number 0 may be released while touch number 1 is still down). Usage example: if SF :: Touch . down? ( 0 ) # touch 0 is down end # get global position of touch 1 global_pos = SF :: Touch . get_position ( 1 ) # get position of touch 1 relative to a window relative_pos = SF :: Touch . get_position ( 1 , window ) See also: SF::Joystick , SF::Keyboard , SF::Mouse","title":"Touch"},{"location":"api/SF/Touch.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Touch.html#SF::Touch.down?(finger)","text":"Check if a touch event is currently down finger - Finger index Returns: True if finger is currently touching the screen, false otherwise [ View source ]","title":".down?"},{"location":"api/SF/Touch.html#SF::Touch.get_position(finger,relative_to)","text":"Get the current position of a touch in window coordinates This function returns the current touch position relative to the given window. finger - Finger index relative_to - Reference window Returns: Current position of finger, or undefined if it's not down [ View source ]","title":".get_position"},{"location":"api/SF/Transform.html","text":"struct SF::Transform inherits Struct # Define a 3x3 transform matrix A SF::Transform specifies how to translate, rotate, scale, shear, project, whatever things. In mathematical terms, it defines how to transform a coordinate system into another. For example, if you apply a rotation transform to a sprite, the result will be a rotated sprite. And anything that is transformed by this rotation transform will be rotated the same way, according to its initial position. Transforms are typically used for drawing. But they can also be used for any computation that requires to transform points between the local and global coordinate systems of an entity (like collision detection). Example: # define a translation transform translation = SF :: Transform . new translation . translate ( 20 , 50 ) # define a rotation transform rotation = SF :: Transform . new rotation . rotate ( 45 ) # combine them transform = translation * rotation # use the result to transform stuff... point = transform . transform_point ( 10 , 20 ) rect = transform . transform_rect ( SF . float_rect ( 0 , 0 , 10 , 100 )) See also: SF::Transformable , SF::RenderStates Constants # Identity # The identity transform (does nothing) Class methods # .new ( a00 : Number , a01 : Number , a02 : Number , a10 : Number , a11 : Number , a12 : Number , a20 : Number , a21 : Number , a22 : Number ) # Construct a transform from a 3x3 matrix a00 - Element (0, 0) of the matrix a01 - Element (0, 1) of the matrix a02 - Element (0, 2) of the matrix a10 - Element (1, 0) of the matrix a11 - Element (1, 1) of the matrix a12 - Element (1, 2) of the matrix a20 - Element (2, 0) of the matrix a21 - Element (2, 1) of the matrix a22 - Element (2, 2) of the matrix [ View source ] .new # Default constructor Creates an identity transform (a transform that does nothing). [ View source ] Methods # #!= ( right : Transform ) : Bool # Overload of binary operator != to compare two transforms This call is equivalent to !(left == right). left - Left operand (the first transform) right - Right operand (the second transform) Returns: true if the transforms are not equal, false otherwise [ View source ] #* ( right : Vector2 | Tuple ) : Vector2f # Overload of binary operator * to transform a point This call is equivalent to calling left.transform_point(right). left - Left operand (the transform) right - Right operand (the point to transform) Returns: New transformed point [ View source ] #* ( right : Transform ) : Transform # Overload of binary operator * to combine two transforms This call is equivalent to calling Transform(left).combine(right). left - Left operand (the first transform) right - Right operand (the second transform) Returns: New combined transform [ View source ] #== ( right : Transform ) : Bool # Overload of binary operator == to compare two transforms Performs an element-wise comparison of the elements of the left transform with the elements of the right transform. left - Left operand (the first transform) right - Right operand (the second transform) Returns: true if the transforms are equal, false otherwise [ View source ] #combine ( transform : Transform ) : Transform # Combine the current transform with another one The result is a transform that is equivalent to applying this followed by transform.* Mathematically, it is equivalent to a matrix multiplication. transform - Transform to combine with this transform Returns: Reference to *this [ View source ] #dup : Transform # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #inspect ( io ) # [ View source ] #inverse : Transform # Return the inverse of the transform If the inverse cannot be computed, an identity transform is returned. Returns: A new transform which is the inverse of self [ View source ] #matrix : Pointer ( Float32 ) # Return the transform as a 4x4 matrix This function returns a pointer to an array of 16 floats containing the transform elements as a 4x4 matrix, which is directly compatible with OpenGL functions. transform = ... glLoadMatrixf ( transform . matrix ()) Returns: Pointer to a 4x4 matrix [ View source ] #rotate ( angle : Number , center : Vector2 | Tuple ) : Transform # Combine the current transform with a rotation The center of rotation is provided for convenience as a second argument, so that you can build rotations around arbitrary points more easily (and efficiently) than the usual translate(-center).rotate(angle).translate(center). This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . rotate ( 90 , SF . vector2f ( 8 , 3 )) . translate ( SF . vector2f ( 50 , 20 )) angle - Rotation angle, in degrees center - Center of rotation Returns: Reference to *this See also: translate , scale [ View source ] #rotate ( angle : Number , center_x : Number , center_y : Number ) : Transform # Combine the current transform with a rotation The center of rotation is provided for convenience as a second argument, so that you can build rotations around arbitrary points more easily (and efficiently) than the usual translate(-center).rotate(angle).translate(center). This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . rotate ( 90 , 8 , 3 ) . translate ( 50 , 20 ) angle - Rotation angle, in degrees center_x - X coordinate of the center of rotation center_y - Y coordinate of the center of rotation Returns: Reference to *this See also: translate , scale [ View source ] #rotate ( angle : Number ) : Transform # Combine the current transform with a rotation This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . rotate ( 90 ) . translate ( 50 , 20 ) angle - Rotation angle, in degrees Returns: Reference to *this See also: translate , scale [ View source ] #scale ( scale_x : Number , scale_y : Number , center_x : Number , center_y : Number ) : Transform # Combine the current transform with a scaling The center of scaling is provided for convenience as a second argument, so that you can build scaling around arbitrary points more easily (and efficiently) than the usual translate(-center).scale(factors).translate(center). This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . scale ( 2 , 1 , 8 , 3 ) . rotate ( 45 ) scale_x - Scaling factor on X axis scale_y - Scaling factor on Y axis center_x - X coordinate of the center of scaling center_y - Y coordinate of the center of scaling Returns: Reference to *this See also: translate , rotate [ View source ] #scale ( scale_x : Number , scale_y : Number ) : Transform # Combine the current transform with a scaling This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . scale ( 2 , 1 ) . rotate ( 45 ) scale_x - Scaling factor on the X axis scale_y - Scaling factor on the Y axis Returns: Reference to *this See also: translate , rotate [ View source ] #scale ( factors : Vector2 | Tuple , center : Vector2 | Tuple ) : Transform # Combine the current transform with a scaling The center of scaling is provided for convenience as a second argument, so that you can build scaling around arbitrary points more easily (and efficiently) than the usual translate(-center).scale(factors).translate(center). This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . scale ( SF . vector2f ( 2 , 1 ), SF . vector2f ( 8 , 3 )) . rotate ( 45 ) factors - Scaling factors center - Center of scaling Returns: Reference to *this See also: translate , rotate [ View source ] #scale ( factors : Vector2 | Tuple ) : Transform # Combine the current transform with a scaling This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . scale ( SF . vector2f ( 2 , 1 )) . rotate ( 45 ) factors - Scaling factors Returns: Reference to *this See also: translate , rotate [ View source ] #transform_point ( point : Vector2 | Tuple ) : Vector2f # Transform a 2D point point - Point to transform Returns: Transformed point [ View source ] #transform_point ( x : Number , y : Number ) : Vector2f # Transform a 2D point x - X coordinate of the point to transform y - Y coordinate of the point to transform Returns: Transformed point [ View source ] #transform_rect ( rectangle : FloatRect ) : FloatRect # Transform a rectangle Since SFML doesn't provide support for oriented rectangles, the result of this function is always an axis-aligned rectangle. Which means that if the transform contains a rotation, the bounding rectangle of the transformed rectangle is returned. rectangle - Rectangle to transform Returns: Transformed rectangle [ View source ] #translate ( offset : Vector2 | Tuple ) : Transform # Combine the current transform with a translation This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . translate ( SF . vector2f ( 100 , 200 )) . rotate ( 45 ) offset - Translation offset to apply Returns: Reference to *this See also: rotate , scale [ View source ] #translate ( x : Number , y : Number ) : Transform # Combine the current transform with a translation This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . translate ( 100 , 200 ) . rotate ( 45 ) x - Offset to apply on X axis y - Offset to apply on Y axis Returns: Reference to *this See also: rotate , scale [ View source ]","title":"Transform"},{"location":"api/SF/Transform.html#SF::Transform","text":"Define a 3x3 transform matrix A SF::Transform specifies how to translate, rotate, scale, shear, project, whatever things. In mathematical terms, it defines how to transform a coordinate system into another. For example, if you apply a rotation transform to a sprite, the result will be a rotated sprite. And anything that is transformed by this rotation transform will be rotated the same way, according to its initial position. Transforms are typically used for drawing. But they can also be used for any computation that requires to transform points between the local and global coordinate systems of an entity (like collision detection). Example: # define a translation transform translation = SF :: Transform . new translation . translate ( 20 , 50 ) # define a rotation transform rotation = SF :: Transform . new rotation . rotate ( 45 ) # combine them transform = translation * rotation # use the result to transform stuff... point = transform . transform_point ( 10 , 20 ) rect = transform . transform_rect ( SF . float_rect ( 0 , 0 , 10 , 100 )) See also: SF::Transformable , SF::RenderStates","title":"Transform"},{"location":"api/SF/Transform.html#constants","text":"","title":"Constants"},{"location":"api/SF/Transform.html#SF::Transform::Identity","text":"The identity transform (does nothing)","title":"Identity"},{"location":"api/SF/Transform.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Transform.html#SF::Transform.new(a00,a01,a02,a10,a11,a12,a20,a21,a22)","text":"Construct a transform from a 3x3 matrix a00 - Element (0, 0) of the matrix a01 - Element (0, 1) of the matrix a02 - Element (0, 2) of the matrix a10 - Element (1, 0) of the matrix a11 - Element (1, 1) of the matrix a12 - Element (1, 2) of the matrix a20 - Element (2, 0) of the matrix a21 - Element (2, 1) of the matrix a22 - Element (2, 2) of the matrix [ View source ]","title":".new"},{"location":"api/SF/Transform.html#methods","text":"","title":"Methods"},{"location":"api/SF/Transform.html#SF::Transform#!=(right)","text":"Overload of binary operator != to compare two transforms This call is equivalent to !(left == right). left - Left operand (the first transform) right - Right operand (the second transform) Returns: true if the transforms are not equal, false otherwise [ View source ]","title":"#!="},{"location":"api/SF/Transform.html#SF::Transform#*(right)","text":"Overload of binary operator * to transform a point This call is equivalent to calling left.transform_point(right). left - Left operand (the transform) right - Right operand (the point to transform) Returns: New transformed point [ View source ]","title":"#*"},{"location":"api/SF/Transform.html#SF::Transform#*(right)","text":"Overload of binary operator * to combine two transforms This call is equivalent to calling Transform(left).combine(right). left - Left operand (the first transform) right - Right operand (the second transform) Returns: New combined transform [ View source ]","title":"#*"},{"location":"api/SF/Transform.html#SF::Transform#==(right)","text":"Overload of binary operator == to compare two transforms Performs an element-wise comparison of the elements of the left transform with the elements of the right transform. left - Left operand (the first transform) right - Right operand (the second transform) Returns: true if the transforms are equal, false otherwise [ View source ]","title":"#=="},{"location":"api/SF/Transform.html#SF::Transform#combine(transform)","text":"Combine the current transform with another one The result is a transform that is equivalent to applying this followed by transform.* Mathematically, it is equivalent to a matrix multiplication. transform - Transform to combine with this transform Returns: Reference to *this [ View source ]","title":"#combine"},{"location":"api/SF/Transform.html#SF::Transform#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Transform.html#SF::Transform#inspect(io)","text":"[ View source ]","title":"#inspect"},{"location":"api/SF/Transform.html#SF::Transform#inverse()","text":"Return the inverse of the transform If the inverse cannot be computed, an identity transform is returned. Returns: A new transform which is the inverse of self [ View source ]","title":"#inverse"},{"location":"api/SF/Transform.html#SF::Transform#matrix()","text":"Return the transform as a 4x4 matrix This function returns a pointer to an array of 16 floats containing the transform elements as a 4x4 matrix, which is directly compatible with OpenGL functions. transform = ... glLoadMatrixf ( transform . matrix ()) Returns: Pointer to a 4x4 matrix [ View source ]","title":"#matrix"},{"location":"api/SF/Transform.html#SF::Transform#rotate(angle,center)","text":"Combine the current transform with a rotation The center of rotation is provided for convenience as a second argument, so that you can build rotations around arbitrary points more easily (and efficiently) than the usual translate(-center).rotate(angle).translate(center). This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . rotate ( 90 , SF . vector2f ( 8 , 3 )) . translate ( SF . vector2f ( 50 , 20 )) angle - Rotation angle, in degrees center - Center of rotation Returns: Reference to *this See also: translate , scale [ View source ]","title":"#rotate"},{"location":"api/SF/Transform.html#SF::Transform#scale(scale_x,scale_y,center_x,center_y)","text":"Combine the current transform with a scaling The center of scaling is provided for convenience as a second argument, so that you can build scaling around arbitrary points more easily (and efficiently) than the usual translate(-center).scale(factors).translate(center). This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . scale ( 2 , 1 , 8 , 3 ) . rotate ( 45 ) scale_x - Scaling factor on X axis scale_y - Scaling factor on Y axis center_x - X coordinate of the center of scaling center_y - Y coordinate of the center of scaling Returns: Reference to *this See also: translate , rotate [ View source ]","title":"#scale"},{"location":"api/SF/Transform.html#SF::Transform#transform_point(point)","text":"Transform a 2D point point - Point to transform Returns: Transformed point [ View source ]","title":"#transform_point"},{"location":"api/SF/Transform.html#SF::Transform#transform_rect(rectangle)","text":"Transform a rectangle Since SFML doesn't provide support for oriented rectangles, the result of this function is always an axis-aligned rectangle. Which means that if the transform contains a rotation, the bounding rectangle of the transformed rectangle is returned. rectangle - Rectangle to transform Returns: Transformed rectangle [ View source ]","title":"#transform_rect"},{"location":"api/SF/Transform.html#SF::Transform#translate(offset)","text":"Combine the current transform with a translation This function returns a reference to *this, so that calls can be chained. transform = SF :: Transform . new transform . translate ( SF . vector2f ( 100 , 200 )) . rotate ( 45 ) offset - Translation offset to apply Returns: Reference to *this See also: rotate , scale [ View source ]","title":"#translate"},{"location":"api/SF/Transformable.html","text":"class SF::Transformable inherits Reference # Decomposed transform defined by a position, a rotation and a scale This class is provided for convenience, on top of SF::Transform . SF::Transform , as a low-level class, offers a great level of flexibility but it is not always convenient to manage. Indeed, one can easily combine any kind of operation, such as a translation followed by a rotation followed by a scaling, but once the result transform is built, there's no way to go backward and, let's say, change only the rotation without modifying the translation and scaling. The entire transform must be recomputed, which means that you need to retrieve the initial translation and scale factors as well, and combine them the same way you did before updating the rotation. This is a tedious operation, and it requires to store all the individual components of the final transform. That's exactly what SF::Transformable was written for: it hides these variables and the composed transform behind an easy to use interface. You can set or get any of the individual components without worrying about the others. It also provides the composed transform (as a SF::Transform ), and keeps it up-to-date. In addition to the position, rotation and scale, SF::Transformable provides an \"origin\" component, which represents the local origin of the three other components. Let's take an example with a 10x10 pixels sprite. By default, the sprite is positioned/rotated/scaled relatively to its top-left corner, because it is the local point (0, 0). But if we change the origin to be (5, 5), the sprite will be positioned/rotated/scaled around its center instead. And if we set the origin to (10, 10), it will be transformed around its bottom-right corner. To keep the SF::Transformable class simple, there's only one origin for all the components. You cannot position the sprite relatively to its top-left corner while rotating it around its center, for example. To do such things, use SF::Transform directly. SF::Transformable can be used as a base class. It is often combined with SF::Drawable -- that's what SFML's sprites, texts and shapes do. class MyEntity < SF :: Transformable include SF :: Drawable def draw ( target , states ) states . transform *= self . transform target . draw ( ... , states ) end end entity = MyEntity . new entity . position = { 10 , 20 } entity . rotation = 45 window . draw entity It can also be used as a member, if you don't want to use its API directly (because you don't need all its functions, or you have different naming conventions for example). class MyEntity @transform : SF :: Transformable forward_missing_to @transform end A note on coordinates and undistorted rendering: By default, SFML (or more exactly, OpenGL) may interpolate drawable objects such as sprites or texts when rendering. While this allows transitions like slow movements or rotations to appear smoothly, it can lead to unwanted results in some cases, for example blurred or distorted objects. In order to render a SF::Drawable object pixel-perfectly, make sure the involved coordinates allow a 1:1 mapping of pixels in the window to texels (pixels in the texture). More specifically, this means: The object's position, origin and scale have no fractional part The object's and the view's rotation are a multiple of 90 degrees The view's center and size have no fractional part See also: SF::Transform Direct known subclasses # SF::Shape SF::Sprite SF::Text Class methods # .new # Default constructor [ View source ] Methods # #dup : Transformable # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Virtual destructor [ View source ] #inverse_transform : Transform # get the inverse of the combined transform of the object Returns: Inverse of the combined transformations applied to the object See also: transform [ View source ] #move ( offset : Vector2 | Tuple ) # Move the object by a given offset This function adds to the current position of the object, unlike position= which overwrites it. Thus, it is equivalent to the following code: object . position += offset offset - Offset See also: position= [ View source ] #move ( offset_x : Number , offset_y : Number ) # Move the object by a given offset This function adds to the current position of the object, unlike position= which overwrites it. Thus, it is equivalent to the following code: pos = object . position object . set_position ( pos . x + offset_x , pos . y + offset_y ) offset_x - X offset offset_y - Y offset See also: position= [ View source ] #origin : Vector2f # get the local origin of the object Returns: Current origin See also: origin= [ View source ] #origin= ( origin : Vector2 | Tuple ) # set the local origin of the object The origin of an object defines the center point for all transformations (position, scale, rotation). The coordinates of this point must be relative to the top-left corner of the object, and ignore all transformations (position, scale, rotation). The default origin of a transformable object is (0, 0). origin - New origin See also: origin [ View source ] #position : Vector2f # get the position of the object Returns: Current position See also: position= [ View source ] #position= ( position : Vector2 | Tuple ) # set the position of the object This function completely overwrites the previous position. See the move function to apply an offset based on the previous position instead. The default position of a transformable object is (0, 0). position - New position See also: move , position [ View source ] #rotate ( angle : Number ) # Rotate the object This function adds to the current rotation of the object, unlike rotation= which overwrites it. Thus, it is equivalent to the following code: object . rotation += angle angle - Angle of rotation, in degrees [ View source ] #rotation : Float32 # get the orientation of the object The rotation is always in the range 0.0 ... 360.0 Returns: Current rotation, in degrees See also: rotation= [ View source ] #rotation= ( angle : Number ) # set the orientation of the object This function completely overwrites the previous rotation. See the rotate function to add an angle based on the previous rotation instead. The default rotation of a transformable object is 0. angle - New rotation, in degrees See also: rotate , rotation [ View source ] #scale : Vector2f # get the current scale of the object Returns: Current scale factors See also: scale= [ View source ] #scale ( factor : Vector2 | Tuple ) # Scale the object This function multiplies the current scale of the object, unlike scale= which overwrites it. Thus, it is equivalent to the following code: scale = object . scale object . scale = { scale . x * factor . x , scale . y * factor . y } factor - Scale factors See also: scale= [ View source ] #scale ( factor_x : Number , factor_y : Number ) # Scale the object This function multiplies the current scale of the object, unlike scale= which overwrites it. Thus, it is equivalent to the following code: scale = object . scale object . set_scale ( scale . x * factor_x , scale . y * factor_y ) factor_x - Horizontal scale factor factor_y - Vertical scale factor See also: scale= [ View source ] #scale= ( factors : Vector2 | Tuple ) # set the scale factors of the object This function completely overwrites the previous scale. See the scale function to add a factor based on the previous scale instead. The default scale of a transformable object is (1, 1). factors - New scale factors See also: scale , scale [ View source ] #set_origin ( x : Number , y : Number ) # set the local origin of the object The origin of an object defines the center point for all transformations (position, scale, rotation). The coordinates of this point must be relative to the top-left corner of the object, and ignore all transformations (position, scale, rotation). The default origin of a transformable object is (0, 0). x - X coordinate of the new origin y - Y coordinate of the new origin See also: origin [ View source ] #set_position ( x : Number , y : Number ) # set the position of the object This function completely overwrites the previous position. See the move function to apply an offset based on the previous position instead. The default position of a transformable object is (0, 0). x - X coordinate of the new position y - Y coordinate of the new position See also: move , position [ View source ] #set_scale ( factor_x : Number , factor_y : Number ) # set the scale factors of the object This function completely overwrites the previous scale. See the scale function to add a factor based on the previous scale instead. The default scale of a transformable object is (1, 1). factor_x - New horizontal scale factor factor_y - New vertical scale factor See also: scale , scale [ View source ] #transform : Transform # get the combined transform of the object Returns: Transform combining the position/rotation/scale/origin of the object See also: inverse_transform [ View source ]","title":"Transformable"},{"location":"api/SF/Transformable.html#SF::Transformable","text":"Decomposed transform defined by a position, a rotation and a scale This class is provided for convenience, on top of SF::Transform . SF::Transform , as a low-level class, offers a great level of flexibility but it is not always convenient to manage. Indeed, one can easily combine any kind of operation, such as a translation followed by a rotation followed by a scaling, but once the result transform is built, there's no way to go backward and, let's say, change only the rotation without modifying the translation and scaling. The entire transform must be recomputed, which means that you need to retrieve the initial translation and scale factors as well, and combine them the same way you did before updating the rotation. This is a tedious operation, and it requires to store all the individual components of the final transform. That's exactly what SF::Transformable was written for: it hides these variables and the composed transform behind an easy to use interface. You can set or get any of the individual components without worrying about the others. It also provides the composed transform (as a SF::Transform ), and keeps it up-to-date. In addition to the position, rotation and scale, SF::Transformable provides an \"origin\" component, which represents the local origin of the three other components. Let's take an example with a 10x10 pixels sprite. By default, the sprite is positioned/rotated/scaled relatively to its top-left corner, because it is the local point (0, 0). But if we change the origin to be (5, 5), the sprite will be positioned/rotated/scaled around its center instead. And if we set the origin to (10, 10), it will be transformed around its bottom-right corner. To keep the SF::Transformable class simple, there's only one origin for all the components. You cannot position the sprite relatively to its top-left corner while rotating it around its center, for example. To do such things, use SF::Transform directly. SF::Transformable can be used as a base class. It is often combined with SF::Drawable -- that's what SFML's sprites, texts and shapes do. class MyEntity < SF :: Transformable include SF :: Drawable def draw ( target , states ) states . transform *= self . transform target . draw ( ... , states ) end end entity = MyEntity . new entity . position = { 10 , 20 } entity . rotation = 45 window . draw entity It can also be used as a member, if you don't want to use its API directly (because you don't need all its functions, or you have different naming conventions for example). class MyEntity @transform : SF :: Transformable forward_missing_to @transform end A note on coordinates and undistorted rendering: By default, SFML (or more exactly, OpenGL) may interpolate drawable objects such as sprites or texts when rendering. While this allows transitions like slow movements or rotations to appear smoothly, it can lead to unwanted results in some cases, for example blurred or distorted objects. In order to render a SF::Drawable object pixel-perfectly, make sure the involved coordinates allow a 1:1 mapping of pixels in the window to texels (pixels in the texture). More specifically, this means: The object's position, origin and scale have no fractional part The object's and the view's rotation are a multiple of 90 degrees The view's center and size have no fractional part See also: SF::Transform","title":"Transformable"},{"location":"api/SF/Transformable.html#direct-known-subclasses","text":"SF::Shape SF::Sprite SF::Text","title":"Direct known subclasses"},{"location":"api/SF/Transformable.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Transformable.html#SF::Transformable.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/Transformable.html#methods","text":"","title":"Methods"},{"location":"api/SF/Transformable.html#SF::Transformable#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Transformable.html#SF::Transformable#finalize()","text":"Virtual destructor [ View source ]","title":"#finalize"},{"location":"api/SF/Transformable.html#SF::Transformable#inverse_transform()","text":"get the inverse of the combined transform of the object Returns: Inverse of the combined transformations applied to the object See also: transform [ View source ]","title":"#inverse_transform"},{"location":"api/SF/Transformable.html#SF::Transformable#move(offset)","text":"Move the object by a given offset This function adds to the current position of the object, unlike position= which overwrites it. Thus, it is equivalent to the following code: object . position += offset offset - Offset See also: position= [ View source ]","title":"#move"},{"location":"api/SF/Transformable.html#SF::Transformable#origin()","text":"get the local origin of the object Returns: Current origin See also: origin= [ View source ]","title":"#origin"},{"location":"api/SF/Transformable.html#SF::Transformable#origin=(origin)","text":"set the local origin of the object The origin of an object defines the center point for all transformations (position, scale, rotation). The coordinates of this point must be relative to the top-left corner of the object, and ignore all transformations (position, scale, rotation). The default origin of a transformable object is (0, 0). origin - New origin See also: origin [ View source ]","title":"#origin="},{"location":"api/SF/Transformable.html#SF::Transformable#position()","text":"get the position of the object Returns: Current position See also: position= [ View source ]","title":"#position"},{"location":"api/SF/Transformable.html#SF::Transformable#position=(position)","text":"set the position of the object This function completely overwrites the previous position. See the move function to apply an offset based on the previous position instead. The default position of a transformable object is (0, 0). position - New position See also: move , position [ View source ]","title":"#position="},{"location":"api/SF/Transformable.html#SF::Transformable#rotate(angle)","text":"Rotate the object This function adds to the current rotation of the object, unlike rotation= which overwrites it. Thus, it is equivalent to the following code: object . rotation += angle angle - Angle of rotation, in degrees [ View source ]","title":"#rotate"},{"location":"api/SF/Transformable.html#SF::Transformable#rotation()","text":"get the orientation of the object The rotation is always in the range 0.0 ... 360.0 Returns: Current rotation, in degrees See also: rotation= [ View source ]","title":"#rotation"},{"location":"api/SF/Transformable.html#SF::Transformable#rotation=(angle)","text":"set the orientation of the object This function completely overwrites the previous rotation. See the rotate function to add an angle based on the previous rotation instead. The default rotation of a transformable object is 0. angle - New rotation, in degrees See also: rotate , rotation [ View source ]","title":"#rotation="},{"location":"api/SF/Transformable.html#SF::Transformable#scale()","text":"get the current scale of the object Returns: Current scale factors See also: scale= [ View source ]","title":"#scale"},{"location":"api/SF/Transformable.html#SF::Transformable#scale=(factors)","text":"set the scale factors of the object This function completely overwrites the previous scale. See the scale function to add a factor based on the previous scale instead. The default scale of a transformable object is (1, 1). factors - New scale factors See also: scale , scale [ View source ]","title":"#scale="},{"location":"api/SF/Transformable.html#SF::Transformable#set_origin(x,y)","text":"set the local origin of the object The origin of an object defines the center point for all transformations (position, scale, rotation). The coordinates of this point must be relative to the top-left corner of the object, and ignore all transformations (position, scale, rotation). The default origin of a transformable object is (0, 0). x - X coordinate of the new origin y - Y coordinate of the new origin See also: origin [ View source ]","title":"#set_origin"},{"location":"api/SF/Transformable.html#SF::Transformable#set_position(x,y)","text":"set the position of the object This function completely overwrites the previous position. See the move function to apply an offset based on the previous position instead. The default position of a transformable object is (0, 0). x - X coordinate of the new position y - Y coordinate of the new position See also: move , position [ View source ]","title":"#set_position"},{"location":"api/SF/Transformable.html#SF::Transformable#set_scale(factor_x,factor_y)","text":"set the scale factors of the object This function completely overwrites the previous scale. See the scale function to add a factor based on the previous scale instead. The default scale of a transformable object is (1, 1). factor_x - New horizontal scale factor factor_y - New vertical scale factor See also: scale , scale [ View source ]","title":"#set_scale"},{"location":"api/SF/Transformable.html#SF::Transformable#transform()","text":"get the combined transform of the object Returns: Transform combining the position/rotation/scale/origin of the object See also: inverse_transform [ View source ]","title":"#transform"},{"location":"api/SF/UdpSocket.html","text":"class SF::UdpSocket inherits SF::Socket # Specialized socket using the UDP protocol A UDP socket is a connectionless socket. Instead of connecting once to a remote host, like TCP sockets, it can send to and receive from any host at any time. It is a datagram protocol: bounded blocks of data (datagrams) are transfered over the network rather than a continuous stream of data (TCP). Therefore, one call to send will always match one call to receive (if the datagram is not lost), with the same data that was sent. The UDP protocol is lightweight but unreliable. Unreliable means that datagrams may be duplicated, be lost or arrive reordered. However, if a datagram arrives, its data is guaranteed to be valid. UDP is generally used for real-time communication (audio or video streaming, real-time games, etc.) where speed is crucial and lost data doesn't matter much. Sending and receiving data can use either the low-level or the high-level functions. The low-level functions process a raw sequence of bytes, whereas the high-level interface uses packets (see SF::Packet ), which are easier to use and provide more safety regarding the data that is exchanged. You can look at the SF::Packet class to get more details about how they work. It is important to note that UdpSocket is unable to send datagrams bigger than MaxDatagramSize. In this case, it returns an error and doesn't send anything. This applies to both raw data and packets. Indeed, even packets are unable to split and recompose data, due to the unreliability of the protocol (dropped, mixed or duplicated datagrams may lead to a big mess when trying to recompose a packet). If the socket is bound to a port, it is automatically unbound from it when the socket is destroyed. However, you can unbind the socket explicitly with the Unbind function if necessary, to stop receiving messages or make the port available for other sockets. Usage example: # ----- The client ----- # Create a socket and bind it to the port 55001 socket = SF :: UdpSocket . new socket . bind ( 55001 ) # Send a message to 192.168.1.50 on port 55002 message = \"Hi, I am #{ SF :: IpAddress . local_address } \" socket . send ( message . to_slice , \"192.168.1.50\" , 55002 ) # Receive an answer (most likely from 192.168.1.50, but could be anyone else) buffer = Slice ( UInt8 ) . new ( 1024 ) status , received , sender , port = socket . receive ( buffer ) puts \" #{ sender } said: #{ buffer } \" # ----- The server ----- # Create a socket and bind it to the port 55002 socket = SF :: UdpSocket . new socket . bind ( 55002 ) # Receive a message from anyone buffer = Slice ( UInt8 ) . new ( 1024 ) status , received , sender , port = socket . receive ( buffer ) puts \" #{ sender } said: #{ buffer } \" # Send an answer message = \"Welcome #{ sender } \" socket . send ( message . to_slice , sender , port ) See also: SF::Socket , SF::TcpSocket , SF::Packet Constants # MaxDatagramSize # The maximum number of bytes that can be sent in a single UDP datagram Class methods # .new # Default constructor [ View source ] Methods # #bind ( port : Int , address : IpAddress = IpAddress :: Any ) : Socket :: Status # Bind the socket to a specific port Binding the socket to a port is necessary for being able to receive data on that port. You can use the special value Socket::AnyPort to tell the system to automatically pick an available port, and then call local_port to retrieve the chosen port. Since the socket can only be bound to a single port at any given moment, if it is already bound when this function is called, it will be unbound from the previous port before being bound to the new one. port - Port to bind the socket to address - Address of the interface to bind to Returns: Status code See also: unbind , local_port [ View source ] #finalize # Destructor [ View source ] #local_port : UInt16 # Get the port to which the socket is bound locally If the socket is not bound to a port, this function returns 0. Returns: Port to which the socket is bound See also: bind [ View source ] #receive ( data : Slice ) : Tuple ( Socket :: Status , Int32 , IpAddress , UInt16 ) # Receive raw data from a remote peer In blocking mode, this function will wait until some bytes are actually received. Be careful to use a buffer which is large enough for the data that you intend to receive, if it is too small then an error will be returned and all the data will be lost. data - The slice to fill with the received bytes Returns: Status code The actual number of bytes received Address of the peer that sent the data Port of the peer that sent the data See also: send [ View source ] #receive ( packet : Packet ) : Tuple ( Socket :: Status , IpAddress , UInt16 ) # Receive a formatted packet of data from a remote peer In blocking mode, this function will wait until the whole packet has been received. packet - Packet to fill with the received data Returns: Status code Address of the peer that sent the data Port of the peer that sent the data See also: send [ View source ] #send ( data : Slice , remote_address : IpAddress , remote_port : Int ) : Socket :: Status # Send raw data to a remote peer Make sure that data size is not greater than UdpSocket::MaxDatagramSize , otherwise this function will fail and no data will be sent. data - Slice containing the sequence of bytes to send remote_address - Address of the receiver remote_port - Port of the receiver to send the data to Returns: Status code See also: receive [ View source ] #send ( packet : Packet , remote_address : IpAddress , remote_port : Int ) : Socket :: Status # Send a formatted packet of data to a remote peer Make sure that the packet size is not greater than UdpSocket::MaxDatagramSize, otherwise this function will fail and no data will be sent. packet - Packet to send remote_address - Address of the receiver remote_port - Port of the receiver to send the data to Returns: Status code See also: receive [ View source ] #unbind # Unbind the socket from the local port to which it is bound The port that the socket was previously bound to is immediately made available to the operating system after this function is called. This means that a subsequent call to bind() will be able to re-bind the port if no other process has done so in the mean time. If the socket is not bound to a port, this function has no effect. See also: bind [ View source ]","title":"UdpSocket"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket","text":"Specialized socket using the UDP protocol A UDP socket is a connectionless socket. Instead of connecting once to a remote host, like TCP sockets, it can send to and receive from any host at any time. It is a datagram protocol: bounded blocks of data (datagrams) are transfered over the network rather than a continuous stream of data (TCP). Therefore, one call to send will always match one call to receive (if the datagram is not lost), with the same data that was sent. The UDP protocol is lightweight but unreliable. Unreliable means that datagrams may be duplicated, be lost or arrive reordered. However, if a datagram arrives, its data is guaranteed to be valid. UDP is generally used for real-time communication (audio or video streaming, real-time games, etc.) where speed is crucial and lost data doesn't matter much. Sending and receiving data can use either the low-level or the high-level functions. The low-level functions process a raw sequence of bytes, whereas the high-level interface uses packets (see SF::Packet ), which are easier to use and provide more safety regarding the data that is exchanged. You can look at the SF::Packet class to get more details about how they work. It is important to note that UdpSocket is unable to send datagrams bigger than MaxDatagramSize. In this case, it returns an error and doesn't send anything. This applies to both raw data and packets. Indeed, even packets are unable to split and recompose data, due to the unreliability of the protocol (dropped, mixed or duplicated datagrams may lead to a big mess when trying to recompose a packet). If the socket is bound to a port, it is automatically unbound from it when the socket is destroyed. However, you can unbind the socket explicitly with the Unbind function if necessary, to stop receiving messages or make the port available for other sockets. Usage example: # ----- The client ----- # Create a socket and bind it to the port 55001 socket = SF :: UdpSocket . new socket . bind ( 55001 ) # Send a message to 192.168.1.50 on port 55002 message = \"Hi, I am #{ SF :: IpAddress . local_address } \" socket . send ( message . to_slice , \"192.168.1.50\" , 55002 ) # Receive an answer (most likely from 192.168.1.50, but could be anyone else) buffer = Slice ( UInt8 ) . new ( 1024 ) status , received , sender , port = socket . receive ( buffer ) puts \" #{ sender } said: #{ buffer } \" # ----- The server ----- # Create a socket and bind it to the port 55002 socket = SF :: UdpSocket . new socket . bind ( 55002 ) # Receive a message from anyone buffer = Slice ( UInt8 ) . new ( 1024 ) status , received , sender , port = socket . receive ( buffer ) puts \" #{ sender } said: #{ buffer } \" # Send an answer message = \"Welcome #{ sender } \" socket . send ( message . to_slice , sender , port ) See also: SF::Socket , SF::TcpSocket , SF::Packet","title":"UdpSocket"},{"location":"api/SF/UdpSocket.html#constants","text":"","title":"Constants"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket::MaxDatagramSize","text":"The maximum number of bytes that can be sent in a single UDP datagram","title":"MaxDatagramSize"},{"location":"api/SF/UdpSocket.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket.new()","text":"Default constructor [ View source ]","title":".new"},{"location":"api/SF/UdpSocket.html#methods","text":"","title":"Methods"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket#bind(port,address)","text":"Bind the socket to a specific port Binding the socket to a port is necessary for being able to receive data on that port. You can use the special value Socket::AnyPort to tell the system to automatically pick an available port, and then call local_port to retrieve the chosen port. Since the socket can only be bound to a single port at any given moment, if it is already bound when this function is called, it will be unbound from the previous port before being bound to the new one. port - Port to bind the socket to address - Address of the interface to bind to Returns: Status code See also: unbind , local_port [ View source ]","title":"#bind"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket#local_port()","text":"Get the port to which the socket is bound locally If the socket is not bound to a port, this function returns 0. Returns: Port to which the socket is bound See also: bind [ View source ]","title":"#local_port"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket#receive(data)","text":"Receive raw data from a remote peer In blocking mode, this function will wait until some bytes are actually received. Be careful to use a buffer which is large enough for the data that you intend to receive, if it is too small then an error will be returned and all the data will be lost. data - The slice to fill with the received bytes Returns: Status code The actual number of bytes received Address of the peer that sent the data Port of the peer that sent the data See also: send [ View source ]","title":"#receive"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket#send(data,remote_address,remote_port)","text":"Send raw data to a remote peer Make sure that data size is not greater than UdpSocket::MaxDatagramSize , otherwise this function will fail and no data will be sent. data - Slice containing the sequence of bytes to send remote_address - Address of the receiver remote_port - Port of the receiver to send the data to Returns: Status code See also: receive [ View source ]","title":"#send"},{"location":"api/SF/UdpSocket.html#SF::UdpSocket#unbind()","text":"Unbind the socket from the local port to which it is bound The port that the socket was previously bound to is immediately made available to the operating system after this function is called. This means that a subsequent call to bind() will be able to re-bind the port if no other process has done so in the mean time. If the socket is not bound to a port, this function has no effect. See also: bind [ View source ]","title":"#unbind"},{"location":"api/SF/Vector2.html","text":"struct SF::Vector2(T) inherits Struct # Utility generic struct for manipulating 2-dimensional vectors SF::Vector2 is a simple struct that defines a mathematical vector with two coordinates (x and y). It can be used to represent anything that has two dimensions: a size, a point, a velocity, etc. The generic parameter T is the type of the coordinates. It can be any type that supports arithmetic operations (+, -, /, *) and comparisons (==, !=), for example Int or Float . You generally don't have to care about the generic form, the most common specializations have special aliases: SF::Vector2(Float32) is SF::Vector2f SF::Vector2(Int32) is SF::Vector2i See also: SF.vector2f , SF.vector2i . The SF::Vector2 struct has a small and simple interface, its x and y members can be accessed directly and it contains no mathematical function like dot product, cross product, length, etc. Usage example: v1 = SF . vector2f ( 16.5 , 24 ) v1 . x = 18.2_f32 y = v1 . y v2 = v1 * 5 v3 = v1 + v2 different = ( v2 != v3 ) Note: for 3-dimensional vectors, see SF::Vector3 . Included modules # Enumerable Class methods # .new ( x : T , y : T ) # Construct the vector from its coordinates. [ View source ] .new # Default constructor: equivalent to new(0, 0) [ View source ] Methods # #* ( n : Number ) # Memberwise multiplication by a scalar [ View source ] #* ( other ) # Memberwise multiplication of two vectors [ View source ] #+ ( other ) # Memberwise addition of two vectors [ View source ] #- ( other ) # Memberwise subtraction of two vectors [ View source ] #- # Memberwise opposite of the vector [ View source ] #/ ( n : Number ) # Memberwise division by a scalar [ View source ] #== ( other : Vector2 ) # Returns true if both corresponding coordinates of two vectors are equal [ View source ] #[] ( i : Int ) : T # Get a coordinate by its index: 0 is x , 1 is y . Raises IndexError for other indices. [ View source ] #each # Yields x , then y [ View source ] #size : Int32 # Returns 2 [ View source ] #x : T # The x coordinate [ View source ] #x= ( x : T ) # The x coordinate [ View source ] #y : T # The y coordinate [ View source ] #y= ( y : T ) # The y coordinate [ View source ]","title":"Vector2"},{"location":"api/SF/Vector2.html#SF::Vector2","text":"Utility generic struct for manipulating 2-dimensional vectors SF::Vector2 is a simple struct that defines a mathematical vector with two coordinates (x and y). It can be used to represent anything that has two dimensions: a size, a point, a velocity, etc. The generic parameter T is the type of the coordinates. It can be any type that supports arithmetic operations (+, -, /, *) and comparisons (==, !=), for example Int or Float . You generally don't have to care about the generic form, the most common specializations have special aliases: SF::Vector2(Float32) is SF::Vector2f SF::Vector2(Int32) is SF::Vector2i See also: SF.vector2f , SF.vector2i . The SF::Vector2 struct has a small and simple interface, its x and y members can be accessed directly and it contains no mathematical function like dot product, cross product, length, etc. Usage example: v1 = SF . vector2f ( 16.5 , 24 ) v1 . x = 18.2_f32 y = v1 . y v2 = v1 * 5 v3 = v1 + v2 different = ( v2 != v3 ) Note: for 3-dimensional vectors, see SF::Vector3 .","title":"Vector2"},{"location":"api/SF/Vector2.html#included-modules","text":"Enumerable","title":"Included modules"},{"location":"api/SF/Vector2.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Vector2.html#SF::Vector2.new(x,y)","text":"Construct the vector from its coordinates. [ View source ]","title":".new"},{"location":"api/SF/Vector2.html#methods","text":"","title":"Methods"},{"location":"api/SF/Vector2.html#SF::Vector2#*(n)","text":"Memberwise multiplication by a scalar [ View source ]","title":"#*"},{"location":"api/SF/Vector2.html#SF::Vector2#+(other)","text":"Memberwise addition of two vectors [ View source ]","title":"#+"},{"location":"api/SF/Vector2.html#SF::Vector2#-(other)","text":"Memberwise subtraction of two vectors [ View source ]","title":"#-"},{"location":"api/SF/Vector2.html#SF::Vector2#/(n)","text":"Memberwise division by a scalar [ View source ]","title":"#/"},{"location":"api/SF/Vector2.html#SF::Vector2#==(other)","text":"Returns true if both corresponding coordinates of two vectors are equal [ View source ]","title":"#=="},{"location":"api/SF/Vector2.html#SF::Vector2#[](i)","text":"Get a coordinate by its index: 0 is x , 1 is y . Raises IndexError for other indices. [ View source ]","title":"#[]"},{"location":"api/SF/Vector2.html#SF::Vector2#each()","text":"Yields x , then y [ View source ]","title":"#each"},{"location":"api/SF/Vector2.html#SF::Vector2#size()","text":"Returns 2 [ View source ]","title":"#size"},{"location":"api/SF/Vector2.html#SF::Vector2#x()","text":"The x coordinate [ View source ]","title":"#x"},{"location":"api/SF/Vector2.html#SF::Vector2#x=(x)","text":"The x coordinate [ View source ]","title":"#x="},{"location":"api/SF/Vector2.html#SF::Vector2#y()","text":"The y coordinate [ View source ]","title":"#y"},{"location":"api/SF/Vector2.html#SF::Vector2#y=(y)","text":"The y coordinate [ View source ]","title":"#y="},{"location":"api/SF/Vector2f.html","text":"alias SF::Vector2f # Alias definition # SF :: Vector2 ( Float32 )","title":"Vector2f"},{"location":"api/SF/Vector2f.html#SF::Vector2f","text":"","title":"Vector2f"},{"location":"api/SF/Vector2f.html#alias-definition","text":"SF :: Vector2 ( Float32 )","title":"Alias definition"},{"location":"api/SF/Vector2i.html","text":"alias SF::Vector2i # Alias definition # SF :: Vector2 ( Int32 )","title":"Vector2i"},{"location":"api/SF/Vector2i.html#SF::Vector2i","text":"","title":"Vector2i"},{"location":"api/SF/Vector2i.html#alias-definition","text":"SF :: Vector2 ( Int32 )","title":"Alias definition"},{"location":"api/SF/Vector2u.html","text":"alias SF::Vector2u # Alias definition # SF :: Vector2 ( Int32 )","title":"Vector2u"},{"location":"api/SF/Vector2u.html#SF::Vector2u","text":"","title":"Vector2u"},{"location":"api/SF/Vector2u.html#alias-definition","text":"SF :: Vector2 ( Int32 )","title":"Alias definition"},{"location":"api/SF/Vector3.html","text":"struct SF::Vector3(T) inherits Struct # Utility generic struct for manipulating 2-dimensional vectors SF::Vector3 is a simple struct that defines a mathematical vector with three coordinates (x, y and z). It can be used to represent anything that has three dimensions: a size, a point, a velocity, etc. The generic parameter T is the type of the coordinates. It can be any type that supports arithmetic operations (+, -, /, *) and comparisons (==, !=), for example Int or Float . You generally don't have to care about the generic form, the most common specialization has a special alias: SF::Vector3(Float32) is SF::Vector3f The SF::Vector3 struct has a small and simple interface, its x , y , z members can be accessed directly and it contains no mathematical function like dot product, cross product, length, etc. Note: for 2-dimensional vectors, see SF::Vector2 . Included modules # Enumerable Class methods # .new ( x : T , y : T , z : T ) # Construct the vector from its coordinates. [ View source ] .new # Default constructor: equivalent to new(0, 0, 0) [ View source ] Methods # #* ( n : Number ) # Memberwise multiplication by a scalar [ View source ] #+ ( other ) # Memberwise addition of two vectors [ View source ] #- ( other ) # Memberwise subtraction of two vectors [ View source ] #- # Memberwise opposite of the vector [ View source ] #/ ( n : Number ) # Memberwise division by a scalar [ View source ] #== ( other : Vector3 ) # Returns true if all corresponding coordinates of two vectors are equal [ View source ] #[] ( i ) # Get a coordinate by its index: 0 is x , 1 is y , 2 is z . Raises IndexError for other indices. [ View source ] #each # Yields x , then y , then z [ View source ] #size # Returns 3 [ View source ] #x : T # The x coordinate [ View source ] #x= ( x : T ) # The x coordinate [ View source ] #y : T # The y coordinate [ View source ] #y= ( y : T ) # The y coordinate [ View source ] #z : T # The z coordinate [ View source ] #z= ( z : T ) # The z coordinate [ View source ]","title":"Vector3"},{"location":"api/SF/Vector3.html#SF::Vector3","text":"Utility generic struct for manipulating 2-dimensional vectors SF::Vector3 is a simple struct that defines a mathematical vector with three coordinates (x, y and z). It can be used to represent anything that has three dimensions: a size, a point, a velocity, etc. The generic parameter T is the type of the coordinates. It can be any type that supports arithmetic operations (+, -, /, *) and comparisons (==, !=), for example Int or Float . You generally don't have to care about the generic form, the most common specialization has a special alias: SF::Vector3(Float32) is SF::Vector3f The SF::Vector3 struct has a small and simple interface, its x , y , z members can be accessed directly and it contains no mathematical function like dot product, cross product, length, etc. Note: for 2-dimensional vectors, see SF::Vector2 .","title":"Vector3"},{"location":"api/SF/Vector3.html#included-modules","text":"Enumerable","title":"Included modules"},{"location":"api/SF/Vector3.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Vector3.html#SF::Vector3.new(x,y,z)","text":"Construct the vector from its coordinates. [ View source ]","title":".new"},{"location":"api/SF/Vector3.html#methods","text":"","title":"Methods"},{"location":"api/SF/Vector3.html#SF::Vector3#*(n)","text":"Memberwise multiplication by a scalar [ View source ]","title":"#*"},{"location":"api/SF/Vector3.html#SF::Vector3#+(other)","text":"Memberwise addition of two vectors [ View source ]","title":"#+"},{"location":"api/SF/Vector3.html#SF::Vector3#-(other)","text":"Memberwise subtraction of two vectors [ View source ]","title":"#-"},{"location":"api/SF/Vector3.html#SF::Vector3#/(n)","text":"Memberwise division by a scalar [ View source ]","title":"#/"},{"location":"api/SF/Vector3.html#SF::Vector3#==(other)","text":"Returns true if all corresponding coordinates of two vectors are equal [ View source ]","title":"#=="},{"location":"api/SF/Vector3.html#SF::Vector3#[](i)","text":"Get a coordinate by its index: 0 is x , 1 is y , 2 is z . Raises IndexError for other indices. [ View source ]","title":"#[]"},{"location":"api/SF/Vector3.html#SF::Vector3#each()","text":"Yields x , then y , then z [ View source ]","title":"#each"},{"location":"api/SF/Vector3.html#SF::Vector3#size()","text":"Returns 3 [ View source ]","title":"#size"},{"location":"api/SF/Vector3.html#SF::Vector3#x()","text":"The x coordinate [ View source ]","title":"#x"},{"location":"api/SF/Vector3.html#SF::Vector3#x=(x)","text":"The x coordinate [ View source ]","title":"#x="},{"location":"api/SF/Vector3.html#SF::Vector3#y()","text":"The y coordinate [ View source ]","title":"#y"},{"location":"api/SF/Vector3.html#SF::Vector3#y=(y)","text":"The y coordinate [ View source ]","title":"#y="},{"location":"api/SF/Vector3.html#SF::Vector3#z()","text":"The z coordinate [ View source ]","title":"#z"},{"location":"api/SF/Vector3.html#SF::Vector3#z=(z)","text":"The z coordinate [ View source ]","title":"#z="},{"location":"api/SF/Vector3f.html","text":"alias SF::Vector3f # Alias definition # SF :: Vector3 ( Float32 )","title":"Vector3f"},{"location":"api/SF/Vector3f.html#SF::Vector3f","text":"","title":"Vector3f"},{"location":"api/SF/Vector3f.html#alias-definition","text":"SF :: Vector3 ( Float32 )","title":"Alias definition"},{"location":"api/SF/Vertex.html","text":"struct SF::Vertex inherits Struct # Define a point with color and texture coordinates A vertex is an improved point. It has a position and other extra attributes that will be used for drawing: in SFML, vertices also have a color and a pair of texture coordinates. The vertex is the building block of drawing. Everything which is visible on screen is made of vertices. They are grouped as 2D primitives (triangles, quads, ...), and these primitives are grouped to create even more complex 2D entities such as sprites, texts, etc. If you use the graphical entities of SFML (sprite, text, shape) you won't have to deal with vertices directly. But if you want to define your own 2D entities, such as tiled maps or particle systems, using vertices will allow you to get maximum performances. Example: # define a 100x100 square, red, with a 10x10 texture mapped on it vertices = [ SF :: Vertex . new ( SF . vector2f ( 0 , 0 ), SF :: Color :: Red , SF . vector2f ( 0 , 0 )), SF :: Vertex . new ( SF . vector2f ( 0 , 100 ), SF :: Color :: Red , SF . vector2f ( 0 , 10 )), SF :: Vertex . new ( SF . vector2f ( 100 , 100 ), SF :: Color :: Red , SF . vector2f ( 10 , 10 )), SF :: Vertex . new ( SF . vector2f ( 100 , 0 ), SF :: Color :: Red , SF . vector2f ( 10 , 0 )), ] # draw it window . draw ( vertices , SF :: Quads ) Note: although texture coordinates are supposed to be an integer amount of pixels, their type is float because of some buggy graphics drivers that are not able to process integer coordinates correctly. See also: SF::VertexArray Class methods # .new ( position : Vector2 | Tuple , color : Color , tex_coords : Vector2 | Tuple ) # Construct the vertex from its position, color and texture coordinates position - Vertex position color - Vertex color tex_coords - Vertex texture coordinates [ View source ] .new ( position : Vector2 | Tuple , color : Color ) # Construct the vertex from its position and color The texture coordinates are (0, 0). position - Vertex position color - Vertex color [ View source ] .new ( position : Vector2 | Tuple , tex_coords : Vector2 | Tuple ) # Construct the vertex from its position and texture coordinates The vertex color is white. position - Vertex position tex_coords - Vertex texture coordinates [ View source ] .new ( position : Vector2 | Tuple ) # Construct the vertex from its position The vertex color is white and texture coordinates are (0, 0). position - Vertex position [ View source ] .new # Default constructor [ View source ] Methods # #color : Color # Color of the vertex [ View source ] #color= ( color : Color ) # [ View source ] #dup : Vertex # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #position : Vector2f # 2D position of the vertex [ View source ] #position= ( position : Vector2 | Tuple ) # [ View source ] #tex_coords : Vector2f # Coordinates of the texture's pixel to map to the vertex [ View source ] #tex_coords= ( tex_coords : Vector2 | Tuple ) # [ View source ]","title":"Vertex"},{"location":"api/SF/Vertex.html#SF::Vertex","text":"Define a point with color and texture coordinates A vertex is an improved point. It has a position and other extra attributes that will be used for drawing: in SFML, vertices also have a color and a pair of texture coordinates. The vertex is the building block of drawing. Everything which is visible on screen is made of vertices. They are grouped as 2D primitives (triangles, quads, ...), and these primitives are grouped to create even more complex 2D entities such as sprites, texts, etc. If you use the graphical entities of SFML (sprite, text, shape) you won't have to deal with vertices directly. But if you want to define your own 2D entities, such as tiled maps or particle systems, using vertices will allow you to get maximum performances. Example: # define a 100x100 square, red, with a 10x10 texture mapped on it vertices = [ SF :: Vertex . new ( SF . vector2f ( 0 , 0 ), SF :: Color :: Red , SF . vector2f ( 0 , 0 )), SF :: Vertex . new ( SF . vector2f ( 0 , 100 ), SF :: Color :: Red , SF . vector2f ( 0 , 10 )), SF :: Vertex . new ( SF . vector2f ( 100 , 100 ), SF :: Color :: Red , SF . vector2f ( 10 , 10 )), SF :: Vertex . new ( SF . vector2f ( 100 , 0 ), SF :: Color :: Red , SF . vector2f ( 10 , 0 )), ] # draw it window . draw ( vertices , SF :: Quads ) Note: although texture coordinates are supposed to be an integer amount of pixels, their type is float because of some buggy graphics drivers that are not able to process integer coordinates correctly. See also: SF::VertexArray","title":"Vertex"},{"location":"api/SF/Vertex.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Vertex.html#SF::Vertex.new(position,color,tex_coords)","text":"Construct the vertex from its position, color and texture coordinates position - Vertex position color - Vertex color tex_coords - Vertex texture coordinates [ View source ]","title":".new"},{"location":"api/SF/Vertex.html#methods","text":"","title":"Methods"},{"location":"api/SF/Vertex.html#SF::Vertex#color()","text":"Color of the vertex [ View source ]","title":"#color"},{"location":"api/SF/Vertex.html#SF::Vertex#color=(color)","text":"[ View source ]","title":"#color="},{"location":"api/SF/Vertex.html#SF::Vertex#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Vertex.html#SF::Vertex#position()","text":"2D position of the vertex [ View source ]","title":"#position"},{"location":"api/SF/Vertex.html#SF::Vertex#position=(position)","text":"[ View source ]","title":"#position="},{"location":"api/SF/Vertex.html#SF::Vertex#tex_coords()","text":"Coordinates of the texture's pixel to map to the vertex [ View source ]","title":"#tex_coords"},{"location":"api/SF/Vertex.html#SF::Vertex#tex_coords=(tex_coords)","text":"[ View source ]","title":"#tex_coords="},{"location":"api/SF/VertexArray.html","text":"class SF::VertexArray inherits Reference # Define a set of one or more 2D primitives SF::VertexArray is a very simple wrapper around a dynamic array of vertices and a primitives type. It includes SF::Drawable , but unlike other drawables it is not transformable. Example: lines = SF :: VertexArray . new ( SF :: LineStrip , 4 ) lines [ 0 ] = SF :: Vertex . new ( SF . vector2f ( 10 , 0 )) lines [ 1 ] = SF :: Vertex . new ( SF . vector2f ( 20 , 0 )) lines [ 2 ] = SF :: Vertex . new ( SF . vector2f ( 30 , 5 )) lines [ 3 ] = SF :: Vertex . new ( SF . vector2f ( 40 , 2 )) window . draw ( lines ) See also: SF::Vertex Included modules # SF::Drawable Class methods # .new ( type : PrimitiveType , vertex_count : Int = 0 ) # Construct the vertex array with a type and an initial number of vertices type - Type of primitives vertex_count - Initial number of vertices in the array [ View source ] .new # Default constructor Creates an empty vertex array. [ View source ] Methods # #[] ( index : Int ) : Vertex # Get the vertex by its index This method doesn't check index , it must be in range 0 ... vertex_count . The behavior is undefined otherwise. index - Index of the vertex to get Returns: The index-th vertex See also: vertex_count [ View source ] #[]= ( index : Int , value : Vertex ) # Set the vertex by its index This method doesn't check index , it must be in range 0 ... vertex_count . The behavior is undefined otherwise. index - Index of the vertex to set See also: vertex_count [ View source ] #append ( vertex : Vertex ) # Add a vertex to the array vertex - Vertex to add [ View source ] #bounds : FloatRect # Compute the bounding rectangle of the vertex array This function returns the minimal axis-aligned rectangle that contains all the vertices of the array. Returns: Bounding rectangle of the vertex array [ View source ] #clear # Clear the vertex array This function removes all the vertices from the array. It doesn't deallocate the corresponding memory, so that adding new vertices after clearing doesn't involve reallocating all the memory. [ View source ] #dup : VertexArray # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ] #primitive_type : PrimitiveType # Get the type of primitives drawn by the vertex array Returns: Primitive type [ View source ] #primitive_type= ( type : PrimitiveType ) # Set the type of primitives to draw This function defines how the vertices must be interpreted when it's time to draw them: As points As lines As triangles As quads The default primitive type is SF::Points . type - Type of primitive [ View source ] #resize ( vertex_count : Int ) # Resize the vertex array If vertex_count is greater than the current size, the previous vertices are kept and new (default-constructed) vertices are added. If vertex_count is less than the current size, existing vertices are removed from the array. vertex_count - New size of the array (number of vertices) [ View source ] #vertex_count : Int32 # Return the vertex count Returns: Number of vertices in the array [ View source ]","title":"VertexArray"},{"location":"api/SF/VertexArray.html#SF::VertexArray","text":"Define a set of one or more 2D primitives SF::VertexArray is a very simple wrapper around a dynamic array of vertices and a primitives type. It includes SF::Drawable , but unlike other drawables it is not transformable. Example: lines = SF :: VertexArray . new ( SF :: LineStrip , 4 ) lines [ 0 ] = SF :: Vertex . new ( SF . vector2f ( 10 , 0 )) lines [ 1 ] = SF :: Vertex . new ( SF . vector2f ( 20 , 0 )) lines [ 2 ] = SF :: Vertex . new ( SF . vector2f ( 30 , 5 )) lines [ 3 ] = SF :: Vertex . new ( SF . vector2f ( 40 , 2 )) window . draw ( lines ) See also: SF::Vertex","title":"VertexArray"},{"location":"api/SF/VertexArray.html#included-modules","text":"SF::Drawable","title":"Included modules"},{"location":"api/SF/VertexArray.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/VertexArray.html#SF::VertexArray.new(type,vertex_count)","text":"Construct the vertex array with a type and an initial number of vertices type - Type of primitives vertex_count - Initial number of vertices in the array [ View source ]","title":".new"},{"location":"api/SF/VertexArray.html#methods","text":"","title":"Methods"},{"location":"api/SF/VertexArray.html#SF::VertexArray#[](index)","text":"Get the vertex by its index This method doesn't check index , it must be in range 0 ... vertex_count . The behavior is undefined otherwise. index - Index of the vertex to get Returns: The index-th vertex See also: vertex_count [ View source ]","title":"#[]"},{"location":"api/SF/VertexArray.html#SF::VertexArray#[]=(index,value)","text":"Set the vertex by its index This method doesn't check index , it must be in range 0 ... vertex_count . The behavior is undefined otherwise. index - Index of the vertex to set See also: vertex_count [ View source ]","title":"#[]="},{"location":"api/SF/VertexArray.html#SF::VertexArray#append(vertex)","text":"Add a vertex to the array vertex - Vertex to add [ View source ]","title":"#append"},{"location":"api/SF/VertexArray.html#SF::VertexArray#bounds()","text":"Compute the bounding rectangle of the vertex array This function returns the minimal axis-aligned rectangle that contains all the vertices of the array. Returns: Bounding rectangle of the vertex array [ View source ]","title":"#bounds"},{"location":"api/SF/VertexArray.html#SF::VertexArray#clear()","text":"Clear the vertex array This function removes all the vertices from the array. It doesn't deallocate the corresponding memory, so that adding new vertices after clearing doesn't involve reallocating all the memory. [ View source ]","title":"#clear"},{"location":"api/SF/VertexArray.html#SF::VertexArray#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/VertexArray.html#SF::VertexArray#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/VertexArray.html#SF::VertexArray#primitive_type()","text":"Get the type of primitives drawn by the vertex array Returns: Primitive type [ View source ]","title":"#primitive_type"},{"location":"api/SF/VertexArray.html#SF::VertexArray#primitive_type=(type)","text":"Set the type of primitives to draw This function defines how the vertices must be interpreted when it's time to draw them: As points As lines As triangles As quads The default primitive type is SF::Points . type - Type of primitive [ View source ]","title":"#primitive_type="},{"location":"api/SF/VertexArray.html#SF::VertexArray#resize(vertex_count)","text":"Resize the vertex array If vertex_count is greater than the current size, the previous vertices are kept and new (default-constructed) vertices are added. If vertex_count is less than the current size, existing vertices are removed from the array. vertex_count - New size of the array (number of vertices) [ View source ]","title":"#resize"},{"location":"api/SF/VertexArray.html#SF::VertexArray#vertex_count()","text":"Return the vertex count Returns: Number of vertices in the array [ View source ]","title":"#vertex_count"},{"location":"api/SF/VertexBuffer.html","text":"class SF::VertexBuffer inherits Reference # Vertex buffer storage for one or more 2D primitives SF::VertexBuffer is a simple wrapper around a dynamic buffer of vertices and a primitives type. Unlike SF::VertexArray , the vertex data is stored in graphics memory. In situations where a large amount of vertex data would have to be transferred from system memory to graphics memory every frame, using SF::VertexBuffer can help. By using a SF::VertexBuffer , data that has not been changed between frames does not have to be re-transferred from system to graphics memory as would be the case with SF::VertexArray . If data transfer is a bottleneck, this can lead to performance gains. Using SF::VertexBuffer , the user also has the ability to only modify a portion of the buffer in graphics memory. This way, a large buffer can be allocated at the start of the application and only the applicable portions of it need to be updated during the course of the application. This allows the user to take full control of data transfers between system and graphics memory if they need to. In special cases, the user can make use of multiple threads to update vertex data in multiple distinct regions of the buffer simultaneously. This might make sense when e.g. the position of multiple objects has to be recalculated very frequently. The computation load can be spread across multiple threads as long as there are no other data dependencies. Simultaneous updates to the vertex buffer are not guaranteed to be carried out by the driver in any specific order. Updating the same region of the buffer from multiple threads will not cause undefined behaviour, however the final state of the buffer will be unpredictable. Simultaneous updates of distinct non-overlapping regions of the buffer are also not guaranteed to complete in a specific order. However, in this case the user can make sure to synchronize the writer threads at well-defined points in their code. The driver will make sure that all pending data transfers complete before the vertex buffer is sourced by the rendering pipeline. It inherits SF::Drawable , but unlike other drawables it is not transformable. Example: sf :: Vertex vertices [ 15 ]; ... sf :: VertexBuffer triangles ( sf :: Triangles ); triangles . create ( 15 ); triangles . update ( vertices ); ... window . draw ( triangles ); See also: SF::Vertex , SF::VertexArray Included modules # SF::Drawable SF::GlResource Class methods # .available? : Bool # Tell whether or not the system supports vertex buffers This function should always be called before using the vertex buffer features. If it returns false, then any attempt to use SF::VertexBuffer will fail. Returns: True if vertex buffers are supported, false otherwise [ View source ] .bind ( vertex_buffer : VertexBuffer? ) # Bind a vertex buffer for rendering This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix SF::VertexBuffer with OpenGL code. sf :: VertexBuffer vb1 , vb2 ; ... sf :: VertexBuffer :: bind ( & vb1 ); // draw OpenGL stuff that use vb1... sf :: VertexBuffer :: bind ( & vb2 ); // draw OpenGL stuff that use vb2... sf :: VertexBuffer :: bind ( NULL ); // draw OpenGL stuff that use no vertex buffer... vertex_buffer - Pointer to the vertex buffer to bind, can be null to use no vertex buffer [ View source ] .new ( type : PrimitiveType , usage : VertexBuffer :: Usage ) # Construct a VertexBuffer with a specific PrimitiveType and usage specifier Creates an empty vertex buffer and sets its primitive type to \\p type and usage to \\p usage. type - Type of primitive usage - Usage specifier [ View source ] .new ( type : PrimitiveType ) # Construct a VertexBuffer with a specific PrimitiveType Creates an empty vertex buffer and sets its primitive type to \\p type. type - Type of primitive [ View source ] .new ( usage : VertexBuffer :: Usage ) # Construct a VertexBuffer with a specific usage specifier Creates an empty vertex buffer and sets its usage to \\p usage. usage - Usage specifier [ View source ] .new # Default constructor Creates an empty vertex buffer. [ View source ] .new ( * args , ** kwargs ) : self # Shorthand for vertex_buffer = VertexBuffer.new; vertex_buffer.create(...); vertex_buffer Raises InitError on failure [ View source ] Methods # #create ( vertex_count : Int ) : Bool # Create the vertex buffer Creates the vertex buffer and allocates enough graphics memory to hold \\p vertex_count vertices. Any previously allocated memory is freed in the process. In order to deallocate previously allocated memory pass 0 as \\p vertex_count. Don't forget to recreate with a non-zero value when graphics memory should be allocated again. vertex_count - Number of vertices worth of memory to allocate Returns: True if creation was successful [ View source ] #dup : VertexBuffer # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # Destructor [ View source ] #native_handle : Int32 # Get the underlying OpenGL handle of the vertex buffer. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed. Returns: OpenGL handle of the vertex buffer or 0 if not yet created [ View source ] #primitive_type : PrimitiveType # Get the type of primitives drawn by the vertex buffer Returns: Primitive type [ View source ] #primitive_type= ( type : PrimitiveType ) # Set the type of primitives to draw This function defines how the vertices must be interpreted when it's time to draw them. The default primitive type is SF::Points . type - Type of primitive [ View source ] #swap ( right : VertexBuffer ) # Swap the contents of this vertex buffer with those of another right - Instance to swap with [ View source ] #update ( vertices : Array ( Vertex ) | Slice ( Vertex ), offset : Int ) : Bool # Update a part of the buffer from an array of vertices \\p offset is specified as the number of vertices to skip from the beginning of the buffer. If \\p offset is 0 and \\p vertex_count is equal to the size of the currently created buffer, its whole contents are replaced. If \\p offset is 0 and \\p vertex_count is greater than the size of the currently created buffer, a new buffer is created containing the vertex data. If \\p offset is 0 and \\p vertex_count is less than the size of the currently created buffer, only the corresponding region is updated. If \\p offset is not 0 and \\p offset + \\p vertex_count is greater than the size of the currently created buffer, the update fails. No additional check is performed on the size of the vertex array, passing invalid arguments will lead to undefined behavior. vertices - Array of vertices to copy to the buffer vertex_count - Number of vertices to copy offset - Offset in the buffer to copy to Returns: True if the update was successful [ View source ] #update ( vertices : Vertex ) : Bool # Update the whole buffer from an array of vertices The vertex array is assumed to have the same size as the created buffer. No additional check is performed on the size of the vertex array, passing invalid arguments will lead to undefined behavior. This function does nothing if vertices is null or if the buffer was not previously created. vertices - Array of vertices to copy to the buffer Returns: True if the update was successful [ View source ] #update ( vertex_buffer : VertexBuffer ) : Bool # Copy the contents of another buffer into this buffer vertex_buffer - Vertex buffer whose contents to copy into this vertex buffer Returns: True if the copy was successful [ View source ] #usage : VertexBuffer :: Usage # Get the usage specifier of this vertex buffer Returns: Usage specifier [ View source ] #usage= ( usage : VertexBuffer :: Usage ) # Set the usage specifier of this vertex buffer This function provides a hint about how this vertex buffer is going to be used in terms of data update frequency. After changing the usage specifier, the vertex buffer has to be updated with new data for the usage specifier to take effect. The default primitive type is SF::VertexBuffer::Stream . usage - Usage specifier [ View source ] #vertex_count : Int32 # Return the vertex count Returns: Number of vertices in the vertex buffer [ View source ]","title":"VertexBuffer"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer","text":"Vertex buffer storage for one or more 2D primitives SF::VertexBuffer is a simple wrapper around a dynamic buffer of vertices and a primitives type. Unlike SF::VertexArray , the vertex data is stored in graphics memory. In situations where a large amount of vertex data would have to be transferred from system memory to graphics memory every frame, using SF::VertexBuffer can help. By using a SF::VertexBuffer , data that has not been changed between frames does not have to be re-transferred from system to graphics memory as would be the case with SF::VertexArray . If data transfer is a bottleneck, this can lead to performance gains. Using SF::VertexBuffer , the user also has the ability to only modify a portion of the buffer in graphics memory. This way, a large buffer can be allocated at the start of the application and only the applicable portions of it need to be updated during the course of the application. This allows the user to take full control of data transfers between system and graphics memory if they need to. In special cases, the user can make use of multiple threads to update vertex data in multiple distinct regions of the buffer simultaneously. This might make sense when e.g. the position of multiple objects has to be recalculated very frequently. The computation load can be spread across multiple threads as long as there are no other data dependencies. Simultaneous updates to the vertex buffer are not guaranteed to be carried out by the driver in any specific order. Updating the same region of the buffer from multiple threads will not cause undefined behaviour, however the final state of the buffer will be unpredictable. Simultaneous updates of distinct non-overlapping regions of the buffer are also not guaranteed to complete in a specific order. However, in this case the user can make sure to synchronize the writer threads at well-defined points in their code. The driver will make sure that all pending data transfers complete before the vertex buffer is sourced by the rendering pipeline. It inherits SF::Drawable , but unlike other drawables it is not transformable. Example: sf :: Vertex vertices [ 15 ]; ... sf :: VertexBuffer triangles ( sf :: Triangles ); triangles . create ( 15 ); triangles . update ( vertices ); ... window . draw ( triangles ); See also: SF::Vertex , SF::VertexArray","title":"VertexBuffer"},{"location":"api/SF/VertexBuffer.html#included-modules","text":"SF::Drawable SF::GlResource","title":"Included modules"},{"location":"api/SF/VertexBuffer.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer.available?()","text":"Tell whether or not the system supports vertex buffers This function should always be called before using the vertex buffer features. If it returns false, then any attempt to use SF::VertexBuffer will fail. Returns: True if vertex buffers are supported, false otherwise [ View source ]","title":".available?"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer.bind(vertex_buffer)","text":"Bind a vertex buffer for rendering This function is not part of the graphics API, it mustn't be used when drawing SFML entities. It must be used only if you mix SF::VertexBuffer with OpenGL code. sf :: VertexBuffer vb1 , vb2 ; ... sf :: VertexBuffer :: bind ( & vb1 ); // draw OpenGL stuff that use vb1... sf :: VertexBuffer :: bind ( & vb2 ); // draw OpenGL stuff that use vb2... sf :: VertexBuffer :: bind ( NULL ); // draw OpenGL stuff that use no vertex buffer... vertex_buffer - Pointer to the vertex buffer to bind, can be null to use no vertex buffer [ View source ]","title":".bind"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer.new(type,usage)","text":"Construct a VertexBuffer with a specific PrimitiveType and usage specifier Creates an empty vertex buffer and sets its primitive type to \\p type and usage to \\p usage. type - Type of primitive usage - Usage specifier [ View source ]","title":".new"},{"location":"api/SF/VertexBuffer.html#methods","text":"","title":"Methods"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#create(vertex_count)","text":"Create the vertex buffer Creates the vertex buffer and allocates enough graphics memory to hold \\p vertex_count vertices. Any previously allocated memory is freed in the process. In order to deallocate previously allocated memory pass 0 as \\p vertex_count. Don't forget to recreate with a non-zero value when graphics memory should be allocated again. vertex_count - Number of vertices worth of memory to allocate Returns: True if creation was successful [ View source ]","title":"#create"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#finalize()","text":"Destructor [ View source ]","title":"#finalize"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#native_handle()","text":"Get the underlying OpenGL handle of the vertex buffer. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed. Returns: OpenGL handle of the vertex buffer or 0 if not yet created [ View source ]","title":"#native_handle"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#primitive_type()","text":"Get the type of primitives drawn by the vertex buffer Returns: Primitive type [ View source ]","title":"#primitive_type"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#primitive_type=(type)","text":"Set the type of primitives to draw This function defines how the vertices must be interpreted when it's time to draw them. The default primitive type is SF::Points . type - Type of primitive [ View source ]","title":"#primitive_type="},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#swap(right)","text":"Swap the contents of this vertex buffer with those of another right - Instance to swap with [ View source ]","title":"#swap"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#update(vertices,offset)","text":"Update a part of the buffer from an array of vertices \\p offset is specified as the number of vertices to skip from the beginning of the buffer. If \\p offset is 0 and \\p vertex_count is equal to the size of the currently created buffer, its whole contents are replaced. If \\p offset is 0 and \\p vertex_count is greater than the size of the currently created buffer, a new buffer is created containing the vertex data. If \\p offset is 0 and \\p vertex_count is less than the size of the currently created buffer, only the corresponding region is updated. If \\p offset is not 0 and \\p offset + \\p vertex_count is greater than the size of the currently created buffer, the update fails. No additional check is performed on the size of the vertex array, passing invalid arguments will lead to undefined behavior. vertices - Array of vertices to copy to the buffer vertex_count - Number of vertices to copy offset - Offset in the buffer to copy to Returns: True if the update was successful [ View source ]","title":"#update"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#usage()","text":"Get the usage specifier of this vertex buffer Returns: Usage specifier [ View source ]","title":"#usage"},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#usage=(usage)","text":"Set the usage specifier of this vertex buffer This function provides a hint about how this vertex buffer is going to be used in terms of data update frequency. After changing the usage specifier, the vertex buffer has to be updated with new data for the usage specifier to take effect. The default primitive type is SF::VertexBuffer::Stream . usage - Usage specifier [ View source ]","title":"#usage="},{"location":"api/SF/VertexBuffer.html#SF::VertexBuffer#vertex_count()","text":"Return the vertex count Returns: Number of vertices in the vertex buffer [ View source ]","title":"#vertex_count"},{"location":"api/SF/VideoMode.html","text":"struct SF::VideoMode inherits Struct # VideoMode defines a video mode (width, height, bpp) A video mode is defined by a width and a height (in pixels) and a depth (in bits per pixel). Video modes are used to setup windows ( SF::Window ) at creation time. The main usage of video modes is for fullscreen mode: indeed you must use one of the valid video modes allowed by the OS (which are defined by what the monitor and the graphics card support), otherwise your window creation will just fail. SF::VideoMode provides a static function for retrieving the list of all the video modes supported by the system: fullscreen_modes(). A custom video mode can also be checked directly for fullscreen compatibility with its valid?() function. Additionally, SF::VideoMode provides a static function to get the mode currently used by the desktop: desktop_mode() . This allows to build windows with the same size or pixel depth as the current resolution. Usage example: # Display the list of all the video modes available for fullscreen SF :: VideoMode . fullscreen_modes . each do | mode | puts \"Mode # #{ i } : #{ mode . width } x #{ mode . height } - #{ mode . bits_per_pixel } bpp\" end # Create a window with the same pixel depth as the desktop desktop = SF :: VideoMode . desktop_mode window . create ( SF :: VideoMode . new ( 1024 , 768 , desktop . bits_per_pixel ), \"SFML window\" ) Class methods # .fullscreen_modes : Array ( VideoMode ) # Retrieve all the video modes supported in fullscreen mode When creating a fullscreen window, the video mode is restricted to be compatible with what the graphics driver and monitor support. This function returns the complete list of all video modes that can be used in fullscreen mode. The returned array is sorted from best to worst, so that the first element will always give the best mode (higher width, height and bits-per-pixel). Returns: Array containing all the supported fullscreen modes [ View source ] .desktop_mode : VideoMode # Get the current desktop video mode Returns: Current desktop video mode [ View source ] .new ( width : Int , height : Int , bits_per_pixel : Int = 32 ) # Construct the video mode with its attributes width - Width in pixels height - Height in pixels bits_per_pixel - Pixel depths in bits per pixel [ View source ] .new # Default constructor This constructors initializes all members to 0. [ View source ] Methods # #!= ( right : VideoMode ) : Bool # Overload of != operator to compare two video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if modes are different [ View source ] #< ( right : VideoMode ) : Bool # Overload of < operator to compare video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if left is lesser than right [ View source ] #<= ( right : VideoMode ) : Bool # Overload of <= operator to compare video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if left is lesser or equal than right [ View source ] #== ( right : VideoMode ) : Bool # Overload of == operator to compare two video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if modes are equal [ View source ] #> ( right : VideoMode ) : Bool # Overload of > operator to compare video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if left is greater than right [ View source ] #>= ( right : VideoMode ) : Bool # Overload of >= operator to compare video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if left is greater or equal than right [ View source ] #bits_per_pixel : UInt32 # Video mode pixel depth, in bits per pixels [ View source ] #bits_per_pixel= ( bits_per_pixel : Int ) # [ View source ] #dup : VideoMode # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #height : UInt32 # Video mode height, in pixels [ View source ] #height= ( height : Int ) # [ View source ] #valid? : Bool # Tell whether or not the video mode is valid The validity of video modes is only relevant when using fullscreen windows; otherwise any video mode can be used with no restriction. Returns: True if the video mode is valid for fullscreen mode [ View source ] #width : UInt32 # Video mode width, in pixels [ View source ] #width= ( width : Int ) # [ View source ]","title":"VideoMode"},{"location":"api/SF/VideoMode.html#SF::VideoMode","text":"VideoMode defines a video mode (width, height, bpp) A video mode is defined by a width and a height (in pixels) and a depth (in bits per pixel). Video modes are used to setup windows ( SF::Window ) at creation time. The main usage of video modes is for fullscreen mode: indeed you must use one of the valid video modes allowed by the OS (which are defined by what the monitor and the graphics card support), otherwise your window creation will just fail. SF::VideoMode provides a static function for retrieving the list of all the video modes supported by the system: fullscreen_modes(). A custom video mode can also be checked directly for fullscreen compatibility with its valid?() function. Additionally, SF::VideoMode provides a static function to get the mode currently used by the desktop: desktop_mode() . This allows to build windows with the same size or pixel depth as the current resolution. Usage example: # Display the list of all the video modes available for fullscreen SF :: VideoMode . fullscreen_modes . each do | mode | puts \"Mode # #{ i } : #{ mode . width } x #{ mode . height } - #{ mode . bits_per_pixel } bpp\" end # Create a window with the same pixel depth as the desktop desktop = SF :: VideoMode . desktop_mode window . create ( SF :: VideoMode . new ( 1024 , 768 , desktop . bits_per_pixel ), \"SFML window\" )","title":"VideoMode"},{"location":"api/SF/VideoMode.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/VideoMode.html#SF::VideoMode.fullscreen_modes()","text":"Retrieve all the video modes supported in fullscreen mode When creating a fullscreen window, the video mode is restricted to be compatible with what the graphics driver and monitor support. This function returns the complete list of all video modes that can be used in fullscreen mode. The returned array is sorted from best to worst, so that the first element will always give the best mode (higher width, height and bits-per-pixel). Returns: Array containing all the supported fullscreen modes [ View source ]","title":".fullscreen_modes"},{"location":"api/SF/VideoMode.html#SF::VideoMode.desktop_mode()","text":"Get the current desktop video mode Returns: Current desktop video mode [ View source ]","title":".desktop_mode"},{"location":"api/SF/VideoMode.html#SF::VideoMode.new(width,height,bits_per_pixel)","text":"Construct the video mode with its attributes width - Width in pixels height - Height in pixels bits_per_pixel - Pixel depths in bits per pixel [ View source ]","title":".new"},{"location":"api/SF/VideoMode.html#methods","text":"","title":"Methods"},{"location":"api/SF/VideoMode.html#SF::VideoMode#!=(right)","text":"Overload of != operator to compare two video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if modes are different [ View source ]","title":"#!="},{"location":"api/SF/VideoMode.html#SF::VideoMode#<(right)","text":"Overload of < operator to compare video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if left is lesser than right [ View source ]","title":"#&lt;"},{"location":"api/SF/VideoMode.html#SF::VideoMode#<=(right)","text":"Overload of <= operator to compare video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if left is lesser or equal than right [ View source ]","title":"#&lt;="},{"location":"api/SF/VideoMode.html#SF::VideoMode#==(right)","text":"Overload of == operator to compare two video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if modes are equal [ View source ]","title":"#=="},{"location":"api/SF/VideoMode.html#SF::VideoMode#>(right)","text":"Overload of > operator to compare video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if left is greater than right [ View source ]","title":"#&gt;"},{"location":"api/SF/VideoMode.html#SF::VideoMode#>=(right)","text":"Overload of >= operator to compare video modes left - Left operand (a video mode) right - Right operand (a video mode) Returns: True if left is greater or equal than right [ View source ]","title":"#&gt;="},{"location":"api/SF/VideoMode.html#SF::VideoMode#bits_per_pixel()","text":"Video mode pixel depth, in bits per pixels [ View source ]","title":"#bits_per_pixel"},{"location":"api/SF/VideoMode.html#SF::VideoMode#bits_per_pixel=(bits_per_pixel)","text":"[ View source ]","title":"#bits_per_pixel="},{"location":"api/SF/VideoMode.html#SF::VideoMode#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/VideoMode.html#SF::VideoMode#height()","text":"Video mode height, in pixels [ View source ]","title":"#height"},{"location":"api/SF/VideoMode.html#SF::VideoMode#height=(height)","text":"[ View source ]","title":"#height="},{"location":"api/SF/VideoMode.html#SF::VideoMode#valid?()","text":"Tell whether or not the video mode is valid The validity of video modes is only relevant when using fullscreen windows; otherwise any video mode can be used with no restriction. Returns: True if the video mode is valid for fullscreen mode [ View source ]","title":"#valid?"},{"location":"api/SF/VideoMode.html#SF::VideoMode#width()","text":"Video mode width, in pixels [ View source ]","title":"#width"},{"location":"api/SF/VideoMode.html#SF::VideoMode#width=(width)","text":"[ View source ]","title":"#width="},{"location":"api/SF/View.html","text":"class SF::View inherits Reference # 2D camera that defines what region is shown on screen SF::View defines a camera in the 2D scene. This is a very powerful concept: you can scroll, rotate or zoom the entire scene without altering the way that your drawable objects are drawn. A view is composed of a source rectangle, which defines what part of the 2D scene is shown, and a target viewport, which defines where the contents of the source rectangle will be displayed on the render target (window or texture). The viewport allows to map the scene to a custom part of the render target, and can be used for split-screen or for displaying a minimap, for example. If the source rectangle doesn't have the same size as the viewport, its contents will be stretched to fit in. To apply a view, you have to assign it to the render target. Then, objects drawn in this render target will be affected by the view until you use another view. Usage example: window = SF :: RenderWindow . new view = SF :: View . new # Initialize the view to a rectangle located at (100, 100) and with a size of 400x200 view . reset ( SF . float_rect ( 100 , 100 , 400 , 200 )) # Rotate it by 45 degrees view . rotate ( 45 ) # Set its target viewport to be half of the window view . viewport = SF . float_rect ( 0.0 , 0.0 , 0.5 , 1.0 ) # Apply it window . view = view # Render stuff window . draw some_sprite # Set the default view back window . view = window . default_view # Render stuff not affected by the view window . draw some_text See also the note on coordinates and undistorted rendering in SF::Transformable . See also: SF::RenderWindow , SF::RenderTexture Class methods # .new ( center : Vector2 | Tuple , size : Vector2 | Tuple ) # Construct the view from its center and size center - Center of the zone to display size - Size of zone to display [ View source ] .new ( rectangle : FloatRect ) # Construct the view from a rectangle rectangle - Rectangle defining the zone to display [ View source ] .new # Default constructor This constructor creates a default view of (0, 0, 1000, 1000) [ View source ] Methods # #center : Vector2f # Get the center of the view Returns: Center of the view See also: size , center= [ View source ] #center= ( center : Vector2 | Tuple ) # Set the center of the view center - New center See also: size= , center [ View source ] #dup : View # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ] #inverse_transform : Transform # Get the inverse projection transform of the view This function is meant for internal use only. Returns: Inverse of the projection transform defining the view See also: transform [ View source ] #move ( offset_x : Number , offset_y : Number ) # Move the view relatively to its current position offset_x - X coordinate of the move offset offset_y - Y coordinate of the move offset See also: center= , rotate , zoom [ View source ] #move ( offset : Vector2 | Tuple ) # Move the view relatively to its current position offset - Move offset See also: center= , rotate , zoom [ View source ] #reset ( rectangle : FloatRect ) # Reset the view to the given rectangle Note that this function resets the rotation angle to 0. rectangle - Rectangle defining the zone to display See also: center= , size= , rotation= [ View source ] #rotate ( angle : Number ) # Rotate the view relatively to its current orientation angle - Angle to rotate, in degrees See also: rotation= , move , zoom [ View source ] #rotation : Float32 # Get the current orientation of the view Returns: Rotation angle of the view, in degrees See also: rotation= [ View source ] #rotation= ( angle : Number ) # Set the orientation of the view The default rotation of a view is 0 degree. angle - New angle, in degrees See also: rotation [ View source ] #set_center ( x : Number , y : Number ) # Set the center of the view x - X coordinate of the new center y - Y coordinate of the new center See also: size= , center [ View source ] #set_size ( width : Number , height : Number ) # Set the size of the view width - New width of the view height - New height of the view See also: center= , center [ View source ] #size : Vector2f # Get the size of the view Returns: Size of the view See also: center , size= [ View source ] #size= ( size : Vector2 | Tuple ) # Set the size of the view size - New size See also: center= , center [ View source ] #transform : Transform # Get the projection transform of the view This function is meant for internal use only. Returns: Projection transform defining the view See also: inverse_transform [ View source ] #viewport : FloatRect # Get the target viewport rectangle of the view Returns: Viewport rectangle, expressed as a factor of the target size See also: viewport= [ View source ] #viewport= ( viewport : FloatRect ) # Set the target viewport The viewport is the rectangle into which the contents of the view are displayed, expressed as a factor (between 0 and 1) of the size of the RenderTarget to which the view is applied. For example, a view which takes the left side of the target would be defined with View.viewport=( SF::FloatRect (0, 0, 0.5, 1)). By default, a view has a viewport which covers the entire target. viewport - New viewport rectangle See also: viewport [ View source ] #zoom ( factor : Number ) # Resize the view rectangle relatively to its current size Resizing the view simulates a zoom, as the zone displayed on screen grows or shrinks. factor is a multiplier: 1 keeps the size unchanged > 1 makes the view bigger (objects appear smaller) < 1 makes the view smaller (objects appear bigger) factor - Zoom factor to apply See also: size= , move , rotate [ View source ]","title":"View"},{"location":"api/SF/View.html#SF::View","text":"2D camera that defines what region is shown on screen SF::View defines a camera in the 2D scene. This is a very powerful concept: you can scroll, rotate or zoom the entire scene without altering the way that your drawable objects are drawn. A view is composed of a source rectangle, which defines what part of the 2D scene is shown, and a target viewport, which defines where the contents of the source rectangle will be displayed on the render target (window or texture). The viewport allows to map the scene to a custom part of the render target, and can be used for split-screen or for displaying a minimap, for example. If the source rectangle doesn't have the same size as the viewport, its contents will be stretched to fit in. To apply a view, you have to assign it to the render target. Then, objects drawn in this render target will be affected by the view until you use another view. Usage example: window = SF :: RenderWindow . new view = SF :: View . new # Initialize the view to a rectangle located at (100, 100) and with a size of 400x200 view . reset ( SF . float_rect ( 100 , 100 , 400 , 200 )) # Rotate it by 45 degrees view . rotate ( 45 ) # Set its target viewport to be half of the window view . viewport = SF . float_rect ( 0.0 , 0.0 , 0.5 , 1.0 ) # Apply it window . view = view # Render stuff window . draw some_sprite # Set the default view back window . view = window . default_view # Render stuff not affected by the view window . draw some_text See also the note on coordinates and undistorted rendering in SF::Transformable . See also: SF::RenderWindow , SF::RenderTexture","title":"View"},{"location":"api/SF/View.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/View.html#SF::View.new(center,size)","text":"Construct the view from its center and size center - Center of the zone to display size - Size of zone to display [ View source ]","title":".new"},{"location":"api/SF/View.html#methods","text":"","title":"Methods"},{"location":"api/SF/View.html#SF::View#center()","text":"Get the center of the view Returns: Center of the view See also: size , center= [ View source ]","title":"#center"},{"location":"api/SF/View.html#SF::View#center=(center)","text":"Set the center of the view center - New center See also: size= , center [ View source ]","title":"#center="},{"location":"api/SF/View.html#SF::View#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/View.html#SF::View#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/View.html#SF::View#inverse_transform()","text":"Get the inverse projection transform of the view This function is meant for internal use only. Returns: Inverse of the projection transform defining the view See also: transform [ View source ]","title":"#inverse_transform"},{"location":"api/SF/View.html#SF::View#move(offset_x,offset_y)","text":"Move the view relatively to its current position offset_x - X coordinate of the move offset offset_y - Y coordinate of the move offset See also: center= , rotate , zoom [ View source ]","title":"#move"},{"location":"api/SF/View.html#SF::View#reset(rectangle)","text":"Reset the view to the given rectangle Note that this function resets the rotation angle to 0. rectangle - Rectangle defining the zone to display See also: center= , size= , rotation= [ View source ]","title":"#reset"},{"location":"api/SF/View.html#SF::View#rotate(angle)","text":"Rotate the view relatively to its current orientation angle - Angle to rotate, in degrees See also: rotation= , move , zoom [ View source ]","title":"#rotate"},{"location":"api/SF/View.html#SF::View#rotation()","text":"Get the current orientation of the view Returns: Rotation angle of the view, in degrees See also: rotation= [ View source ]","title":"#rotation"},{"location":"api/SF/View.html#SF::View#rotation=(angle)","text":"Set the orientation of the view The default rotation of a view is 0 degree. angle - New angle, in degrees See also: rotation [ View source ]","title":"#rotation="},{"location":"api/SF/View.html#SF::View#set_center(x,y)","text":"Set the center of the view x - X coordinate of the new center y - Y coordinate of the new center See also: size= , center [ View source ]","title":"#set_center"},{"location":"api/SF/View.html#SF::View#set_size(width,height)","text":"Set the size of the view width - New width of the view height - New height of the view See also: center= , center [ View source ]","title":"#set_size"},{"location":"api/SF/View.html#SF::View#size()","text":"Get the size of the view Returns: Size of the view See also: center , size= [ View source ]","title":"#size"},{"location":"api/SF/View.html#SF::View#size=(size)","text":"Set the size of the view size - New size See also: center= , center [ View source ]","title":"#size="},{"location":"api/SF/View.html#SF::View#transform()","text":"Get the projection transform of the view This function is meant for internal use only. Returns: Projection transform defining the view See also: inverse_transform [ View source ]","title":"#transform"},{"location":"api/SF/View.html#SF::View#viewport()","text":"Get the target viewport rectangle of the view Returns: Viewport rectangle, expressed as a factor of the target size See also: viewport= [ View source ]","title":"#viewport"},{"location":"api/SF/View.html#SF::View#viewport=(viewport)","text":"Set the target viewport The viewport is the rectangle into which the contents of the view are displayed, expressed as a factor (between 0 and 1) of the size of the RenderTarget to which the view is applied. For example, a view which takes the left side of the target would be defined with View.viewport=( SF::FloatRect (0, 0, 0.5, 1)). By default, a view has a viewport which covers the entire target. viewport - New viewport rectangle See also: viewport [ View source ]","title":"#viewport="},{"location":"api/SF/View.html#SF::View#zoom(factor)","text":"Resize the view rectangle relatively to its current size Resizing the view simulates a zoom, as the zone displayed on screen grows or shrinks. factor is a multiplier: 1 keeps the size unchanged > 1 makes the view bigger (objects appear smaller) < 1 makes the view smaller (objects appear bigger) factor - Zoom factor to apply See also: size= , move , rotate [ View source ]","title":"#zoom"},{"location":"api/SF/Window.html","text":"class SF::Window inherits Reference # Window that serves as a target for OpenGL rendering SF::Window is the main class of the Window module. It defines an OS window that is able to receive an OpenGL rendering. A SF::Window can create its own new window, or be embedded into an already existing control using the create(handle) function. This can be useful for embedding an OpenGL rendering area into a view which is part of a bigger GUI with existing windows, controls, etc. It can also serve as embedding an OpenGL rendering area into a window created by another (probably richer) GUI library like Qt or wx_widgets. The SF::Window class provides a simple interface for manipulating the window: move, resize, show/hide, control mouse cursor, etc. It also provides event handling through its poll_event() and wait_event() functions. Note that OpenGL experts can pass their own parameters (antialiasing level, bits for the depth and stencil buffers, etc.) to the OpenGL context attached to the window, with the SF::ContextSettings structure which is passed as an optional argument when creating the window. On dual-graphics systems consisting of a low-power integrated GPU and a powerful discrete GPU, the driver picks which GPU will run an SFML application. In order to inform the driver that an SFML application can benefit from being run on the more powerful discrete GPU, #SFML_DEFINE_DISCRETE_GPU_PREFERENCE can be placed in a source file that is compiled and linked into the final application. The macro should be placed outside of any scopes in the global namespace. Usage example: # Declare and create a new window window = SF :: Window . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) # Limit the framerate to 60 frames per second (this step is optional) window . framerate_limit = 60 # The main loop - ends as soon as the window is closed while window . open? # Event processing while ( event = window . poll_event ()) # Request for closing the window if event . is_a? ( SF :: Event :: Closed ) window . close () end end # Activate the window for OpenGL rendering window . active = true # OpenGL drawing commands go here... # End the current frame and display its contents on screen window . display () end Included modules # SF::GlResource SF::NonCopyable Direct known subclasses # SF::RenderWindow Class methods # .new ( mode : VideoMode , title : String , style : Style = Style :: Default , settings : ContextSettings = ContextSettings . new ) # Construct a new window This constructor creates the window with the size and pixel depth defined in mode. An optional style can be passed to customize the look and behavior of the window (borders, title bar, resizable, closable, ...). If style contains Style::Fullscreen, then mode must be a valid video mode. The fourth parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. mode - Video mode to use (defines the width, height and depth of the rendering area of the window) title - Title of the window style - Window style, a bitwise OR combination of SF::Style enumerators settings - Additional settings for the underlying OpenGL context [ View source ] .new ( handle : WindowHandle , settings : ContextSettings = ContextSettings . new ) # Construct the window from an existing control Use this constructor if you want to create an OpenGL rendering area into an already existing control. The second parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. handle - Platform-specific handle of the control settings - Additional settings for the underlying OpenGL context [ View source ] .new # Default constructor This constructor doesn't actually create the window, use the other constructors or call create() to do so. [ View source ] .new ( * args , ** kwargs ) : self # Shorthand for window = Window.new; window.create(...); window [ View source ] Methods # #active= ( active : Bool = true ) : Bool # Activate or deactivate the window as the current target for OpenGL rendering A window is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one window can be active on a thread at a time, thus the window previously active (if any) automatically gets deactivated. This is not to be confused with request_focus() . active - True to activate, false to deactivate Returns: True if operation was successful, false otherwise [ View source ] #close # Close the window and destroy all the attached resources After calling this function, the SF::Window instance remains valid and you can call create() to recreate the window. All other functions such as poll_event() or display() will still work (i.e. you don't have to test open?() every time), and will have no effect on closed windows. [ View source ] #create ( mode : VideoMode , title : String , style : Style = Style :: Default , settings : ContextSettings = ContextSettings . new ) # Create (or recreate) the window If the window was already created, it closes it first. If style contains Style::Fullscreen, then mode must be a valid video mode. The fourth parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. mode - Video mode to use (defines the width, height and depth of the rendering area of the window) title - Title of the window style - Window style, a bitwise OR combination of SF::Style enumerators settings - Additional settings for the underlying OpenGL context [ View source ] #create ( handle : WindowHandle , settings : ContextSettings = ContextSettings . new ) # Create (or recreate) the window from an existing control Use this function if you want to create an OpenGL rendering area into an already existing control. If the window was already created, it closes it first. The second parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. handle - Platform-specific handle of the control settings - Additional settings for the underlying OpenGL context [ View source ] #display # Display on screen what has been rendered to the window so far This function is typically called after all OpenGL rendering has been done for the current frame, in order to show it on screen. [ View source ] #finalize # Destructor Closes the window and frees all the resources attached to it. [ View source ] #focus? : Bool # Check whether the window has the input focus At any given time, only one window may have the input focus to receive input events such as keystrokes or most mouse events. Returns: True if window has focus, false otherwise See also: request_focus [ View source ] #framerate_limit= ( limit : Int ) # Limit the framerate to a maximum fixed frequency If a limit is set, the window will use a small delay after each call to display() to ensure that the current frame lasted long enough to match the framerate limit. SFML will try to match the given limit as much as it can, but since it internally uses SF.sleep , whose precision depends on the underlying OS, the results may be a little unprecise as well (for example, you can get 65 FPS when requesting 60). limit - Framerate limit, in frames per seconds (use 0 to disable limit) [ View source ] #joystick_threshold= ( threshold : Number ) # Change the joystick threshold The joystick threshold is the value below which no JoystickMoved event will be generated. The threshold value is 0.1 by default. threshold - New threshold, in the range 0.0 .. 100.0 [ View source ] #key_repeat_enabled= ( enabled : Bool ) # Enable or disable automatic key-repeat If key repeat is enabled, you will receive repeated KeyPressed events while keeping a key pressed. If it is disabled, you will only get a single event when the key is pressed. Key repeat is enabled by default. enabled - True to enable, false to disable [ View source ] #mouse_cursor= ( cursor : Cursor ) # Set the displayed cursor to a native system cursor Upon window creation, the arrow cursor is used by default. Warning: The cursor must not be destroyed while in use by the window. Warning: Features related to Cursor are not supported on iOS and Android. cursor - Native system cursor type to display See also: SF::Cursor.load_from_system See also: SF::Cursor.load_from_pixels [ View source ] #mouse_cursor_grabbed= ( grabbed : Bool ) # Grab or release the mouse cursor If set, grabs the mouse cursor inside this window's client area so it may no longer be moved outside its bounds. Note that grabbing is only active while the window has focus. grabbed - True to enable, false to disable [ View source ] #mouse_cursor_visible= ( visible : Bool ) # Show or hide the mouse cursor The mouse cursor is visible by default. visible - True to show the mouse cursor, false to hide it [ View source ] #open? : Bool # Tell whether or not the window is open This function returns whether or not the window exists. Note that a hidden window (visible=(false)) is open (therefore this function would return true). Returns: True if the window is open, false if it has been closed [ View source ] #poll_event : Event? # Pop the event on top of the event queue, if any, and return it This function is not blocking: if there's no pending event then it will return false and leave event unmodified. Note that more than one event may be present in the event queue, thus you should always call this function in a loop to make sure that you process every pending event. while ( event = window . poll_event ()) # process event... end event - Event to be returned Returns: True if an event was returned, or false if the event queue was empty See also: wait_event [ View source ] #position : Vector2i # Get the position of the window Returns: Position of the window, in pixels See also: position= [ View source ] #position= ( position : Vector2 | Tuple ) # Change the position of the window on screen This function only works for top-level windows (i.e. it will be ignored for windows created from the handle of a child window/control). position - New position, in pixels See also: position [ View source ] #request_focus # Request the current window to be made the active foreground window At any given time, only one window may have the input focus to receive input events such as keystrokes or mouse events. If a window requests focus, it only hints to the operating system, that it would like to be focused. The operating system is free to deny the request. This is not to be confused with active=() . See also: focus? [ View source ] #set_icon ( width : Int , height : Int , pixels : Pointer ( UInt8 )) # Change the window's icon pixels must be an array of width x height pixels in 32-bits RGBA format. The OS default icon is used by default. width - Icon's width, in pixels height - Icon's height, in pixels pixels - Pointer to the array of pixels in memory. The pixels are copied, so you need not keep the source alive after calling this function. See also: title= [ View source ] #settings : ContextSettings # Get the settings of the OpenGL context of the window Note that these settings may be different from what was passed to the constructor or the create() function, if one or more settings were not supported. In this case, SFML chose the closest match. Returns: Structure containing the OpenGL context settings [ View source ] #size : Vector2u # Get the size of the rendering region of the window The size doesn't include the titlebar and borders of the window. Returns: Size in pixels See also: size= [ View source ] #size= ( size : Vector2 | Tuple ) # Change the size of the rendering region of the window size - New size, in pixels See also: size [ View source ] #system_handle : WindowHandle # Get the OS-specific handle of the window The type of the returned handle is SF::WindowHandle , which is a typedef to the handle type defined by the OS. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed. Returns: System handle of the window [ View source ] #title= ( title : String ) # Change the title of the window title - New title See also: icon= [ View source ] #vertical_sync_enabled= ( enabled : Bool ) # Enable or disable vertical synchronization Activating vertical synchronization will limit the number of frames displayed to the refresh rate of the monitor. This can avoid some visual artifacts, and limit the framerate to a good value (but not constant across different computers). Vertical synchronization is disabled by default. enabled - True to enable v-sync, false to deactivate it [ View source ] #visible= ( visible : Bool ) # Show or hide the window The window is shown by default. visible - True to show the window, false to hide it [ View source ] #wait_event : Event? # Wait for an event and return it This function is blocking: if there's no pending event then it will wait until an event is received. After this function returns (and no error occurred), the event object is always valid and filled properly. This function is typically used when you have a thread that is dedicated to events handling: you want to make this thread sleep as long as no new event is received. if ( event = window . wait_event ()) # process event... end event - Event to be returned Returns: False if any error occurred See also: poll_event [ View source ]","title":"Window"},{"location":"api/SF/Window.html#SF::Window","text":"Window that serves as a target for OpenGL rendering SF::Window is the main class of the Window module. It defines an OS window that is able to receive an OpenGL rendering. A SF::Window can create its own new window, or be embedded into an already existing control using the create(handle) function. This can be useful for embedding an OpenGL rendering area into a view which is part of a bigger GUI with existing windows, controls, etc. It can also serve as embedding an OpenGL rendering area into a window created by another (probably richer) GUI library like Qt or wx_widgets. The SF::Window class provides a simple interface for manipulating the window: move, resize, show/hide, control mouse cursor, etc. It also provides event handling through its poll_event() and wait_event() functions. Note that OpenGL experts can pass their own parameters (antialiasing level, bits for the depth and stencil buffers, etc.) to the OpenGL context attached to the window, with the SF::ContextSettings structure which is passed as an optional argument when creating the window. On dual-graphics systems consisting of a low-power integrated GPU and a powerful discrete GPU, the driver picks which GPU will run an SFML application. In order to inform the driver that an SFML application can benefit from being run on the more powerful discrete GPU, #SFML_DEFINE_DISCRETE_GPU_PREFERENCE can be placed in a source file that is compiled and linked into the final application. The macro should be placed outside of any scopes in the global namespace. Usage example: # Declare and create a new window window = SF :: Window . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) # Limit the framerate to 60 frames per second (this step is optional) window . framerate_limit = 60 # The main loop - ends as soon as the window is closed while window . open? # Event processing while ( event = window . poll_event ()) # Request for closing the window if event . is_a? ( SF :: Event :: Closed ) window . close () end end # Activate the window for OpenGL rendering window . active = true # OpenGL drawing commands go here... # End the current frame and display its contents on screen window . display () end","title":"Window"},{"location":"api/SF/Window.html#included-modules","text":"SF::GlResource SF::NonCopyable","title":"Included modules"},{"location":"api/SF/Window.html#direct-known-subclasses","text":"SF::RenderWindow","title":"Direct known subclasses"},{"location":"api/SF/Window.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Window.html#SF::Window.new(mode,title,style,settings)","text":"Construct a new window This constructor creates the window with the size and pixel depth defined in mode. An optional style can be passed to customize the look and behavior of the window (borders, title bar, resizable, closable, ...). If style contains Style::Fullscreen, then mode must be a valid video mode. The fourth parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. mode - Video mode to use (defines the width, height and depth of the rendering area of the window) title - Title of the window style - Window style, a bitwise OR combination of SF::Style enumerators settings - Additional settings for the underlying OpenGL context [ View source ]","title":".new"},{"location":"api/SF/Window.html#methods","text":"","title":"Methods"},{"location":"api/SF/Window.html#SF::Window#active=(active)","text":"Activate or deactivate the window as the current target for OpenGL rendering A window is active only on the current thread, if you want to make it active on another thread you have to deactivate it on the previous thread first if it was active. Only one window can be active on a thread at a time, thus the window previously active (if any) automatically gets deactivated. This is not to be confused with request_focus() . active - True to activate, false to deactivate Returns: True if operation was successful, false otherwise [ View source ]","title":"#active="},{"location":"api/SF/Window.html#SF::Window#close()","text":"Close the window and destroy all the attached resources After calling this function, the SF::Window instance remains valid and you can call create() to recreate the window. All other functions such as poll_event() or display() will still work (i.e. you don't have to test open?() every time), and will have no effect on closed windows. [ View source ]","title":"#close"},{"location":"api/SF/Window.html#SF::Window#create(mode,title,style,settings)","text":"Create (or recreate) the window If the window was already created, it closes it first. If style contains Style::Fullscreen, then mode must be a valid video mode. The fourth parameter is an optional structure specifying advanced OpenGL context settings such as antialiasing, depth-buffer bits, etc. mode - Video mode to use (defines the width, height and depth of the rendering area of the window) title - Title of the window style - Window style, a bitwise OR combination of SF::Style enumerators settings - Additional settings for the underlying OpenGL context [ View source ]","title":"#create"},{"location":"api/SF/Window.html#SF::Window#display()","text":"Display on screen what has been rendered to the window so far This function is typically called after all OpenGL rendering has been done for the current frame, in order to show it on screen. [ View source ]","title":"#display"},{"location":"api/SF/Window.html#SF::Window#finalize()","text":"Destructor Closes the window and frees all the resources attached to it. [ View source ]","title":"#finalize"},{"location":"api/SF/Window.html#SF::Window#focus?()","text":"Check whether the window has the input focus At any given time, only one window may have the input focus to receive input events such as keystrokes or most mouse events. Returns: True if window has focus, false otherwise See also: request_focus [ View source ]","title":"#focus?"},{"location":"api/SF/Window.html#SF::Window#framerate_limit=(limit)","text":"Limit the framerate to a maximum fixed frequency If a limit is set, the window will use a small delay after each call to display() to ensure that the current frame lasted long enough to match the framerate limit. SFML will try to match the given limit as much as it can, but since it internally uses SF.sleep , whose precision depends on the underlying OS, the results may be a little unprecise as well (for example, you can get 65 FPS when requesting 60). limit - Framerate limit, in frames per seconds (use 0 to disable limit) [ View source ]","title":"#framerate_limit="},{"location":"api/SF/Window.html#SF::Window#joystick_threshold=(threshold)","text":"Change the joystick threshold The joystick threshold is the value below which no JoystickMoved event will be generated. The threshold value is 0.1 by default. threshold - New threshold, in the range 0.0 .. 100.0 [ View source ]","title":"#joystick_threshold="},{"location":"api/SF/Window.html#SF::Window#key_repeat_enabled=(enabled)","text":"Enable or disable automatic key-repeat If key repeat is enabled, you will receive repeated KeyPressed events while keeping a key pressed. If it is disabled, you will only get a single event when the key is pressed. Key repeat is enabled by default. enabled - True to enable, false to disable [ View source ]","title":"#key_repeat_enabled="},{"location":"api/SF/Window.html#SF::Window#mouse_cursor=(cursor)","text":"Set the displayed cursor to a native system cursor Upon window creation, the arrow cursor is used by default. Warning: The cursor must not be destroyed while in use by the window. Warning: Features related to Cursor are not supported on iOS and Android. cursor - Native system cursor type to display See also: SF::Cursor.load_from_system See also: SF::Cursor.load_from_pixels [ View source ]","title":"#mouse_cursor="},{"location":"api/SF/Window.html#SF::Window#mouse_cursor_grabbed=(grabbed)","text":"Grab or release the mouse cursor If set, grabs the mouse cursor inside this window's client area so it may no longer be moved outside its bounds. Note that grabbing is only active while the window has focus. grabbed - True to enable, false to disable [ View source ]","title":"#mouse_cursor_grabbed="},{"location":"api/SF/Window.html#SF::Window#mouse_cursor_visible=(visible)","text":"Show or hide the mouse cursor The mouse cursor is visible by default. visible - True to show the mouse cursor, false to hide it [ View source ]","title":"#mouse_cursor_visible="},{"location":"api/SF/Window.html#SF::Window#open?()","text":"Tell whether or not the window is open This function returns whether or not the window exists. Note that a hidden window (visible=(false)) is open (therefore this function would return true). Returns: True if the window is open, false if it has been closed [ View source ]","title":"#open?"},{"location":"api/SF/Window.html#SF::Window#poll_event()","text":"Pop the event on top of the event queue, if any, and return it This function is not blocking: if there's no pending event then it will return false and leave event unmodified. Note that more than one event may be present in the event queue, thus you should always call this function in a loop to make sure that you process every pending event. while ( event = window . poll_event ()) # process event... end event - Event to be returned Returns: True if an event was returned, or false if the event queue was empty See also: wait_event [ View source ]","title":"#poll_event"},{"location":"api/SF/Window.html#SF::Window#position()","text":"Get the position of the window Returns: Position of the window, in pixels See also: position= [ View source ]","title":"#position"},{"location":"api/SF/Window.html#SF::Window#position=(position)","text":"Change the position of the window on screen This function only works for top-level windows (i.e. it will be ignored for windows created from the handle of a child window/control). position - New position, in pixels See also: position [ View source ]","title":"#position="},{"location":"api/SF/Window.html#SF::Window#request_focus()","text":"Request the current window to be made the active foreground window At any given time, only one window may have the input focus to receive input events such as keystrokes or mouse events. If a window requests focus, it only hints to the operating system, that it would like to be focused. The operating system is free to deny the request. This is not to be confused with active=() . See also: focus? [ View source ]","title":"#request_focus"},{"location":"api/SF/Window.html#SF::Window#set_icon(width,height,pixels)","text":"Change the window's icon pixels must be an array of width x height pixels in 32-bits RGBA format. The OS default icon is used by default. width - Icon's width, in pixels height - Icon's height, in pixels pixels - Pointer to the array of pixels in memory. The pixels are copied, so you need not keep the source alive after calling this function. See also: title= [ View source ]","title":"#set_icon"},{"location":"api/SF/Window.html#SF::Window#settings()","text":"Get the settings of the OpenGL context of the window Note that these settings may be different from what was passed to the constructor or the create() function, if one or more settings were not supported. In this case, SFML chose the closest match. Returns: Structure containing the OpenGL context settings [ View source ]","title":"#settings"},{"location":"api/SF/Window.html#SF::Window#size()","text":"Get the size of the rendering region of the window The size doesn't include the titlebar and borders of the window. Returns: Size in pixels See also: size= [ View source ]","title":"#size"},{"location":"api/SF/Window.html#SF::Window#size=(size)","text":"Change the size of the rendering region of the window size - New size, in pixels See also: size [ View source ]","title":"#size="},{"location":"api/SF/Window.html#SF::Window#system_handle()","text":"Get the OS-specific handle of the window The type of the returned handle is SF::WindowHandle , which is a typedef to the handle type defined by the OS. You shouldn't need to use this function, unless you have very specific stuff to implement that SFML doesn't support, or implement a temporary workaround until a bug is fixed. Returns: System handle of the window [ View source ]","title":"#system_handle"},{"location":"api/SF/Window.html#SF::Window#title=(title)","text":"Change the title of the window title - New title See also: icon= [ View source ]","title":"#title="},{"location":"api/SF/Window.html#SF::Window#vertical_sync_enabled=(enabled)","text":"Enable or disable vertical synchronization Activating vertical synchronization will limit the number of frames displayed to the refresh rate of the monitor. This can avoid some visual artifacts, and limit the framerate to a good value (but not constant across different computers). Vertical synchronization is disabled by default. enabled - True to enable v-sync, false to deactivate it [ View source ]","title":"#vertical_sync_enabled="},{"location":"api/SF/Window.html#SF::Window#visible=(visible)","text":"Show or hide the window The window is shown by default. visible - True to show the window, false to hide it [ View source ]","title":"#visible="},{"location":"api/SF/Window.html#SF::Window#wait_event()","text":"Wait for an event and return it This function is blocking: if there's no pending event then it will wait until an event is received. After this function returns (and no error occurred), the event object is always valid and filled properly. This function is typically used when you have a thread that is dedicated to events handling: you want to make this thread sleep as long as no new event is received. if ( event = window . wait_event ()) # process event... end event - Event to be returned Returns: False if any error occurred See also: poll_event [ View source ]","title":"#wait_event"},{"location":"api/SF/WindowHandle.html","text":"alias SF::WindowHandle # A low-level window handle type, specific to each platform. Alias definition # SFMLExt :: WindowHandle","title":"WindowHandle"},{"location":"api/SF/WindowHandle.html#SF::WindowHandle","text":"A low-level window handle type, specific to each platform.","title":"WindowHandle"},{"location":"api/SF/WindowHandle.html#alias-definition","text":"SFMLExt :: WindowHandle","title":"Alias definition"},{"location":"api/SF/BlendMode/Equation.html","text":"enum SF::BlendMode::Equation # Enumeration of the blending equations The equations are mapped directly to their OpenGL equivalents, specified by gl_blend_equation() or gl_blend_equation_separate(). Members # Add # Pixel = Src * SrcFactor + Dst * DstFactor Subtract # Pixel = Src * SrcFactor - Dst * DstFactor ReverseSubtract # Pixel = Dst * DstFactor - Src * SrcFactor Methods # #add? # [ View source ] #reverse_subtract? # [ View source ] #subtract? # [ View source ]","title":"Equation"},{"location":"api/SF/BlendMode/Equation.html#SF::BlendMode::Equation","text":"Enumeration of the blending equations The equations are mapped directly to their OpenGL equivalents, specified by gl_blend_equation() or gl_blend_equation_separate().","title":"Equation"},{"location":"api/SF/BlendMode/Equation.html#members","text":"","title":"Members"},{"location":"api/SF/BlendMode/Equation.html#SF::BlendMode::Equation::Add","text":"Pixel = Src * SrcFactor + Dst * DstFactor","title":"Add"},{"location":"api/SF/BlendMode/Equation.html#SF::BlendMode::Equation::Subtract","text":"Pixel = Src * SrcFactor - Dst * DstFactor","title":"Subtract"},{"location":"api/SF/BlendMode/Equation.html#SF::BlendMode::Equation::ReverseSubtract","text":"Pixel = Dst * DstFactor - Src * SrcFactor","title":"ReverseSubtract"},{"location":"api/SF/BlendMode/Equation.html#methods","text":"","title":"Methods"},{"location":"api/SF/BlendMode/Equation.html#SF::BlendMode::Equation#add?()","text":"[ View source ]","title":"#add?"},{"location":"api/SF/BlendMode/Equation.html#SF::BlendMode::Equation#reverse_subtract?()","text":"[ View source ]","title":"#reverse_subtract?"},{"location":"api/SF/BlendMode/Equation.html#SF::BlendMode::Equation#subtract?()","text":"[ View source ]","title":"#subtract?"},{"location":"api/SF/BlendMode/Factor.html","text":"enum SF::BlendMode::Factor # Enumeration of the blending factors The factors are mapped directly to their OpenGL equivalents, specified by gl_blend_func() or gl_blend_func_separate(). Members # Zero # (0, 0, 0, 0) One # (1, 1, 1, 1) SrcColor # (src.r, src.g, src.b, src.a) OneMinusSrcColor # (1, 1, 1, 1) - (src.r, src.g, src.b, src.a) DstColor # (dst.r, dst.g, dst.b, dst.a) OneMinusDstColor # (1, 1, 1, 1) - (dst.r, dst.g, dst.b, dst.a) SrcAlpha # (src.a, src.a, src.a, src.a) OneMinusSrcAlpha # (1, 1, 1, 1) - (src.a, src.a, src.a, src.a) DstAlpha # (dst.a, dst.a, dst.a, dst.a) OneMinusDstAlpha # (1, 1, 1, 1) - (dst.a, dst.a, dst.a, dst.a) Methods # #dst_alpha? # [ View source ] #dst_color? # [ View source ] #one? # [ View source ] #one_minus_dst_alpha? # [ View source ] #one_minus_dst_color? # [ View source ] #one_minus_src_alpha? # [ View source ] #one_minus_src_color? # [ View source ] #src_alpha? # [ View source ] #src_color? # [ View source ] #zero? # [ View source ]","title":"Factor"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor","text":"Enumeration of the blending factors The factors are mapped directly to their OpenGL equivalents, specified by gl_blend_func() or gl_blend_func_separate().","title":"Factor"},{"location":"api/SF/BlendMode/Factor.html#members","text":"","title":"Members"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::Zero","text":"(0, 0, 0, 0)","title":"Zero"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::One","text":"(1, 1, 1, 1)","title":"One"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::SrcColor","text":"(src.r, src.g, src.b, src.a)","title":"SrcColor"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::OneMinusSrcColor","text":"(1, 1, 1, 1) - (src.r, src.g, src.b, src.a)","title":"OneMinusSrcColor"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::DstColor","text":"(dst.r, dst.g, dst.b, dst.a)","title":"DstColor"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::OneMinusDstColor","text":"(1, 1, 1, 1) - (dst.r, dst.g, dst.b, dst.a)","title":"OneMinusDstColor"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::SrcAlpha","text":"(src.a, src.a, src.a, src.a)","title":"SrcAlpha"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::OneMinusSrcAlpha","text":"(1, 1, 1, 1) - (src.a, src.a, src.a, src.a)","title":"OneMinusSrcAlpha"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::DstAlpha","text":"(dst.a, dst.a, dst.a, dst.a)","title":"DstAlpha"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor::OneMinusDstAlpha","text":"(1, 1, 1, 1) - (dst.a, dst.a, dst.a, dst.a)","title":"OneMinusDstAlpha"},{"location":"api/SF/BlendMode/Factor.html#methods","text":"","title":"Methods"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#dst_alpha?()","text":"[ View source ]","title":"#dst_alpha?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#dst_color?()","text":"[ View source ]","title":"#dst_color?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#one?()","text":"[ View source ]","title":"#one?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#one_minus_dst_alpha?()","text":"[ View source ]","title":"#one_minus_dst_alpha?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#one_minus_dst_color?()","text":"[ View source ]","title":"#one_minus_dst_color?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#one_minus_src_alpha?()","text":"[ View source ]","title":"#one_minus_src_alpha?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#one_minus_src_color?()","text":"[ View source ]","title":"#one_minus_src_color?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#src_alpha?()","text":"[ View source ]","title":"#src_alpha?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#src_color?()","text":"[ View source ]","title":"#src_color?"},{"location":"api/SF/BlendMode/Factor.html#SF::BlendMode::Factor#zero?()","text":"[ View source ]","title":"#zero?"},{"location":"api/SF/ContextSettings/Attribute.html","text":"enum SF::ContextSettings::Attribute # Enumeration of the context attribute flags Members # Default # Non-debug, compatibility context (this and the core attribute are mutually exclusive) Core # Core attribute Debug # Debug attribute Methods # #core? # [ View source ] #debug? # [ View source ] #default? # [ View source ] #none? # [ View source ]","title":"Attribute"},{"location":"api/SF/ContextSettings/Attribute.html#SF::ContextSettings::Attribute","text":"Enumeration of the context attribute flags","title":"Attribute"},{"location":"api/SF/ContextSettings/Attribute.html#members","text":"","title":"Members"},{"location":"api/SF/ContextSettings/Attribute.html#SF::ContextSettings::Attribute::Default","text":"Non-debug, compatibility context (this and the core attribute are mutually exclusive)","title":"Default"},{"location":"api/SF/ContextSettings/Attribute.html#SF::ContextSettings::Attribute::Core","text":"Core attribute","title":"Core"},{"location":"api/SF/ContextSettings/Attribute.html#SF::ContextSettings::Attribute::Debug","text":"Debug attribute","title":"Debug"},{"location":"api/SF/ContextSettings/Attribute.html#methods","text":"","title":"Methods"},{"location":"api/SF/ContextSettings/Attribute.html#SF::ContextSettings::Attribute#core?()","text":"[ View source ]","title":"#core?"},{"location":"api/SF/ContextSettings/Attribute.html#SF::ContextSettings::Attribute#debug?()","text":"[ View source ]","title":"#debug?"},{"location":"api/SF/ContextSettings/Attribute.html#SF::ContextSettings::Attribute#default?()","text":"[ View source ]","title":"#default?"},{"location":"api/SF/ContextSettings/Attribute.html#SF::ContextSettings::Attribute#none?()","text":"[ View source ]","title":"#none?"},{"location":"api/SF/Cursor/Type.html","text":"enum SF::Cursor::Type # Enumeration of the native system cursor types Refer to the following table to determine which cursor is available on which platform. Type Linux Mac OS X Windows SF::Cursor::Arrow yes yes yes SF::Cursor::ArrowWait no no yes SF::Cursor::Wait yes no yes SF::Cursor::Text yes yes yes SF::Cursor::Hand yes yes yes SF::Cursor::SizeHorizontal yes yes yes SF::Cursor::SizeVertical yes yes yes SF::Cursor::SizeTopLeftBottomRight no yes* yes SF::Cursor::SizeBottomLeftTopRight no yes* yes SF::Cursor::SizeAll yes no yes SF::Cursor::Cross yes yes yes SF::Cursor::Help yes yes* yes SF::Cursor::NotAllowed yes yes yes These cursor types are undocumented so may not be available on all versions, but have been tested on 10.13 Members # Arrow # Arrow cursor (default) ArrowWait # Busy arrow cursor Wait # Busy cursor Text # I-beam, cursor when hovering over a field allowing text entry Hand # Pointing hand cursor SizeHorizontal # Horizontal double arrow cursor SizeVertical # Vertical double arrow cursor SizeTopLeftBottomRight # Double arrow cursor going from top-left to bottom-right SizeBottomLeftTopRight # Double arrow cursor going from bottom-left to top-right SizeAll # Combination of SizeHorizontal and SizeVertical Cross # Crosshair cursor Help # Help cursor NotAllowed # Action not allowed cursor Methods # #arrow? # [ View source ] #arrow_wait? # [ View source ] #cross? # [ View source ] #hand? # [ View source ] #help? # [ View source ] #not_allowed? # [ View source ] #size_all? # [ View source ] #size_bottom_left_top_right? # [ View source ] #size_horizontal? # [ View source ] #size_top_left_bottom_right? # [ View source ] #size_vertical? # [ View source ] #text? # [ View source ] #wait? # [ View source ]","title":"Type"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type","text":"Enumeration of the native system cursor types Refer to the following table to determine which cursor is available on which platform. Type Linux Mac OS X Windows SF::Cursor::Arrow yes yes yes SF::Cursor::ArrowWait no no yes SF::Cursor::Wait yes no yes SF::Cursor::Text yes yes yes SF::Cursor::Hand yes yes yes SF::Cursor::SizeHorizontal yes yes yes SF::Cursor::SizeVertical yes yes yes SF::Cursor::SizeTopLeftBottomRight no yes* yes SF::Cursor::SizeBottomLeftTopRight no yes* yes SF::Cursor::SizeAll yes no yes SF::Cursor::Cross yes yes yes SF::Cursor::Help yes yes* yes SF::Cursor::NotAllowed yes yes yes These cursor types are undocumented so may not be available on all versions, but have been tested on 10.13","title":"Type"},{"location":"api/SF/Cursor/Type.html#members","text":"","title":"Members"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::Arrow","text":"Arrow cursor (default)","title":"Arrow"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::ArrowWait","text":"Busy arrow cursor","title":"ArrowWait"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::Wait","text":"Busy cursor","title":"Wait"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::Text","text":"I-beam, cursor when hovering over a field allowing text entry","title":"Text"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::Hand","text":"Pointing hand cursor","title":"Hand"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::SizeHorizontal","text":"Horizontal double arrow cursor","title":"SizeHorizontal"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::SizeVertical","text":"Vertical double arrow cursor","title":"SizeVertical"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::SizeTopLeftBottomRight","text":"Double arrow cursor going from top-left to bottom-right","title":"SizeTopLeftBottomRight"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::SizeBottomLeftTopRight","text":"Double arrow cursor going from bottom-left to top-right","title":"SizeBottomLeftTopRight"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::SizeAll","text":"Combination of SizeHorizontal and SizeVertical","title":"SizeAll"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::Cross","text":"Crosshair cursor","title":"Cross"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::Help","text":"Help cursor","title":"Help"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type::NotAllowed","text":"Action not allowed cursor","title":"NotAllowed"},{"location":"api/SF/Cursor/Type.html#methods","text":"","title":"Methods"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#arrow?()","text":"[ View source ]","title":"#arrow?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#arrow_wait?()","text":"[ View source ]","title":"#arrow_wait?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#cross?()","text":"[ View source ]","title":"#cross?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#hand?()","text":"[ View source ]","title":"#hand?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#help?()","text":"[ View source ]","title":"#help?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#not_allowed?()","text":"[ View source ]","title":"#not_allowed?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#size_all?()","text":"[ View source ]","title":"#size_all?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#size_bottom_left_top_right?()","text":"[ View source ]","title":"#size_bottom_left_top_right?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#size_horizontal?()","text":"[ View source ]","title":"#size_horizontal?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#size_top_left_bottom_right?()","text":"[ View source ]","title":"#size_top_left_bottom_right?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#size_vertical?()","text":"[ View source ]","title":"#size_vertical?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#text?()","text":"[ View source ]","title":"#text?"},{"location":"api/SF/Cursor/Type.html#SF::Cursor::Type#wait?()","text":"[ View source ]","title":"#wait?"},{"location":"api/SF/Event/Closed.html","text":"struct SF::Event::Closed inherits SF::Event # The window requested to be closed (no data)","title":"Closed"},{"location":"api/SF/Event/Closed.html#SF::Event::Closed","text":"The window requested to be closed (no data)","title":"Closed"},{"location":"api/SF/Event/GainedFocus.html","text":"struct SF::Event::GainedFocus inherits SF::Event # The window gained the focus (no data)","title":"GainedFocus"},{"location":"api/SF/Event/GainedFocus.html#SF::Event::GainedFocus","text":"The window gained the focus (no data)","title":"GainedFocus"},{"location":"api/SF/Event/JoystickButtonEvent.html","text":"abstract struct SF::Event::JoystickButtonEvent inherits SF::Event # Joystick buttons events parameters (JoystickButtonPressed, JoystickButtonReleased) Direct known subclasses # SF::Event::JoystickButtonPressed SF::Event::JoystickButtonReleased Class methods # .new # [ View source ] Methods # #button : UInt32 # Index of the button that has been pressed (in range 0 ... Joystick::ButtonCount ) [ View source ] #button= ( button : Int ) # [ View source ] #dup : JoystickButtonEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #joystick_id : UInt32 # Index of the joystick (in range 0 ... Joystick::Count ) [ View source ] #joystick_id= ( joystick_id : Int ) # [ View source ]","title":"JoystickButtonEvent"},{"location":"api/SF/Event/JoystickButtonEvent.html#SF::Event::JoystickButtonEvent","text":"Joystick buttons events parameters (JoystickButtonPressed, JoystickButtonReleased)","title":"JoystickButtonEvent"},{"location":"api/SF/Event/JoystickButtonEvent.html#direct-known-subclasses","text":"SF::Event::JoystickButtonPressed SF::Event::JoystickButtonReleased","title":"Direct known subclasses"},{"location":"api/SF/Event/JoystickButtonEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/JoystickButtonEvent.html#SF::Event::JoystickButtonEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/JoystickButtonEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/JoystickButtonEvent.html#SF::Event::JoystickButtonEvent#button()","text":"Index of the button that has been pressed (in range 0 ... Joystick::ButtonCount ) [ View source ]","title":"#button"},{"location":"api/SF/Event/JoystickButtonEvent.html#SF::Event::JoystickButtonEvent#button=(button)","text":"[ View source ]","title":"#button="},{"location":"api/SF/Event/JoystickButtonEvent.html#SF::Event::JoystickButtonEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/JoystickButtonEvent.html#SF::Event::JoystickButtonEvent#joystick_id()","text":"Index of the joystick (in range 0 ... Joystick::Count ) [ View source ]","title":"#joystick_id"},{"location":"api/SF/Event/JoystickButtonEvent.html#SF::Event::JoystickButtonEvent#joystick_id=(joystick_id)","text":"[ View source ]","title":"#joystick_id="},{"location":"api/SF/Event/JoystickButtonPressed.html","text":"struct SF::Event::JoystickButtonPressed inherits SF::Event::JoystickButtonEvent # A joystick button was pressed (data in event.joystick_button)","title":"JoystickButtonPressed"},{"location":"api/SF/Event/JoystickButtonPressed.html#SF::Event::JoystickButtonPressed","text":"A joystick button was pressed (data in event.joystick_button)","title":"JoystickButtonPressed"},{"location":"api/SF/Event/JoystickButtonReleased.html","text":"struct SF::Event::JoystickButtonReleased inherits SF::Event::JoystickButtonEvent # A joystick button was released (data in event.joystick_button)","title":"JoystickButtonReleased"},{"location":"api/SF/Event/JoystickButtonReleased.html#SF::Event::JoystickButtonReleased","text":"A joystick button was released (data in event.joystick_button)","title":"JoystickButtonReleased"},{"location":"api/SF/Event/JoystickConnectEvent.html","text":"abstract struct SF::Event::JoystickConnectEvent inherits SF::Event # Joystick connection events parameters (JoystickConnected, JoystickDisconnected) Direct known subclasses # SF::Event::JoystickConnected SF::Event::JoystickDisconnected Class methods # .new # [ View source ] Methods # #dup : JoystickConnectEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #joystick_id : UInt32 # Index of the joystick (in range 0 ... Joystick::Count ) [ View source ] #joystick_id= ( joystick_id : Int ) # [ View source ]","title":"JoystickConnectEvent"},{"location":"api/SF/Event/JoystickConnectEvent.html#SF::Event::JoystickConnectEvent","text":"Joystick connection events parameters (JoystickConnected, JoystickDisconnected)","title":"JoystickConnectEvent"},{"location":"api/SF/Event/JoystickConnectEvent.html#direct-known-subclasses","text":"SF::Event::JoystickConnected SF::Event::JoystickDisconnected","title":"Direct known subclasses"},{"location":"api/SF/Event/JoystickConnectEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/JoystickConnectEvent.html#SF::Event::JoystickConnectEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/JoystickConnectEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/JoystickConnectEvent.html#SF::Event::JoystickConnectEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/JoystickConnectEvent.html#SF::Event::JoystickConnectEvent#joystick_id()","text":"Index of the joystick (in range 0 ... Joystick::Count ) [ View source ]","title":"#joystick_id"},{"location":"api/SF/Event/JoystickConnectEvent.html#SF::Event::JoystickConnectEvent#joystick_id=(joystick_id)","text":"[ View source ]","title":"#joystick_id="},{"location":"api/SF/Event/JoystickConnected.html","text":"struct SF::Event::JoystickConnected inherits SF::Event::JoystickConnectEvent # A joystick was connected (data in event.joystick_connect)","title":"JoystickConnected"},{"location":"api/SF/Event/JoystickConnected.html#SF::Event::JoystickConnected","text":"A joystick was connected (data in event.joystick_connect)","title":"JoystickConnected"},{"location":"api/SF/Event/JoystickDisconnected.html","text":"struct SF::Event::JoystickDisconnected inherits SF::Event::JoystickConnectEvent # A joystick was disconnected (data in event.joystick_connect)","title":"JoystickDisconnected"},{"location":"api/SF/Event/JoystickDisconnected.html#SF::Event::JoystickDisconnected","text":"A joystick was disconnected (data in event.joystick_connect)","title":"JoystickDisconnected"},{"location":"api/SF/Event/JoystickMoveEvent.html","text":"abstract struct SF::Event::JoystickMoveEvent inherits SF::Event # Joystick axis move event parameters (JoystickMoved) Direct known subclasses # SF::Event::JoystickMoved Class methods # .new # [ View source ] Methods # #axis : Joystick :: Axis # Axis on which the joystick moved [ View source ] #axis= ( axis : Joystick :: Axis ) # [ View source ] #dup : JoystickMoveEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #joystick_id : UInt32 # Index of the joystick (in range 0 ... Joystick::Count ) [ View source ] #joystick_id= ( joystick_id : Int ) # [ View source ] #position : Float32 # New position on the axis (in range -100 .. 100 ) [ View source ] #position= ( position : Number ) # [ View source ]","title":"JoystickMoveEvent"},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent","text":"Joystick axis move event parameters (JoystickMoved)","title":"JoystickMoveEvent"},{"location":"api/SF/Event/JoystickMoveEvent.html#direct-known-subclasses","text":"SF::Event::JoystickMoved","title":"Direct known subclasses"},{"location":"api/SF/Event/JoystickMoveEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/JoystickMoveEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent#axis()","text":"Axis on which the joystick moved [ View source ]","title":"#axis"},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent#axis=(axis)","text":"[ View source ]","title":"#axis="},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent#joystick_id()","text":"Index of the joystick (in range 0 ... Joystick::Count ) [ View source ]","title":"#joystick_id"},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent#joystick_id=(joystick_id)","text":"[ View source ]","title":"#joystick_id="},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent#position()","text":"New position on the axis (in range -100 .. 100 ) [ View source ]","title":"#position"},{"location":"api/SF/Event/JoystickMoveEvent.html#SF::Event::JoystickMoveEvent#position=(position)","text":"[ View source ]","title":"#position="},{"location":"api/SF/Event/JoystickMoved.html","text":"struct SF::Event::JoystickMoved inherits SF::Event::JoystickMoveEvent # The joystick moved along an axis (data in event.joystick_move)","title":"JoystickMoved"},{"location":"api/SF/Event/JoystickMoved.html#SF::Event::JoystickMoved","text":"The joystick moved along an axis (data in event.joystick_move)","title":"JoystickMoved"},{"location":"api/SF/Event/KeyEvent.html","text":"abstract struct SF::Event::KeyEvent inherits SF::Event # Keyboard event parameters (KeyPressed, KeyReleased) Direct known subclasses # SF::Event::KeyPressed SF::Event::KeyReleased Class methods # .new # [ View source ] Methods # #alt : Bool # Is the Alt key pressed? [ View source ] #alt= ( alt : Bool ) # [ View source ] #code : Keyboard :: Key # Code of the key that has been pressed [ View source ] #code= ( code : Keyboard :: Key ) # [ View source ] #control : Bool # Is the Control key pressed? [ View source ] #control= ( control : Bool ) # [ View source ] #dup : KeyEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #shift : Bool # Is the Shift key pressed? [ View source ] #shift= ( shift : Bool ) # [ View source ] #system : Bool # Is the System key pressed? [ View source ] #system= ( system : Bool ) # [ View source ]","title":"KeyEvent"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent","text":"Keyboard event parameters (KeyPressed, KeyReleased)","title":"KeyEvent"},{"location":"api/SF/Event/KeyEvent.html#direct-known-subclasses","text":"SF::Event::KeyPressed SF::Event::KeyReleased","title":"Direct known subclasses"},{"location":"api/SF/Event/KeyEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/KeyEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#alt()","text":"Is the Alt key pressed? [ View source ]","title":"#alt"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#alt=(alt)","text":"[ View source ]","title":"#alt="},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#code()","text":"Code of the key that has been pressed [ View source ]","title":"#code"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#code=(code)","text":"[ View source ]","title":"#code="},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#control()","text":"Is the Control key pressed? [ View source ]","title":"#control"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#control=(control)","text":"[ View source ]","title":"#control="},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#shift()","text":"Is the Shift key pressed? [ View source ]","title":"#shift"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#shift=(shift)","text":"[ View source ]","title":"#shift="},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#system()","text":"Is the System key pressed? [ View source ]","title":"#system"},{"location":"api/SF/Event/KeyEvent.html#SF::Event::KeyEvent#system=(system)","text":"[ View source ]","title":"#system="},{"location":"api/SF/Event/KeyPressed.html","text":"struct SF::Event::KeyPressed inherits SF::Event::KeyEvent # A key was pressed (data in event.key)","title":"KeyPressed"},{"location":"api/SF/Event/KeyPressed.html#SF::Event::KeyPressed","text":"A key was pressed (data in event.key)","title":"KeyPressed"},{"location":"api/SF/Event/KeyReleased.html","text":"struct SF::Event::KeyReleased inherits SF::Event::KeyEvent # A key was released (data in event.key)","title":"KeyReleased"},{"location":"api/SF/Event/KeyReleased.html#SF::Event::KeyReleased","text":"A key was released (data in event.key)","title":"KeyReleased"},{"location":"api/SF/Event/LostFocus.html","text":"struct SF::Event::LostFocus inherits SF::Event # The window lost the focus (no data)","title":"LostFocus"},{"location":"api/SF/Event/LostFocus.html#SF::Event::LostFocus","text":"The window lost the focus (no data)","title":"LostFocus"},{"location":"api/SF/Event/MouseButtonEvent.html","text":"abstract struct SF::Event::MouseButtonEvent inherits SF::Event # Mouse buttons events parameters (MouseButtonPressed, MouseButtonReleased) Direct known subclasses # SF::Event::MouseButtonPressed SF::Event::MouseButtonReleased Class methods # .new # [ View source ] Methods # #button : Mouse :: Button # Code of the button that has been pressed [ View source ] #button= ( button : Mouse :: Button ) # [ View source ] #dup : MouseButtonEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #x : Int32 # X position of the mouse pointer, relative to the left of the owner window [ View source ] #x= ( x : Int ) # [ View source ] #y : Int32 # Y position of the mouse pointer, relative to the top of the owner window [ View source ] #y= ( y : Int ) # [ View source ]","title":"MouseButtonEvent"},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent","text":"Mouse buttons events parameters (MouseButtonPressed, MouseButtonReleased)","title":"MouseButtonEvent"},{"location":"api/SF/Event/MouseButtonEvent.html#direct-known-subclasses","text":"SF::Event::MouseButtonPressed SF::Event::MouseButtonReleased","title":"Direct known subclasses"},{"location":"api/SF/Event/MouseButtonEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/MouseButtonEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent#button()","text":"Code of the button that has been pressed [ View source ]","title":"#button"},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent#button=(button)","text":"[ View source ]","title":"#button="},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent#x()","text":"X position of the mouse pointer, relative to the left of the owner window [ View source ]","title":"#x"},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent#x=(x)","text":"[ View source ]","title":"#x="},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent#y()","text":"Y position of the mouse pointer, relative to the top of the owner window [ View source ]","title":"#y"},{"location":"api/SF/Event/MouseButtonEvent.html#SF::Event::MouseButtonEvent#y=(y)","text":"[ View source ]","title":"#y="},{"location":"api/SF/Event/MouseButtonPressed.html","text":"struct SF::Event::MouseButtonPressed inherits SF::Event::MouseButtonEvent # A mouse button was pressed (data in event.mouse_button)","title":"MouseButtonPressed"},{"location":"api/SF/Event/MouseButtonPressed.html#SF::Event::MouseButtonPressed","text":"A mouse button was pressed (data in event.mouse_button)","title":"MouseButtonPressed"},{"location":"api/SF/Event/MouseButtonReleased.html","text":"struct SF::Event::MouseButtonReleased inherits SF::Event::MouseButtonEvent # A mouse button was released (data in event.mouse_button)","title":"MouseButtonReleased"},{"location":"api/SF/Event/MouseButtonReleased.html#SF::Event::MouseButtonReleased","text":"A mouse button was released (data in event.mouse_button)","title":"MouseButtonReleased"},{"location":"api/SF/Event/MouseEntered.html","text":"struct SF::Event::MouseEntered inherits SF::Event # The mouse cursor entered the area of the window (no data)","title":"MouseEntered"},{"location":"api/SF/Event/MouseEntered.html#SF::Event::MouseEntered","text":"The mouse cursor entered the area of the window (no data)","title":"MouseEntered"},{"location":"api/SF/Event/MouseLeft.html","text":"struct SF::Event::MouseLeft inherits SF::Event # The mouse cursor left the area of the window (no data)","title":"MouseLeft"},{"location":"api/SF/Event/MouseLeft.html#SF::Event::MouseLeft","text":"The mouse cursor left the area of the window (no data)","title":"MouseLeft"},{"location":"api/SF/Event/MouseMoveEvent.html","text":"abstract struct SF::Event::MouseMoveEvent inherits SF::Event # Mouse move event parameters (MouseMoved) Direct known subclasses # SF::Event::MouseMoved Class methods # .new # [ View source ] Methods # #dup : MouseMoveEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #x : Int32 # X position of the mouse pointer, relative to the left of the owner window [ View source ] #x= ( x : Int ) # [ View source ] #y : Int32 # Y position of the mouse pointer, relative to the top of the owner window [ View source ] #y= ( y : Int ) # [ View source ]","title":"MouseMoveEvent"},{"location":"api/SF/Event/MouseMoveEvent.html#SF::Event::MouseMoveEvent","text":"Mouse move event parameters (MouseMoved)","title":"MouseMoveEvent"},{"location":"api/SF/Event/MouseMoveEvent.html#direct-known-subclasses","text":"SF::Event::MouseMoved","title":"Direct known subclasses"},{"location":"api/SF/Event/MouseMoveEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/MouseMoveEvent.html#SF::Event::MouseMoveEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/MouseMoveEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/MouseMoveEvent.html#SF::Event::MouseMoveEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/MouseMoveEvent.html#SF::Event::MouseMoveEvent#x()","text":"X position of the mouse pointer, relative to the left of the owner window [ View source ]","title":"#x"},{"location":"api/SF/Event/MouseMoveEvent.html#SF::Event::MouseMoveEvent#x=(x)","text":"[ View source ]","title":"#x="},{"location":"api/SF/Event/MouseMoveEvent.html#SF::Event::MouseMoveEvent#y()","text":"Y position of the mouse pointer, relative to the top of the owner window [ View source ]","title":"#y"},{"location":"api/SF/Event/MouseMoveEvent.html#SF::Event::MouseMoveEvent#y=(y)","text":"[ View source ]","title":"#y="},{"location":"api/SF/Event/MouseMoved.html","text":"struct SF::Event::MouseMoved inherits SF::Event::MouseMoveEvent # The mouse cursor moved (data in event.mouse_move)","title":"MouseMoved"},{"location":"api/SF/Event/MouseMoved.html#SF::Event::MouseMoved","text":"The mouse cursor moved (data in event.mouse_move)","title":"MouseMoved"},{"location":"api/SF/Event/MouseWheelEvent.html","text":"abstract struct SF::Event::MouseWheelEvent inherits SF::Event # Mouse wheel events parameters (MouseWheelMoved) DEPRECATED: This event is deprecated and potentially inaccurate. Use MouseWheelScrollEvent instead. Direct known subclasses # SF::Event::MouseWheelMoved Class methods # .new # [ View source ] Methods # #delta : Int32 # Number of ticks the wheel has moved (positive is up, negative is down) [ View source ] #delta= ( delta : Int ) # [ View source ] #dup : MouseWheelEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #x : Int32 # X position of the mouse pointer, relative to the left of the owner window [ View source ] #x= ( x : Int ) # [ View source ] #y : Int32 # Y position of the mouse pointer, relative to the top of the owner window [ View source ] #y= ( y : Int ) # [ View source ]","title":"MouseWheelEvent"},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent","text":"Mouse wheel events parameters (MouseWheelMoved) DEPRECATED: This event is deprecated and potentially inaccurate. Use MouseWheelScrollEvent instead.","title":"MouseWheelEvent"},{"location":"api/SF/Event/MouseWheelEvent.html#direct-known-subclasses","text":"SF::Event::MouseWheelMoved","title":"Direct known subclasses"},{"location":"api/SF/Event/MouseWheelEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/MouseWheelEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent#delta()","text":"Number of ticks the wheel has moved (positive is up, negative is down) [ View source ]","title":"#delta"},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent#delta=(delta)","text":"[ View source ]","title":"#delta="},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent#x()","text":"X position of the mouse pointer, relative to the left of the owner window [ View source ]","title":"#x"},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent#x=(x)","text":"[ View source ]","title":"#x="},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent#y()","text":"Y position of the mouse pointer, relative to the top of the owner window [ View source ]","title":"#y"},{"location":"api/SF/Event/MouseWheelEvent.html#SF::Event::MouseWheelEvent#y=(y)","text":"[ View source ]","title":"#y="},{"location":"api/SF/Event/MouseWheelMoved.html","text":"struct SF::Event::MouseWheelMoved inherits SF::Event::MouseWheelEvent # The mouse wheel was scrolled (data in event.mouse_wheel) (deprecated)","title":"MouseWheelMoved"},{"location":"api/SF/Event/MouseWheelMoved.html#SF::Event::MouseWheelMoved","text":"The mouse wheel was scrolled (data in event.mouse_wheel) (deprecated)","title":"MouseWheelMoved"},{"location":"api/SF/Event/MouseWheelScrollEvent.html","text":"abstract struct SF::Event::MouseWheelScrollEvent inherits SF::Event # Mouse wheel events parameters (MouseWheelScrolled) Direct known subclasses # SF::Event::MouseWheelScrolled Class methods # .new # [ View source ] Methods # #delta : Float32 # Wheel offset (positive is up/left, negative is down/right). High-precision mice may use non-integral offsets. [ View source ] #delta= ( delta : Number ) # [ View source ] #dup : MouseWheelScrollEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #wheel : Mouse :: Wheel # Which wheel (for mice with multiple ones) [ View source ] #wheel= ( wheel : Mouse :: Wheel ) # [ View source ] #x : Int32 # X position of the mouse pointer, relative to the left of the owner window [ View source ] #x= ( x : Int ) # [ View source ] #y : Int32 # Y position of the mouse pointer, relative to the top of the owner window [ View source ] #y= ( y : Int ) # [ View source ]","title":"MouseWheelScrollEvent"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent","text":"Mouse wheel events parameters (MouseWheelScrolled)","title":"MouseWheelScrollEvent"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#direct-known-subclasses","text":"SF::Event::MouseWheelScrolled","title":"Direct known subclasses"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#delta()","text":"Wheel offset (positive is up/left, negative is down/right). High-precision mice may use non-integral offsets. [ View source ]","title":"#delta"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#delta=(delta)","text":"[ View source ]","title":"#delta="},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#wheel()","text":"Which wheel (for mice with multiple ones) [ View source ]","title":"#wheel"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#wheel=(wheel)","text":"[ View source ]","title":"#wheel="},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#x()","text":"X position of the mouse pointer, relative to the left of the owner window [ View source ]","title":"#x"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#x=(x)","text":"[ View source ]","title":"#x="},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#y()","text":"Y position of the mouse pointer, relative to the top of the owner window [ View source ]","title":"#y"},{"location":"api/SF/Event/MouseWheelScrollEvent.html#SF::Event::MouseWheelScrollEvent#y=(y)","text":"[ View source ]","title":"#y="},{"location":"api/SF/Event/MouseWheelScrolled.html","text":"struct SF::Event::MouseWheelScrolled inherits SF::Event::MouseWheelScrollEvent # The mouse wheel was scrolled (data in event.mouse_wheel_scroll)","title":"MouseWheelScrolled"},{"location":"api/SF/Event/MouseWheelScrolled.html#SF::Event::MouseWheelScrolled","text":"The mouse wheel was scrolled (data in event.mouse_wheel_scroll)","title":"MouseWheelScrolled"},{"location":"api/SF/Event/Resized.html","text":"struct SF::Event::Resized inherits SF::Event::SizeEvent # The window was resized (data in event.size)","title":"Resized"},{"location":"api/SF/Event/Resized.html#SF::Event::Resized","text":"The window was resized (data in event.size)","title":"Resized"},{"location":"api/SF/Event/SensorChanged.html","text":"struct SF::Event::SensorChanged inherits SF::Event::SensorEvent # A sensor value changed (data in event.sensor)","title":"SensorChanged"},{"location":"api/SF/Event/SensorChanged.html#SF::Event::SensorChanged","text":"A sensor value changed (data in event.sensor)","title":"SensorChanged"},{"location":"api/SF/Event/SensorEvent.html","text":"abstract struct SF::Event::SensorEvent inherits SF::Event # Sensor event parameters (SensorChanged) Direct known subclasses # SF::Event::SensorChanged Class methods # .new # [ View source ] Methods # #dup : SensorEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #type : Sensor :: Type # Type of the sensor [ View source ] #type= ( type : Sensor :: Type ) # [ View source ] #x : Float32 # Current value of the sensor on X axis [ View source ] #x= ( x : Number ) # [ View source ] #y : Float32 # Current value of the sensor on Y axis [ View source ] #y= ( y : Number ) # [ View source ] #z : Float32 # Current value of the sensor on Z axis [ View source ] #z= ( z : Number ) # [ View source ]","title":"SensorEvent"},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent","text":"Sensor event parameters (SensorChanged)","title":"SensorEvent"},{"location":"api/SF/Event/SensorEvent.html#direct-known-subclasses","text":"SF::Event::SensorChanged","title":"Direct known subclasses"},{"location":"api/SF/Event/SensorEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/SensorEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#type()","text":"Type of the sensor [ View source ]","title":"#type"},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#type=(type)","text":"[ View source ]","title":"#type="},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#x()","text":"Current value of the sensor on X axis [ View source ]","title":"#x"},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#x=(x)","text":"[ View source ]","title":"#x="},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#y()","text":"Current value of the sensor on Y axis [ View source ]","title":"#y"},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#y=(y)","text":"[ View source ]","title":"#y="},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#z()","text":"Current value of the sensor on Z axis [ View source ]","title":"#z"},{"location":"api/SF/Event/SensorEvent.html#SF::Event::SensorEvent#z=(z)","text":"[ View source ]","title":"#z="},{"location":"api/SF/Event/SizeEvent.html","text":"abstract struct SF::Event::SizeEvent inherits SF::Event # Size events parameters (Resized) Direct known subclasses # SF::Event::Resized Class methods # .new # [ View source ] Methods # #dup : SizeEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #height : UInt32 # New height, in pixels [ View source ] #height= ( height : Int ) # [ View source ] #width : UInt32 # New width, in pixels [ View source ] #width= ( width : Int ) # [ View source ]","title":"SizeEvent"},{"location":"api/SF/Event/SizeEvent.html#SF::Event::SizeEvent","text":"Size events parameters (Resized)","title":"SizeEvent"},{"location":"api/SF/Event/SizeEvent.html#direct-known-subclasses","text":"SF::Event::Resized","title":"Direct known subclasses"},{"location":"api/SF/Event/SizeEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/SizeEvent.html#SF::Event::SizeEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/SizeEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/SizeEvent.html#SF::Event::SizeEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/SizeEvent.html#SF::Event::SizeEvent#height()","text":"New height, in pixels [ View source ]","title":"#height"},{"location":"api/SF/Event/SizeEvent.html#SF::Event::SizeEvent#height=(height)","text":"[ View source ]","title":"#height="},{"location":"api/SF/Event/SizeEvent.html#SF::Event::SizeEvent#width()","text":"New width, in pixels [ View source ]","title":"#width"},{"location":"api/SF/Event/SizeEvent.html#SF::Event::SizeEvent#width=(width)","text":"[ View source ]","title":"#width="},{"location":"api/SF/Event/TextEntered.html","text":"struct SF::Event::TextEntered inherits SF::Event::TextEvent # A character was entered (data in event.text)","title":"TextEntered"},{"location":"api/SF/Event/TextEntered.html#SF::Event::TextEntered","text":"A character was entered (data in event.text)","title":"TextEntered"},{"location":"api/SF/Event/TextEvent.html","text":"abstract struct SF::Event::TextEvent inherits SF::Event # Text event parameters (TextEntered) Direct known subclasses # SF::Event::TextEntered Class methods # .new # [ View source ] Methods # #dup : TextEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #unicode : UInt32 # UTF-32 Unicode value of the character [ View source ] #unicode= ( unicode : Int ) # [ View source ]","title":"TextEvent"},{"location":"api/SF/Event/TextEvent.html#SF::Event::TextEvent","text":"Text event parameters (TextEntered)","title":"TextEvent"},{"location":"api/SF/Event/TextEvent.html#direct-known-subclasses","text":"SF::Event::TextEntered","title":"Direct known subclasses"},{"location":"api/SF/Event/TextEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/TextEvent.html#SF::Event::TextEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/TextEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/TextEvent.html#SF::Event::TextEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/TextEvent.html#SF::Event::TextEvent#unicode()","text":"UTF-32 Unicode value of the character [ View source ]","title":"#unicode"},{"location":"api/SF/Event/TextEvent.html#SF::Event::TextEvent#unicode=(unicode)","text":"[ View source ]","title":"#unicode="},{"location":"api/SF/Event/TouchBegan.html","text":"struct SF::Event::TouchBegan inherits SF::Event::TouchEvent # A touch event began (data in event.touch)","title":"TouchBegan"},{"location":"api/SF/Event/TouchBegan.html#SF::Event::TouchBegan","text":"A touch event began (data in event.touch)","title":"TouchBegan"},{"location":"api/SF/Event/TouchEnded.html","text":"struct SF::Event::TouchEnded inherits SF::Event::TouchEvent # A touch event ended (data in event.touch)","title":"TouchEnded"},{"location":"api/SF/Event/TouchEnded.html#SF::Event::TouchEnded","text":"A touch event ended (data in event.touch)","title":"TouchEnded"},{"location":"api/SF/Event/TouchEvent.html","text":"abstract struct SF::Event::TouchEvent inherits SF::Event # Touch events parameters (TouchBegan, TouchMoved, TouchEnded) Direct known subclasses # SF::Event::TouchBegan SF::Event::TouchEnded SF::Event::TouchMoved Class methods # .new # [ View source ] Methods # #dup : TouchEvent # Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ] #finger : UInt32 # Index of the finger in case of multi-touch events [ View source ] #finger= ( finger : Int ) # [ View source ] #x : Int32 # X position of the touch, relative to the left of the owner window [ View source ] #x= ( x : Int ) # [ View source ] #y : Int32 # Y position of the touch, relative to the top of the owner window [ View source ] #y= ( y : Int ) # [ View source ]","title":"TouchEvent"},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent","text":"Touch events parameters (TouchBegan, TouchMoved, TouchEnded)","title":"TouchEvent"},{"location":"api/SF/Event/TouchEvent.html#direct-known-subclasses","text":"SF::Event::TouchBegan SF::Event::TouchEnded SF::Event::TouchMoved","title":"Direct known subclasses"},{"location":"api/SF/Event/TouchEvent.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Event/TouchEvent.html#methods","text":"","title":"Methods"},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent#dup()","text":"Returns a shallow copy of this object. Because Value is a value type, this method returns self , which already involves a shallow copy of this object because value types are passed by value. [ View source ]","title":"#dup"},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent#finger()","text":"Index of the finger in case of multi-touch events [ View source ]","title":"#finger"},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent#finger=(finger)","text":"[ View source ]","title":"#finger="},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent#x()","text":"X position of the touch, relative to the left of the owner window [ View source ]","title":"#x"},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent#x=(x)","text":"[ View source ]","title":"#x="},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent#y()","text":"Y position of the touch, relative to the top of the owner window [ View source ]","title":"#y"},{"location":"api/SF/Event/TouchEvent.html#SF::Event::TouchEvent#y=(y)","text":"[ View source ]","title":"#y="},{"location":"api/SF/Event/TouchMoved.html","text":"struct SF::Event::TouchMoved inherits SF::Event::TouchEvent # A touch moved (data in event.touch)","title":"TouchMoved"},{"location":"api/SF/Event/TouchMoved.html#SF::Event::TouchMoved","text":"A touch moved (data in event.touch)","title":"TouchMoved"},{"location":"api/SF/Font/Info.html","text":"class SF::Font::Info inherits Reference # Holds various information about a font Class methods # .new # [ View source ] Methods # #dup : Info # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #family : String # The font family [ View source ] #family= ( family : String ) # [ View source ] #finalize # [ View source ]","title":"Info"},{"location":"api/SF/Font/Info.html#SF::Font::Info","text":"Holds various information about a font","title":"Info"},{"location":"api/SF/Font/Info.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Font/Info.html#SF::Font::Info.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Font/Info.html#methods","text":"","title":"Methods"},{"location":"api/SF/Font/Info.html#SF::Font::Info#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Font/Info.html#SF::Font::Info#family()","text":"The font family [ View source ]","title":"#family"},{"location":"api/SF/Font/Info.html#SF::Font::Info#family=(family)","text":"[ View source ]","title":"#family="},{"location":"api/SF/Font/Info.html#SF::Font::Info#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Ftp/DirectoryResponse.html","text":"class SF::Ftp::DirectoryResponse inherits SF::Ftp::Response # Specialization of FTP response returning a directory Class methods # .new ( response : Ftp :: Response ) # Default constructor response - Source response [ View source ] Methods # #directory : String # Get the directory returned in the response Returns: Directory name [ View source ] #dup : DirectoryResponse # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ]","title":"DirectoryResponse"},{"location":"api/SF/Ftp/DirectoryResponse.html#SF::Ftp::DirectoryResponse","text":"Specialization of FTP response returning a directory","title":"DirectoryResponse"},{"location":"api/SF/Ftp/DirectoryResponse.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Ftp/DirectoryResponse.html#SF::Ftp::DirectoryResponse.new(response)","text":"Default constructor response - Source response [ View source ]","title":".new"},{"location":"api/SF/Ftp/DirectoryResponse.html#methods","text":"","title":"Methods"},{"location":"api/SF/Ftp/DirectoryResponse.html#SF::Ftp::DirectoryResponse#directory()","text":"Get the directory returned in the response Returns: Directory name [ View source ]","title":"#directory"},{"location":"api/SF/Ftp/DirectoryResponse.html#SF::Ftp::DirectoryResponse#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Ftp/DirectoryResponse.html#SF::Ftp::DirectoryResponse#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Ftp/ListingResponse.html","text":"class SF::Ftp::ListingResponse inherits SF::Ftp::Response # Specialization of FTP response returning a filename listing Class methods # .new ( response : Ftp :: Response , data : String ) # Default constructor response - Source response data - Data containing the raw listing [ View source ] Methods # #dup : ListingResponse # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ] #listing : Array ( String ) # Return the array of directory/file names Returns: Array containing the requested listing [ View source ]","title":"ListingResponse"},{"location":"api/SF/Ftp/ListingResponse.html#SF::Ftp::ListingResponse","text":"Specialization of FTP response returning a filename listing","title":"ListingResponse"},{"location":"api/SF/Ftp/ListingResponse.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Ftp/ListingResponse.html#SF::Ftp::ListingResponse.new(response,data)","text":"Default constructor response - Source response data - Data containing the raw listing [ View source ]","title":".new"},{"location":"api/SF/Ftp/ListingResponse.html#methods","text":"","title":"Methods"},{"location":"api/SF/Ftp/ListingResponse.html#SF::Ftp::ListingResponse#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Ftp/ListingResponse.html#SF::Ftp::ListingResponse#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Ftp/ListingResponse.html#SF::Ftp::ListingResponse#listing()","text":"Return the array of directory/file names Returns: Array containing the requested listing [ View source ]","title":"#listing"},{"location":"api/SF/Ftp/Response.html","text":"class SF::Ftp::Response inherits Reference # Define a FTP response Direct known subclasses # SF::Ftp::DirectoryResponse SF::Ftp::ListingResponse Class methods # .new ( code : Ftp :: Response :: Status = InvalidResponse , message : String = \"\" ) # Default constructor This constructor is used by the FTP client to build the response. code - Response status code message - Response message [ View source ] Methods # #dup : Response # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ] #message : String # Get the full message contained in the response Returns: The response message [ View source ] #ok? : Bool # Check if the status code means a success This function is defined for convenience, it is equivalent to testing if the status code is < 400. Returns: True if the status is a success, false if it is a failure [ View source ] #status : Ftp :: Response :: Status # Get the status code of the response Returns: Status code [ View source ]","title":"Response"},{"location":"api/SF/Ftp/Response.html#SF::Ftp::Response","text":"Define a FTP response","title":"Response"},{"location":"api/SF/Ftp/Response.html#direct-known-subclasses","text":"SF::Ftp::DirectoryResponse SF::Ftp::ListingResponse","title":"Direct known subclasses"},{"location":"api/SF/Ftp/Response.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Ftp/Response.html#SF::Ftp::Response.new(code,message)","text":"Default constructor This constructor is used by the FTP client to build the response. code - Response status code message - Response message [ View source ]","title":".new"},{"location":"api/SF/Ftp/Response.html#methods","text":"","title":"Methods"},{"location":"api/SF/Ftp/Response.html#SF::Ftp::Response#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Ftp/Response.html#SF::Ftp::Response#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Ftp/Response.html#SF::Ftp::Response#message()","text":"Get the full message contained in the response Returns: The response message [ View source ]","title":"#message"},{"location":"api/SF/Ftp/Response.html#SF::Ftp::Response#ok?()","text":"Check if the status code means a success This function is defined for convenience, it is equivalent to testing if the status code is < 400. Returns: True if the status is a success, false if it is a failure [ View source ]","title":"#ok?"},{"location":"api/SF/Ftp/Response.html#SF::Ftp::Response#status()","text":"Get the status code of the response Returns: Status code [ View source ]","title":"#status"},{"location":"api/SF/Ftp/TransferMode.html","text":"enum SF::Ftp::TransferMode # Enumeration of transfer modes Members # Binary # Binary mode (file is transfered as a sequence of bytes) Ascii # Text mode using ASCII encoding Ebcdic # Text mode using EBCDIC encoding Methods # #ascii? # [ View source ] #binary? # [ View source ] #ebcdic? # [ View source ]","title":"TransferMode"},{"location":"api/SF/Ftp/TransferMode.html#SF::Ftp::TransferMode","text":"Enumeration of transfer modes","title":"TransferMode"},{"location":"api/SF/Ftp/TransferMode.html#members","text":"","title":"Members"},{"location":"api/SF/Ftp/TransferMode.html#SF::Ftp::TransferMode::Binary","text":"Binary mode (file is transfered as a sequence of bytes)","title":"Binary"},{"location":"api/SF/Ftp/TransferMode.html#SF::Ftp::TransferMode::Ascii","text":"Text mode using ASCII encoding","title":"Ascii"},{"location":"api/SF/Ftp/TransferMode.html#SF::Ftp::TransferMode::Ebcdic","text":"Text mode using EBCDIC encoding","title":"Ebcdic"},{"location":"api/SF/Ftp/TransferMode.html#methods","text":"","title":"Methods"},{"location":"api/SF/Ftp/TransferMode.html#SF::Ftp::TransferMode#ascii?()","text":"[ View source ]","title":"#ascii?"},{"location":"api/SF/Ftp/TransferMode.html#SF::Ftp::TransferMode#binary?()","text":"[ View source ]","title":"#binary?"},{"location":"api/SF/Ftp/TransferMode.html#SF::Ftp::TransferMode#ebcdic?()","text":"[ View source ]","title":"#ebcdic?"},{"location":"api/SF/Ftp/Response/Status.html","text":"enum SF::Ftp::Response::Status # Status codes possibly returned by a FTP response Members # RestartMarkerReply # Restart marker reply ServiceReadySoon # Service ready in N minutes DataConnectionAlreadyOpened # Data connection already opened, transfer starting OpeningDataConnection # File status ok, about to open data connection Ok # Command ok PointlessCommand # Command not implemented SystemStatus # System status, or system help reply DirectoryStatus # Directory status FileStatus # File status HelpMessage # Help message SystemType # NAME system type, where NAME is an official system name from the list in the Assigned Numbers document ServiceReady # Service ready for new user ClosingConnection # Service closing control connection DataConnectionOpened # Data connection open, no transfer in progress ClosingDataConnection # Closing data connection, requested file action successful EnteringPassiveMode # Entering passive mode LoggedIn # User logged in, proceed. Logged out if appropriate FileActionOk # Requested file action ok DirectoryOk # PATHNAME created NeedPassword # User name ok, need password NeedAccountToLogIn # Need account for login NeedInformation # Requested file action pending further information ServiceUnavailable # Service not available, closing control connection DataConnectionUnavailable # Can't open data connection TransferAborted # Connection closed, transfer aborted FileActionAborted # Requested file action not taken LocalError # Requested action aborted, local error in processing InsufficientStorageSpace # Requested action not taken; insufficient storage space in system, file unavailable CommandUnknown # Syntax error, command unrecognized ParametersUnknown # Syntax error in parameters or arguments CommandNotImplemented # Command not implemented BadCommandSequence # Bad sequence of commands ParameterNotImplemented # Command not implemented for that parameter NotLoggedIn # Not logged in NeedAccountToStore # Need account for storing files FileUnavailable # Requested action not taken, file unavailable PageTypeUnknown # Requested action aborted, page type unknown NotEnoughMemory # Requested file action aborted, exceeded storage allocation FilenameNotAllowed # Requested action not taken, file name not allowed InvalidResponse # Not part of the FTP standard, generated by SFML when a received response cannot be parsed ConnectionFailed # Not part of the FTP standard, generated by SFML when the low-level socket connection with the server fails ConnectionClosed # Not part of the FTP standard, generated by SFML when the low-level socket connection is unexpectedly closed InvalidFile # Not part of the FTP standard, generated by SFML when a local file cannot be read or written Methods # #bad_command_sequence? # [ View source ] #closing_connection? # [ View source ] #closing_data_connection? # [ View source ] #command_not_implemented? # [ View source ] #command_unknown? # [ View source ] #connection_closed? # [ View source ] #connection_failed? # [ View source ] #data_connection_already_opened? # [ View source ] #data_connection_opened? # [ View source ] #data_connection_unavailable? # [ View source ] #directory_ok? # [ View source ] #directory_status? # [ View source ] #entering_passive_mode? # [ View source ] #file_action_aborted? # [ View source ] #file_action_ok? # [ View source ] #file_status? # [ View source ] #file_unavailable? # [ View source ] #filename_not_allowed? # [ View source ] #help_message? # [ View source ] #insufficient_storage_space? # [ View source ] #invalid_file? # [ View source ] #invalid_response? # [ View source ] #local_error? # [ View source ] #logged_in? # [ View source ] #need_account_to_log_in? # [ View source ] #need_account_to_store? # [ View source ] #need_information? # [ View source ] #need_password? # [ View source ] #not_enough_memory? # [ View source ] #not_logged_in? # [ View source ] #ok? # [ View source ] #opening_data_connection? # [ View source ] #page_type_unknown? # [ View source ] #parameter_not_implemented? # [ View source ] #parameters_unknown? # [ View source ] #pointless_command? # [ View source ] #restart_marker_reply? # [ View source ] #service_ready? # [ View source ] #service_ready_soon? # [ View source ] #service_unavailable? # [ View source ] #system_status? # [ View source ] #system_type? # [ View source ] #transfer_aborted? # [ View source ]","title":"Status"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status","text":"Status codes possibly returned by a FTP response","title":"Status"},{"location":"api/SF/Ftp/Response/Status.html#members","text":"","title":"Members"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::RestartMarkerReply","text":"Restart marker reply","title":"RestartMarkerReply"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ServiceReadySoon","text":"Service ready in N minutes","title":"ServiceReadySoon"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::DataConnectionAlreadyOpened","text":"Data connection already opened, transfer starting","title":"DataConnectionAlreadyOpened"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::OpeningDataConnection","text":"File status ok, about to open data connection","title":"OpeningDataConnection"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::Ok","text":"Command ok","title":"Ok"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::PointlessCommand","text":"Command not implemented","title":"PointlessCommand"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::SystemStatus","text":"System status, or system help reply","title":"SystemStatus"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::DirectoryStatus","text":"Directory status","title":"DirectoryStatus"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::FileStatus","text":"File status","title":"FileStatus"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::HelpMessage","text":"Help message","title":"HelpMessage"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::SystemType","text":"NAME system type, where NAME is an official system name from the list in the Assigned Numbers document","title":"SystemType"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ServiceReady","text":"Service ready for new user","title":"ServiceReady"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ClosingConnection","text":"Service closing control connection","title":"ClosingConnection"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::DataConnectionOpened","text":"Data connection open, no transfer in progress","title":"DataConnectionOpened"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ClosingDataConnection","text":"Closing data connection, requested file action successful","title":"ClosingDataConnection"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::EnteringPassiveMode","text":"Entering passive mode","title":"EnteringPassiveMode"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::LoggedIn","text":"User logged in, proceed. Logged out if appropriate","title":"LoggedIn"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::FileActionOk","text":"Requested file action ok","title":"FileActionOk"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::DirectoryOk","text":"PATHNAME created","title":"DirectoryOk"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::NeedPassword","text":"User name ok, need password","title":"NeedPassword"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::NeedAccountToLogIn","text":"Need account for login","title":"NeedAccountToLogIn"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::NeedInformation","text":"Requested file action pending further information","title":"NeedInformation"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ServiceUnavailable","text":"Service not available, closing control connection","title":"ServiceUnavailable"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::DataConnectionUnavailable","text":"Can't open data connection","title":"DataConnectionUnavailable"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::TransferAborted","text":"Connection closed, transfer aborted","title":"TransferAborted"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::FileActionAborted","text":"Requested file action not taken","title":"FileActionAborted"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::LocalError","text":"Requested action aborted, local error in processing","title":"LocalError"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::InsufficientStorageSpace","text":"Requested action not taken; insufficient storage space in system, file unavailable","title":"InsufficientStorageSpace"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::CommandUnknown","text":"Syntax error, command unrecognized","title":"CommandUnknown"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ParametersUnknown","text":"Syntax error in parameters or arguments","title":"ParametersUnknown"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::CommandNotImplemented","text":"Command not implemented","title":"CommandNotImplemented"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::BadCommandSequence","text":"Bad sequence of commands","title":"BadCommandSequence"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ParameterNotImplemented","text":"Command not implemented for that parameter","title":"ParameterNotImplemented"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::NotLoggedIn","text":"Not logged in","title":"NotLoggedIn"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::NeedAccountToStore","text":"Need account for storing files","title":"NeedAccountToStore"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::FileUnavailable","text":"Requested action not taken, file unavailable","title":"FileUnavailable"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::PageTypeUnknown","text":"Requested action aborted, page type unknown","title":"PageTypeUnknown"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::NotEnoughMemory","text":"Requested file action aborted, exceeded storage allocation","title":"NotEnoughMemory"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::FilenameNotAllowed","text":"Requested action not taken, file name not allowed","title":"FilenameNotAllowed"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::InvalidResponse","text":"Not part of the FTP standard, generated by SFML when a received response cannot be parsed","title":"InvalidResponse"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ConnectionFailed","text":"Not part of the FTP standard, generated by SFML when the low-level socket connection with the server fails","title":"ConnectionFailed"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::ConnectionClosed","text":"Not part of the FTP standard, generated by SFML when the low-level socket connection is unexpectedly closed","title":"ConnectionClosed"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status::InvalidFile","text":"Not part of the FTP standard, generated by SFML when a local file cannot be read or written","title":"InvalidFile"},{"location":"api/SF/Ftp/Response/Status.html#methods","text":"","title":"Methods"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#bad_command_sequence?()","text":"[ View source ]","title":"#bad_command_sequence?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#closing_connection?()","text":"[ View source ]","title":"#closing_connection?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#closing_data_connection?()","text":"[ View source ]","title":"#closing_data_connection?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#command_not_implemented?()","text":"[ View source ]","title":"#command_not_implemented?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#command_unknown?()","text":"[ View source ]","title":"#command_unknown?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#connection_closed?()","text":"[ View source ]","title":"#connection_closed?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#connection_failed?()","text":"[ View source ]","title":"#connection_failed?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#data_connection_already_opened?()","text":"[ View source ]","title":"#data_connection_already_opened?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#data_connection_opened?()","text":"[ View source ]","title":"#data_connection_opened?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#data_connection_unavailable?()","text":"[ View source ]","title":"#data_connection_unavailable?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#directory_ok?()","text":"[ View source ]","title":"#directory_ok?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#directory_status?()","text":"[ View source ]","title":"#directory_status?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#entering_passive_mode?()","text":"[ View source ]","title":"#entering_passive_mode?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#file_action_aborted?()","text":"[ View source ]","title":"#file_action_aborted?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#file_action_ok?()","text":"[ View source ]","title":"#file_action_ok?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#file_status?()","text":"[ View source ]","title":"#file_status?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#file_unavailable?()","text":"[ View source ]","title":"#file_unavailable?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#filename_not_allowed?()","text":"[ View source ]","title":"#filename_not_allowed?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#help_message?()","text":"[ View source ]","title":"#help_message?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#insufficient_storage_space?()","text":"[ View source ]","title":"#insufficient_storage_space?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#invalid_file?()","text":"[ View source ]","title":"#invalid_file?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#invalid_response?()","text":"[ View source ]","title":"#invalid_response?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#local_error?()","text":"[ View source ]","title":"#local_error?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#logged_in?()","text":"[ View source ]","title":"#logged_in?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#need_account_to_log_in?()","text":"[ View source ]","title":"#need_account_to_log_in?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#need_account_to_store?()","text":"[ View source ]","title":"#need_account_to_store?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#need_information?()","text":"[ View source ]","title":"#need_information?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#need_password?()","text":"[ View source ]","title":"#need_password?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#not_enough_memory?()","text":"[ View source ]","title":"#not_enough_memory?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#not_logged_in?()","text":"[ View source ]","title":"#not_logged_in?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#ok?()","text":"[ View source ]","title":"#ok?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#opening_data_connection?()","text":"[ View source ]","title":"#opening_data_connection?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#page_type_unknown?()","text":"[ View source ]","title":"#page_type_unknown?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#parameter_not_implemented?()","text":"[ View source ]","title":"#parameter_not_implemented?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#parameters_unknown?()","text":"[ View source ]","title":"#parameters_unknown?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#pointless_command?()","text":"[ View source ]","title":"#pointless_command?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#restart_marker_reply?()","text":"[ View source ]","title":"#restart_marker_reply?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#service_ready?()","text":"[ View source ]","title":"#service_ready?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#service_ready_soon?()","text":"[ View source ]","title":"#service_ready_soon?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#service_unavailable?()","text":"[ View source ]","title":"#service_unavailable?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#system_status?()","text":"[ View source ]","title":"#system_status?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#system_type?()","text":"[ View source ]","title":"#system_type?"},{"location":"api/SF/Ftp/Response/Status.html#SF::Ftp::Response::Status#transfer_aborted?()","text":"[ View source ]","title":"#transfer_aborted?"},{"location":"api/SF/Http/Request.html","text":"class SF::Http::Request inherits Reference # Define a HTTP request Class methods # .new ( uri : String = \"/\" , method : Http :: Request :: Method = Get , body : String = \"\" ) # Default constructor This constructor creates a GET request, with the root URI (\"/\") and an empty body. uri - Target URI method - Method to use for the request body - Content of the request's body [ View source ] Methods # #body= ( body : String ) # Set the body of the request The body of a request is optional and only makes sense for POST requests. It is ignored for all other methods. The body is empty by default. body - Content of the body [ View source ] #dup : Request # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ] #method= ( method : Http :: Request :: Method ) # Set the request method See the Method enumeration for a complete list of all the availale methods. The method is Http::Request::Get by default. method - Method to use for the request [ View source ] #set_field ( field : String , value : String ) # Set the value of a field The field is created if it doesn't exist. The name of the field is case-insensitive. By default, a request doesn't contain any field (but the mandatory fields are added later by the HTTP client when sending the request). field - Name of the field to set value - Value of the field [ View source ] #set_http_version ( major : Int , minor : Int ) # Set the HTTP version for the request The HTTP version is 1.0 by default. major - Major HTTP version number minor - Minor HTTP version number [ View source ] #uri= ( uri : String ) # Set the requested URI The URI is the resource (usually a web page or a file) that you want to get or post. The URI is \"/\" (the root page) by default. uri - URI to request, relative to the host [ View source ]","title":"Request"},{"location":"api/SF/Http/Request.html#SF::Http::Request","text":"Define a HTTP request","title":"Request"},{"location":"api/SF/Http/Request.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Http/Request.html#SF::Http::Request.new(uri,method,body)","text":"Default constructor This constructor creates a GET request, with the root URI (\"/\") and an empty body. uri - Target URI method - Method to use for the request body - Content of the request's body [ View source ]","title":".new"},{"location":"api/SF/Http/Request.html#methods","text":"","title":"Methods"},{"location":"api/SF/Http/Request.html#SF::Http::Request#body=(body)","text":"Set the body of the request The body of a request is optional and only makes sense for POST requests. It is ignored for all other methods. The body is empty by default. body - Content of the body [ View source ]","title":"#body="},{"location":"api/SF/Http/Request.html#SF::Http::Request#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Http/Request.html#SF::Http::Request#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Http/Request.html#SF::Http::Request#method=(method)","text":"Set the request method See the Method enumeration for a complete list of all the availale methods. The method is Http::Request::Get by default. method - Method to use for the request [ View source ]","title":"#method="},{"location":"api/SF/Http/Request.html#SF::Http::Request#set_field(field,value)","text":"Set the value of a field The field is created if it doesn't exist. The name of the field is case-insensitive. By default, a request doesn't contain any field (but the mandatory fields are added later by the HTTP client when sending the request). field - Name of the field to set value - Value of the field [ View source ]","title":"#set_field"},{"location":"api/SF/Http/Request.html#SF::Http::Request#set_http_version(major,minor)","text":"Set the HTTP version for the request The HTTP version is 1.0 by default. major - Major HTTP version number minor - Minor HTTP version number [ View source ]","title":"#set_http_version"},{"location":"api/SF/Http/Request.html#SF::Http::Request#uri=(uri)","text":"Set the requested URI The URI is the resource (usually a web page or a file) that you want to get or post. The URI is \"/\" (the root page) by default. uri - URI to request, relative to the host [ View source ]","title":"#uri="},{"location":"api/SF/Http/Response.html","text":"class SF::Http::Response inherits Reference # Define a HTTP response Class methods # .new # Default constructor Constructs an empty response. [ View source ] Methods # #body : String # Get the body of the response The body of a response may contain: the requested page (for GET requests) a response from the server (for POST requests) nothing (for HEAD requests) an error message (in case of an error) Returns: The response body [ View source ] #dup : Response # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ] #get_field ( field : String ) : String # Get the value of a field If the field field is not found in the response header, the empty string is returned. This function uses case-insensitive comparisons. field - Name of the field to get Returns: Value of the field, or empty string if not found [ View source ] #major_http_version : Int32 # Get the major HTTP version number of the response Returns: Major HTTP version number See also: minor_http_version [ View source ] #minor_http_version : Int32 # Get the minor HTTP version number of the response Returns: Minor HTTP version number See also: major_http_version [ View source ] #status : Http :: Response :: Status # Get the response status code The status code should be the first thing to be checked after receiving a response, it defines whether it is a success, a failure or anything else (see the Status enumeration). Returns: Status code of the response [ View source ]","title":"Response"},{"location":"api/SF/Http/Response.html#SF::Http::Response","text":"Define a HTTP response","title":"Response"},{"location":"api/SF/Http/Response.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Http/Response.html#SF::Http::Response.new()","text":"Default constructor Constructs an empty response. [ View source ]","title":".new"},{"location":"api/SF/Http/Response.html#methods","text":"","title":"Methods"},{"location":"api/SF/Http/Response.html#SF::Http::Response#body()","text":"Get the body of the response The body of a response may contain: the requested page (for GET requests) a response from the server (for POST requests) nothing (for HEAD requests) an error message (in case of an error) Returns: The response body [ View source ]","title":"#body"},{"location":"api/SF/Http/Response.html#SF::Http::Response#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Http/Response.html#SF::Http::Response#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Http/Response.html#SF::Http::Response#get_field(field)","text":"Get the value of a field If the field field is not found in the response header, the empty string is returned. This function uses case-insensitive comparisons. field - Name of the field to get Returns: Value of the field, or empty string if not found [ View source ]","title":"#get_field"},{"location":"api/SF/Http/Response.html#SF::Http::Response#major_http_version()","text":"Get the major HTTP version number of the response Returns: Major HTTP version number See also: minor_http_version [ View source ]","title":"#major_http_version"},{"location":"api/SF/Http/Response.html#SF::Http::Response#minor_http_version()","text":"Get the minor HTTP version number of the response Returns: Minor HTTP version number See also: major_http_version [ View source ]","title":"#minor_http_version"},{"location":"api/SF/Http/Response.html#SF::Http::Response#status()","text":"Get the response status code The status code should be the first thing to be checked after receiving a response, it defines whether it is a success, a failure or anything else (see the Status enumeration). Returns: Status code of the response [ View source ]","title":"#status"},{"location":"api/SF/Http/Request/Method.html","text":"enum SF::Http::Request::Method # Enumerate the available HTTP methods for a request Members # Get # Request in get mode, standard method to retrieve a page Post # Request in post mode, usually to send data to a page Head # Request a page's header only Put # Request in put mode, useful for a REST API Delete # Request in delete mode, useful for a REST API Methods # #delete? # [ View source ] #get? # [ View source ] #head? # [ View source ] #post? # [ View source ] #put? # [ View source ]","title":"Method"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method","text":"Enumerate the available HTTP methods for a request","title":"Method"},{"location":"api/SF/Http/Request/Method.html#members","text":"","title":"Members"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method::Get","text":"Request in get mode, standard method to retrieve a page","title":"Get"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method::Post","text":"Request in post mode, usually to send data to a page","title":"Post"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method::Head","text":"Request a page's header only","title":"Head"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method::Put","text":"Request in put mode, useful for a REST API","title":"Put"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method::Delete","text":"Request in delete mode, useful for a REST API","title":"Delete"},{"location":"api/SF/Http/Request/Method.html#methods","text":"","title":"Methods"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method#delete?()","text":"[ View source ]","title":"#delete?"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method#get?()","text":"[ View source ]","title":"#get?"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method#head?()","text":"[ View source ]","title":"#head?"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method#post?()","text":"[ View source ]","title":"#post?"},{"location":"api/SF/Http/Request/Method.html#SF::Http::Request::Method#put?()","text":"[ View source ]","title":"#put?"},{"location":"api/SF/Http/Response/Status.html","text":"enum SF::Http::Response::Status # Enumerate all the valid status codes for a response Members # Ok # Most common code returned when operation was successful Created # The resource has successfully been created Accepted # The request has been accepted, but will be processed later by the server NoContent # The server didn't send any data in return ResetContent # The server informs the client that it should clear the view (form) that caused the request to be sent PartialContent # The server has sent a part of the resource, as a response to a partial GET request MultipleChoices # The requested page can be accessed from several locations MovedPermanently # The requested page has permanently moved to a new location MovedTemporarily # The requested page has temporarily moved to a new location NotModified # For conditional requests, means the requested page hasn't changed and doesn't need to be refreshed BadRequest # The server couldn't understand the request (syntax error) Unauthorized # The requested page needs an authentication to be accessed Forbidden # The requested page cannot be accessed at all, even with authentication NotFound # The requested page doesn't exist RangeNotSatisfiable # The server can't satisfy the partial GET request (with a \"Range\" header field) InternalServerError # The server encountered an unexpected error NotImplemented # The server doesn't implement a requested feature BadGateway # The gateway server has received an error from the source server ServiceNotAvailable # The server is temporarily unavailable (overloaded, in maintenance, ...) GatewayTimeout # The gateway server couldn't receive a response from the source server VersionNotSupported # The server doesn't support the requested HTTP version InvalidResponse # Response is not a valid HTTP one ConnectionFailed # Connection with server failed Methods # #accepted? # [ View source ] #bad_gateway? # [ View source ] #bad_request? # [ View source ] #connection_failed? # [ View source ] #created? # [ View source ] #forbidden? # [ View source ] #gateway_timeout? # [ View source ] #internal_server_error? # [ View source ] #invalid_response? # [ View source ] #moved_permanently? # [ View source ] #moved_temporarily? # [ View source ] #multiple_choices? # [ View source ] #no_content? # [ View source ] #not_found? # [ View source ] #not_implemented? # [ View source ] #not_modified? # [ View source ] #ok? # [ View source ] #partial_content? # [ View source ] #range_not_satisfiable? # [ View source ] #reset_content? # [ View source ] #service_not_available? # [ View source ] #unauthorized? # [ View source ] #version_not_supported? # [ View source ]","title":"Status"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status","text":"Enumerate all the valid status codes for a response","title":"Status"},{"location":"api/SF/Http/Response/Status.html#members","text":"","title":"Members"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::Ok","text":"Most common code returned when operation was successful","title":"Ok"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::Created","text":"The resource has successfully been created","title":"Created"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::Accepted","text":"The request has been accepted, but will be processed later by the server","title":"Accepted"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::NoContent","text":"The server didn't send any data in return","title":"NoContent"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::ResetContent","text":"The server informs the client that it should clear the view (form) that caused the request to be sent","title":"ResetContent"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::PartialContent","text":"The server has sent a part of the resource, as a response to a partial GET request","title":"PartialContent"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::MultipleChoices","text":"The requested page can be accessed from several locations","title":"MultipleChoices"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::MovedPermanently","text":"The requested page has permanently moved to a new location","title":"MovedPermanently"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::MovedTemporarily","text":"The requested page has temporarily moved to a new location","title":"MovedTemporarily"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::NotModified","text":"For conditional requests, means the requested page hasn't changed and doesn't need to be refreshed","title":"NotModified"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::BadRequest","text":"The server couldn't understand the request (syntax error)","title":"BadRequest"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::Unauthorized","text":"The requested page needs an authentication to be accessed","title":"Unauthorized"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::Forbidden","text":"The requested page cannot be accessed at all, even with authentication","title":"Forbidden"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::NotFound","text":"The requested page doesn't exist","title":"NotFound"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::RangeNotSatisfiable","text":"The server can't satisfy the partial GET request (with a \"Range\" header field)","title":"RangeNotSatisfiable"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::InternalServerError","text":"The server encountered an unexpected error","title":"InternalServerError"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::NotImplemented","text":"The server doesn't implement a requested feature","title":"NotImplemented"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::BadGateway","text":"The gateway server has received an error from the source server","title":"BadGateway"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::ServiceNotAvailable","text":"The server is temporarily unavailable (overloaded, in maintenance, ...)","title":"ServiceNotAvailable"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::GatewayTimeout","text":"The gateway server couldn't receive a response from the source server","title":"GatewayTimeout"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::VersionNotSupported","text":"The server doesn't support the requested HTTP version","title":"VersionNotSupported"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::InvalidResponse","text":"Response is not a valid HTTP one","title":"InvalidResponse"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status::ConnectionFailed","text":"Connection with server failed","title":"ConnectionFailed"},{"location":"api/SF/Http/Response/Status.html#methods","text":"","title":"Methods"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#accepted?()","text":"[ View source ]","title":"#accepted?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#bad_gateway?()","text":"[ View source ]","title":"#bad_gateway?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#bad_request?()","text":"[ View source ]","title":"#bad_request?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#connection_failed?()","text":"[ View source ]","title":"#connection_failed?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#created?()","text":"[ View source ]","title":"#created?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#forbidden?()","text":"[ View source ]","title":"#forbidden?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#gateway_timeout?()","text":"[ View source ]","title":"#gateway_timeout?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#internal_server_error?()","text":"[ View source ]","title":"#internal_server_error?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#invalid_response?()","text":"[ View source ]","title":"#invalid_response?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#moved_permanently?()","text":"[ View source ]","title":"#moved_permanently?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#moved_temporarily?()","text":"[ View source ]","title":"#moved_temporarily?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#multiple_choices?()","text":"[ View source ]","title":"#multiple_choices?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#no_content?()","text":"[ View source ]","title":"#no_content?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#not_found?()","text":"[ View source ]","title":"#not_found?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#not_implemented?()","text":"[ View source ]","title":"#not_implemented?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#not_modified?()","text":"[ View source ]","title":"#not_modified?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#ok?()","text":"[ View source ]","title":"#ok?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#partial_content?()","text":"[ View source ]","title":"#partial_content?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#range_not_satisfiable?()","text":"[ View source ]","title":"#range_not_satisfiable?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#reset_content?()","text":"[ View source ]","title":"#reset_content?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#service_not_available?()","text":"[ View source ]","title":"#service_not_available?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#unauthorized?()","text":"[ View source ]","title":"#unauthorized?"},{"location":"api/SF/Http/Response/Status.html#SF::Http::Response::Status#version_not_supported?()","text":"[ View source ]","title":"#version_not_supported?"},{"location":"api/SF/Joystick/Axis.html","text":"enum SF::Joystick::Axis # Axes supported by SFML joysticks Members # X # The X axis Y # The Y axis Z # The Z axis R # The R axis U # The U axis V # The V axis PovX # The X axis of the point-of-view hat PovY # The Y axis of the point-of-view hat Methods # #pov_x? # [ View source ] #pov_y? # [ View source ] #r? # [ View source ] #u? # [ View source ] #v? # [ View source ] #x? # [ View source ] #y? # [ View source ] #z? # [ View source ]","title":"Axis"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis","text":"Axes supported by SFML joysticks","title":"Axis"},{"location":"api/SF/Joystick/Axis.html#members","text":"","title":"Members"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis::X","text":"The X axis","title":"X"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis::Y","text":"The Y axis","title":"Y"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis::Z","text":"The Z axis","title":"Z"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis::R","text":"The R axis","title":"R"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis::U","text":"The U axis","title":"U"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis::V","text":"The V axis","title":"V"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis::PovX","text":"The X axis of the point-of-view hat","title":"PovX"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis::PovY","text":"The Y axis of the point-of-view hat","title":"PovY"},{"location":"api/SF/Joystick/Axis.html#methods","text":"","title":"Methods"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis#pov_x?()","text":"[ View source ]","title":"#pov_x?"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis#pov_y?()","text":"[ View source ]","title":"#pov_y?"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis#r?()","text":"[ View source ]","title":"#r?"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis#u?()","text":"[ View source ]","title":"#u?"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis#v?()","text":"[ View source ]","title":"#v?"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis#x?()","text":"[ View source ]","title":"#x?"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis#y?()","text":"[ View source ]","title":"#y?"},{"location":"api/SF/Joystick/Axis.html#SF::Joystick::Axis#z?()","text":"[ View source ]","title":"#z?"},{"location":"api/SF/Joystick/Identification.html","text":"class SF::Joystick::Identification inherits Reference # Structure holding a joystick's identification Class methods # .new # [ View source ] Methods # #dup : Identification # Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ] #finalize # [ View source ] #name : String # Name of the joystick [ View source ] #name= ( name : String ) # [ View source ] #product_id : Int32 # Product identifier [ View source ] #product_id= ( product_id : Int ) # [ View source ] #vendor_id : Int32 # Manufacturer identifier [ View source ] #vendor_id= ( vendor_id : Int ) # [ View source ]","title":"Identification"},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification","text":"Structure holding a joystick's identification","title":"Identification"},{"location":"api/SF/Joystick/Identification.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Joystick/Identification.html#methods","text":"","title":"Methods"},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification#dup()","text":"Returns a shallow copy of this object. This allocates a new object and copies the contents of self into it. [ View source ]","title":"#dup"},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification#finalize()","text":"[ View source ]","title":"#finalize"},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification#name()","text":"Name of the joystick [ View source ]","title":"#name"},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification#name=(name)","text":"[ View source ]","title":"#name="},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification#product_id()","text":"Product identifier [ View source ]","title":"#product_id"},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification#product_id=(product_id)","text":"[ View source ]","title":"#product_id="},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification#vendor_id()","text":"Manufacturer identifier [ View source ]","title":"#vendor_id"},{"location":"api/SF/Joystick/Identification.html#SF::Joystick::Identification#vendor_id=(vendor_id)","text":"[ View source ]","title":"#vendor_id="},{"location":"api/SF/Keyboard/Key.html","text":"enum SF::Keyboard::Key # Key codes Members # Unknown # Unhandled key A # The A key B # The B key C # The C key D # The D key E # The E key F # The F key G # The G key H # The H key I # The I key J # The J key K # The K key L # The L key M # The M key N # The N key O # The O key P # The P key Q # The Q key R # The R key S # The S key T # The T key U # The U key V # The V key W # The W key X # The X key Y # The Y key Z # The Z key Num0 # The 0 key Num1 # The 1 key Num2 # The 2 key Num3 # The 3 key Num4 # The 4 key Num5 # The 5 key Num6 # The 6 key Num7 # The 7 key Num8 # The 8 key Num9 # The 9 key Escape # The Escape key LControl # The left Control key LShift # The left Shift key LAlt # The left Alt key LSystem # The left OS specific key: window (Windows and Linux), apple (MacOS X), ... RControl # The right Control key RShift # The right Shift key RAlt # The right Alt key RSystem # The right OS specific key: window (Windows and Linux), apple (MacOS X), ... Menu # The Menu key LBracket # The [ key RBracket # The ] key Semicolon # The ; key Comma # The , key Period # The . key Quote # The ' key Slash # The / key Backslash # The \\ key Tilde # The ~ key Equal # The = key Hyphen # The - key (hyphen) Space # The Space key Enter # The Enter/Return keys Backspace # The Backspace key Tab # The Tabulation key PageUp # The Page up key PageDown # The Page down key End # The End key Home # The Home key Insert # The Insert key Delete # The Delete key Add # The + key Subtract # The - key (minus, usually from numpad) Multiply # The * key Divide # The / key Left # Left arrow Right # Right arrow Up # Up arrow Down # Down arrow Numpad0 # The numpad 0 key Numpad1 # The numpad 1 key Numpad2 # The numpad 2 key Numpad3 # The numpad 3 key Numpad4 # The numpad 4 key Numpad5 # The numpad 5 key Numpad6 # The numpad 6 key Numpad7 # The numpad 7 key Numpad8 # The numpad 8 key Numpad9 # The numpad 9 key F1 # The F1 key F2 # The F2 key F3 # The F3 key F4 # The F4 key F5 # The F5 key F6 # The F6 key F7 # The F7 key F8 # The F8 key F9 # The F9 key F10 # The F10 key F11 # The F11 key F12 # The F12 key F13 # The F13 key F14 # The F14 key F15 # The F15 key Pause # The Pause key KeyCount # Keep last -- the total number of keyboard keys Dash # DEPRECATED: Use Hyphen instead BackSpace # DEPRECATED: Use Backspace instead BackSlash # DEPRECATED: Use Backslash instead SemiColon # DEPRECATED: Use Semicolon instead Return # DEPRECATED: Use Enter instead Class methods # .parse? ( string ) : self ? # Same as Enum#parse? but with a workaround to skip duplicate names [ View source ] Methods # #a? # [ View source ] #add? # [ View source ] #b? # [ View source ] #back_slash? # [ View source ] #back_space? # [ View source ] #backslash? # [ View source ] #backspace? # [ View source ] #c? # [ View source ] #comma? # [ View source ] #d? # [ View source ] #dash? # [ View source ] #delete? # [ View source ] #divide? # [ View source ] #down? # [ View source ] #e? # [ View source ] #end? # [ View source ] #enter? # [ View source ] #equal? # [ View source ] #escape? # [ View source ] #f10? # [ View source ] #f11? # [ View source ] #f12? # [ View source ] #f13? # [ View source ] #f14? # [ View source ] #f15? # [ View source ] #f1? # [ View source ] #f2? # [ View source ] #f3? # [ View source ] #f4? # [ View source ] #f5? # [ View source ] #f6? # [ View source ] #f7? # [ View source ] #f8? # [ View source ] #f9? # [ View source ] #f? # [ View source ] #g? # [ View source ] #h? # [ View source ] #home? # [ View source ] #hyphen? # [ View source ] #i? # [ View source ] #insert? # [ View source ] #j? # [ View source ] #k? # [ View source ] #key_count? # [ View source ] #l? # [ View source ] #l_alt? # [ View source ] #l_bracket? # [ View source ] #l_control? # [ View source ] #l_shift? # [ View source ] #l_system? # [ View source ] #left? # [ View source ] #m? # [ View source ] #menu? # [ View source ] #multiply? # [ View source ] #n? # [ View source ] #num0? # [ View source ] #num1? # [ View source ] #num2? # [ View source ] #num3? # [ View source ] #num4? # [ View source ] #num5? # [ View source ] #num6? # [ View source ] #num7? # [ View source ] #num8? # [ View source ] #num9? # [ View source ] #numpad0? # [ View source ] #numpad1? # [ View source ] #numpad2? # [ View source ] #numpad3? # [ View source ] #numpad4? # [ View source ] #numpad5? # [ View source ] #numpad6? # [ View source ] #numpad7? # [ View source ] #numpad8? # [ View source ] #numpad9? # [ View source ] #o? # [ View source ] #p? # [ View source ] #page_down? # [ View source ] #page_up? # [ View source ] #pause? # [ View source ] #period? # [ View source ] #q? # [ View source ] #quote? # [ View source ] #r? # [ View source ] #r_alt? # [ View source ] #r_bracket? # [ View source ] #r_control? # [ View source ] #r_shift? # [ View source ] #r_system? # [ View source ] #return? # [ View source ] #right? # [ View source ] #s? # [ View source ] #semi_colon? # [ View source ] #semicolon? # [ View source ] #slash? # [ View source ] #space? # [ View source ] #subtract? # [ View source ] #t? # [ View source ] #tab? # [ View source ] #tilde? # [ View source ] #u? # [ View source ] #unknown? # [ View source ] #up? # [ View source ] #v? # [ View source ] #w? # [ View source ] #x? # [ View source ] #y? # [ View source ] #z? # [ View source ]","title":"Key"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key","text":"Key codes","title":"Key"},{"location":"api/SF/Keyboard/Key.html#members","text":"","title":"Members"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Unknown","text":"Unhandled key","title":"Unknown"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::A","text":"The A key","title":"A"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::B","text":"The B key","title":"B"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::C","text":"The C key","title":"C"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::D","text":"The D key","title":"D"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::E","text":"The E key","title":"E"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F","text":"The F key","title":"F"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::G","text":"The G key","title":"G"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::H","text":"The H key","title":"H"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::I","text":"The I key","title":"I"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::J","text":"The J key","title":"J"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::K","text":"The K key","title":"K"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::L","text":"The L key","title":"L"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::M","text":"The M key","title":"M"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::N","text":"The N key","title":"N"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::O","text":"The O key","title":"O"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::P","text":"The P key","title":"P"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Q","text":"The Q key","title":"Q"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::R","text":"The R key","title":"R"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::S","text":"The S key","title":"S"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::T","text":"The T key","title":"T"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::U","text":"The U key","title":"U"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::V","text":"The V key","title":"V"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::W","text":"The W key","title":"W"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::X","text":"The X key","title":"X"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Y","text":"The Y key","title":"Y"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Z","text":"The Z key","title":"Z"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num0","text":"The 0 key","title":"Num0"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num1","text":"The 1 key","title":"Num1"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num2","text":"The 2 key","title":"Num2"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num3","text":"The 3 key","title":"Num3"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num4","text":"The 4 key","title":"Num4"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num5","text":"The 5 key","title":"Num5"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num6","text":"The 6 key","title":"Num6"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num7","text":"The 7 key","title":"Num7"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num8","text":"The 8 key","title":"Num8"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Num9","text":"The 9 key","title":"Num9"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Escape","text":"The Escape key","title":"Escape"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::LControl","text":"The left Control key","title":"LControl"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::LShift","text":"The left Shift key","title":"LShift"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::LAlt","text":"The left Alt key","title":"LAlt"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::LSystem","text":"The left OS specific key: window (Windows and Linux), apple (MacOS X), ...","title":"LSystem"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::RControl","text":"The right Control key","title":"RControl"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::RShift","text":"The right Shift key","title":"RShift"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::RAlt","text":"The right Alt key","title":"RAlt"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::RSystem","text":"The right OS specific key: window (Windows and Linux), apple (MacOS X), ...","title":"RSystem"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Menu","text":"The Menu key","title":"Menu"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::LBracket","text":"The [ key","title":"LBracket"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::RBracket","text":"The ] key","title":"RBracket"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Semicolon","text":"The ; key","title":"Semicolon"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Comma","text":"The , key","title":"Comma"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Period","text":"The . key","title":"Period"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Quote","text":"The ' key","title":"Quote"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Slash","text":"The / key","title":"Slash"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Backslash","text":"The \\ key","title":"Backslash"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Tilde","text":"The ~ key","title":"Tilde"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Equal","text":"The = key","title":"Equal"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Hyphen","text":"The - key (hyphen)","title":"Hyphen"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Space","text":"The Space key","title":"Space"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Enter","text":"The Enter/Return keys","title":"Enter"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Backspace","text":"The Backspace key","title":"Backspace"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Tab","text":"The Tabulation key","title":"Tab"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::PageUp","text":"The Page up key","title":"PageUp"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::PageDown","text":"The Page down key","title":"PageDown"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::End","text":"The End key","title":"End"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Home","text":"The Home key","title":"Home"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Insert","text":"The Insert key","title":"Insert"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Delete","text":"The Delete key","title":"Delete"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Add","text":"The + key","title":"Add"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Subtract","text":"The - key (minus, usually from numpad)","title":"Subtract"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Multiply","text":"The * key","title":"Multiply"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Divide","text":"The / key","title":"Divide"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Left","text":"Left arrow","title":"Left"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Right","text":"Right arrow","title":"Right"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Up","text":"Up arrow","title":"Up"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Down","text":"Down arrow","title":"Down"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad0","text":"The numpad 0 key","title":"Numpad0"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad1","text":"The numpad 1 key","title":"Numpad1"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad2","text":"The numpad 2 key","title":"Numpad2"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad3","text":"The numpad 3 key","title":"Numpad3"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad4","text":"The numpad 4 key","title":"Numpad4"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad5","text":"The numpad 5 key","title":"Numpad5"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad6","text":"The numpad 6 key","title":"Numpad6"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad7","text":"The numpad 7 key","title":"Numpad7"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad8","text":"The numpad 8 key","title":"Numpad8"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Numpad9","text":"The numpad 9 key","title":"Numpad9"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F1","text":"The F1 key","title":"F1"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F2","text":"The F2 key","title":"F2"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F3","text":"The F3 key","title":"F3"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F4","text":"The F4 key","title":"F4"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F5","text":"The F5 key","title":"F5"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F6","text":"The F6 key","title":"F6"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F7","text":"The F7 key","title":"F7"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F8","text":"The F8 key","title":"F8"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F9","text":"The F9 key","title":"F9"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F10","text":"The F10 key","title":"F10"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F11","text":"The F11 key","title":"F11"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F12","text":"The F12 key","title":"F12"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F13","text":"The F13 key","title":"F13"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F14","text":"The F14 key","title":"F14"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::F15","text":"The F15 key","title":"F15"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Pause","text":"The Pause key","title":"Pause"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::KeyCount","text":"Keep last -- the total number of keyboard keys","title":"KeyCount"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Dash","text":"DEPRECATED: Use Hyphen instead","title":"Dash"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::BackSpace","text":"DEPRECATED: Use Backspace instead","title":"BackSpace"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::BackSlash","text":"DEPRECATED: Use Backslash instead","title":"BackSlash"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::SemiColon","text":"DEPRECATED: Use Semicolon instead","title":"SemiColon"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key::Return","text":"DEPRECATED: Use Enter instead","title":"Return"},{"location":"api/SF/Keyboard/Key.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key.parse?(string)","text":"Same as Enum#parse? but with a workaround to skip duplicate names [ View source ]","title":".parse?"},{"location":"api/SF/Keyboard/Key.html#methods","text":"","title":"Methods"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#a?()","text":"[ View source ]","title":"#a?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#add?()","text":"[ View source ]","title":"#add?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#b?()","text":"[ View source ]","title":"#b?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#back_slash?()","text":"[ View source ]","title":"#back_slash?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#back_space?()","text":"[ View source ]","title":"#back_space?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#backslash?()","text":"[ View source ]","title":"#backslash?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#backspace?()","text":"[ View source ]","title":"#backspace?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#c?()","text":"[ View source ]","title":"#c?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#comma?()","text":"[ View source ]","title":"#comma?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#d?()","text":"[ View source ]","title":"#d?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#dash?()","text":"[ View source ]","title":"#dash?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#delete?()","text":"[ View source ]","title":"#delete?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#divide?()","text":"[ View source ]","title":"#divide?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#down?()","text":"[ View source ]","title":"#down?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#e?()","text":"[ View source ]","title":"#e?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#end?()","text":"[ View source ]","title":"#end?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#enter?()","text":"[ View source ]","title":"#enter?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#equal?()","text":"[ View source ]","title":"#equal?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#escape?()","text":"[ View source ]","title":"#escape?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f10?()","text":"[ View source ]","title":"#f10?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f11?()","text":"[ View source ]","title":"#f11?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f12?()","text":"[ View source ]","title":"#f12?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f13?()","text":"[ View source ]","title":"#f13?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f14?()","text":"[ View source ]","title":"#f14?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f15?()","text":"[ View source ]","title":"#f15?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f1?()","text":"[ View source ]","title":"#f1?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f2?()","text":"[ View source ]","title":"#f2?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f3?()","text":"[ View source ]","title":"#f3?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f4?()","text":"[ View source ]","title":"#f4?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f5?()","text":"[ View source ]","title":"#f5?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f6?()","text":"[ View source ]","title":"#f6?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f7?()","text":"[ View source ]","title":"#f7?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f8?()","text":"[ View source ]","title":"#f8?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f9?()","text":"[ View source ]","title":"#f9?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#f?()","text":"[ View source ]","title":"#f?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#g?()","text":"[ View source ]","title":"#g?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#h?()","text":"[ View source ]","title":"#h?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#home?()","text":"[ View source ]","title":"#home?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#hyphen?()","text":"[ View source ]","title":"#hyphen?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#i?()","text":"[ View source ]","title":"#i?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#insert?()","text":"[ View source ]","title":"#insert?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#j?()","text":"[ View source ]","title":"#j?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#k?()","text":"[ View source ]","title":"#k?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#key_count?()","text":"[ View source ]","title":"#key_count?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#l?()","text":"[ View source ]","title":"#l?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#l_alt?()","text":"[ View source ]","title":"#l_alt?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#l_bracket?()","text":"[ View source ]","title":"#l_bracket?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#l_control?()","text":"[ View source ]","title":"#l_control?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#l_shift?()","text":"[ View source ]","title":"#l_shift?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#l_system?()","text":"[ View source ]","title":"#l_system?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#left?()","text":"[ View source ]","title":"#left?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#m?()","text":"[ View source ]","title":"#m?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#menu?()","text":"[ View source ]","title":"#menu?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#multiply?()","text":"[ View source ]","title":"#multiply?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#n?()","text":"[ View source ]","title":"#n?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num0?()","text":"[ View source ]","title":"#num0?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num1?()","text":"[ View source ]","title":"#num1?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num2?()","text":"[ View source ]","title":"#num2?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num3?()","text":"[ View source ]","title":"#num3?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num4?()","text":"[ View source ]","title":"#num4?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num5?()","text":"[ View source ]","title":"#num5?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num6?()","text":"[ View source ]","title":"#num6?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num7?()","text":"[ View source ]","title":"#num7?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num8?()","text":"[ View source ]","title":"#num8?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#num9?()","text":"[ View source ]","title":"#num9?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad0?()","text":"[ View source ]","title":"#numpad0?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad1?()","text":"[ View source ]","title":"#numpad1?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad2?()","text":"[ View source ]","title":"#numpad2?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad3?()","text":"[ View source ]","title":"#numpad3?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad4?()","text":"[ View source ]","title":"#numpad4?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad5?()","text":"[ View source ]","title":"#numpad5?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad6?()","text":"[ View source ]","title":"#numpad6?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad7?()","text":"[ View source ]","title":"#numpad7?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad8?()","text":"[ View source ]","title":"#numpad8?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#numpad9?()","text":"[ View source ]","title":"#numpad9?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#o?()","text":"[ View source ]","title":"#o?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#p?()","text":"[ View source ]","title":"#p?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#page_down?()","text":"[ View source ]","title":"#page_down?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#page_up?()","text":"[ View source ]","title":"#page_up?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#pause?()","text":"[ View source ]","title":"#pause?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#period?()","text":"[ View source ]","title":"#period?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#q?()","text":"[ View source ]","title":"#q?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#quote?()","text":"[ View source ]","title":"#quote?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#r?()","text":"[ View source ]","title":"#r?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#r_alt?()","text":"[ View source ]","title":"#r_alt?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#r_bracket?()","text":"[ View source ]","title":"#r_bracket?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#r_control?()","text":"[ View source ]","title":"#r_control?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#r_shift?()","text":"[ View source ]","title":"#r_shift?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#r_system?()","text":"[ View source ]","title":"#r_system?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#return?()","text":"[ View source ]","title":"#return?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#right?()","text":"[ View source ]","title":"#right?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#s?()","text":"[ View source ]","title":"#s?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#semi_colon?()","text":"[ View source ]","title":"#semi_colon?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#semicolon?()","text":"[ View source ]","title":"#semicolon?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#slash?()","text":"[ View source ]","title":"#slash?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#space?()","text":"[ View source ]","title":"#space?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#subtract?()","text":"[ View source ]","title":"#subtract?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#t?()","text":"[ View source ]","title":"#t?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#tab?()","text":"[ View source ]","title":"#tab?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#tilde?()","text":"[ View source ]","title":"#tilde?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#u?()","text":"[ View source ]","title":"#u?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#unknown?()","text":"[ View source ]","title":"#unknown?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#up?()","text":"[ View source ]","title":"#up?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#v?()","text":"[ View source ]","title":"#v?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#w?()","text":"[ View source ]","title":"#w?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#x?()","text":"[ View source ]","title":"#x?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#y?()","text":"[ View source ]","title":"#y?"},{"location":"api/SF/Keyboard/Key.html#SF::Keyboard::Key#z?()","text":"[ View source ]","title":"#z?"},{"location":"api/SF/Mouse/Button.html","text":"enum SF::Mouse::Button # Mouse buttons Members # Left # The left mouse button Right # The right mouse button Middle # The middle (wheel) mouse button XButton1 # The first extra mouse button XButton2 # The second extra mouse button ButtonCount # Keep last -- the total number of mouse buttons Methods # #button_count? # [ View source ] #left? # [ View source ] #middle? # [ View source ] #right? # [ View source ] #x_button1? # [ View source ] #x_button2? # [ View source ]","title":"Button"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button","text":"Mouse buttons","title":"Button"},{"location":"api/SF/Mouse/Button.html#members","text":"","title":"Members"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button::Left","text":"The left mouse button","title":"Left"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button::Right","text":"The right mouse button","title":"Right"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button::Middle","text":"The middle (wheel) mouse button","title":"Middle"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button::XButton1","text":"The first extra mouse button","title":"XButton1"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button::XButton2","text":"The second extra mouse button","title":"XButton2"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button::ButtonCount","text":"Keep last -- the total number of mouse buttons","title":"ButtonCount"},{"location":"api/SF/Mouse/Button.html#methods","text":"","title":"Methods"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button#button_count?()","text":"[ View source ]","title":"#button_count?"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button#left?()","text":"[ View source ]","title":"#left?"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button#middle?()","text":"[ View source ]","title":"#middle?"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button#right?()","text":"[ View source ]","title":"#right?"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button#x_button1?()","text":"[ View source ]","title":"#x_button1?"},{"location":"api/SF/Mouse/Button.html#SF::Mouse::Button#x_button2?()","text":"[ View source ]","title":"#x_button2?"},{"location":"api/SF/Mouse/Wheel.html","text":"enum SF::Mouse::Wheel # Mouse wheels Members # VerticalWheel # The vertical mouse wheel HorizontalWheel # The horizontal mouse wheel Methods # #horizontal_wheel? # [ View source ] #vertical_wheel? # [ View source ]","title":"Wheel"},{"location":"api/SF/Mouse/Wheel.html#SF::Mouse::Wheel","text":"Mouse wheels","title":"Wheel"},{"location":"api/SF/Mouse/Wheel.html#members","text":"","title":"Members"},{"location":"api/SF/Mouse/Wheel.html#SF::Mouse::Wheel::VerticalWheel","text":"The vertical mouse wheel","title":"VerticalWheel"},{"location":"api/SF/Mouse/Wheel.html#SF::Mouse::Wheel::HorizontalWheel","text":"The horizontal mouse wheel","title":"HorizontalWheel"},{"location":"api/SF/Mouse/Wheel.html#methods","text":"","title":"Methods"},{"location":"api/SF/Mouse/Wheel.html#SF::Mouse::Wheel#horizontal_wheel?()","text":"[ View source ]","title":"#horizontal_wheel?"},{"location":"api/SF/Mouse/Wheel.html#SF::Mouse::Wheel#vertical_wheel?()","text":"[ View source ]","title":"#vertical_wheel?"},{"location":"api/SF/Music/Span.html","text":"struct SF::Music::Span(T) inherits Struct # Class methods # .new ( offset = T . zero , length = T . zero ) # [ View source ] Methods # #length : T # The length of the time range [ View source ] #length= ( length : T ) # The length of the time range [ View source ] #offset : T # The beginning offset of the time range [ View source ] #offset= ( offset : T ) # The beginning offset of the time range [ View source ]","title":"Span"},{"location":"api/SF/Music/Span.html#SF::Music::Span","text":"","title":"Span"},{"location":"api/SF/Music/Span.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Music/Span.html#SF::Music::Span.new(offset,length)","text":"[ View source ]","title":".new"},{"location":"api/SF/Music/Span.html#methods","text":"","title":"Methods"},{"location":"api/SF/Music/Span.html#SF::Music::Span#length()","text":"The length of the time range [ View source ]","title":"#length"},{"location":"api/SF/Music/Span.html#SF::Music::Span#length=(length)","text":"The length of the time range [ View source ]","title":"#length="},{"location":"api/SF/Music/Span.html#SF::Music::Span#offset()","text":"The beginning offset of the time range [ View source ]","title":"#offset"},{"location":"api/SF/Music/Span.html#SF::Music::Span#offset=(offset)","text":"The beginning offset of the time range [ View source ]","title":"#offset="},{"location":"api/SF/Music/TimeSpan.html","text":"alias SF::Music::TimeSpan # Alias definition # SF :: Music :: Span ( SF :: Time )","title":"TimeSpan"},{"location":"api/SF/Music/TimeSpan.html#SF::Music::TimeSpan","text":"","title":"TimeSpan"},{"location":"api/SF/Music/TimeSpan.html#alias-definition","text":"SF :: Music :: Span ( SF :: Time )","title":"Alias definition"},{"location":"api/SF/Sensor/Type.html","text":"enum SF::Sensor::Type # Sensor type Members # Accelerometer # Measures the raw acceleration (m/s^2) Gyroscope # Measures the raw rotation rates (degrees/s) Magnetometer # Measures the ambient magnetic field (micro-teslas) Gravity # Measures the direction and intensity of gravity, independent of device acceleration (m/s^2) UserAcceleration # Measures the direction and intensity of device acceleration, independent of the gravity (m/s^2) Orientation # Measures the absolute 3D orientation (degrees) Count # Keep last -- the total number of sensor types Methods # #accelerometer? # [ View source ] #count? # [ View source ] #gravity? # [ View source ] #gyroscope? # [ View source ] #magnetometer? # [ View source ] #orientation? # [ View source ] #user_acceleration? # [ View source ]","title":"Type"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type","text":"Sensor type","title":"Type"},{"location":"api/SF/Sensor/Type.html#members","text":"","title":"Members"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type::Accelerometer","text":"Measures the raw acceleration (m/s^2)","title":"Accelerometer"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type::Gyroscope","text":"Measures the raw rotation rates (degrees/s)","title":"Gyroscope"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type::Magnetometer","text":"Measures the ambient magnetic field (micro-teslas)","title":"Magnetometer"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type::Gravity","text":"Measures the direction and intensity of gravity, independent of device acceleration (m/s^2)","title":"Gravity"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type::UserAcceleration","text":"Measures the direction and intensity of device acceleration, independent of the gravity (m/s^2)","title":"UserAcceleration"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type::Orientation","text":"Measures the absolute 3D orientation (degrees)","title":"Orientation"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type::Count","text":"Keep last -- the total number of sensor types","title":"Count"},{"location":"api/SF/Sensor/Type.html#methods","text":"","title":"Methods"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type#accelerometer?()","text":"[ View source ]","title":"#accelerometer?"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type#count?()","text":"[ View source ]","title":"#count?"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type#gravity?()","text":"[ View source ]","title":"#gravity?"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type#gyroscope?()","text":"[ View source ]","title":"#gyroscope?"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type#magnetometer?()","text":"[ View source ]","title":"#magnetometer?"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type#orientation?()","text":"[ View source ]","title":"#orientation?"},{"location":"api/SF/Sensor/Type.html#SF::Sensor::Type#user_acceleration?()","text":"[ View source ]","title":"#user_acceleration?"},{"location":"api/SF/Shader/CurrentTextureType.html","text":"struct SF::Shader::CurrentTextureType inherits Struct # Special type that can be passed to Shader#set_parameter that represents the texture of the object being drawn. Class methods # .new # [ View source ]","title":"CurrentTextureType"},{"location":"api/SF/Shader/CurrentTextureType.html#SF::Shader::CurrentTextureType","text":"Special type that can be passed to Shader#set_parameter that represents the texture of the object being drawn.","title":"CurrentTextureType"},{"location":"api/SF/Shader/CurrentTextureType.html#class-methods","text":"","title":"Class methods"},{"location":"api/SF/Shader/CurrentTextureType.html#SF::Shader::CurrentTextureType.new()","text":"[ View source ]","title":".new"},{"location":"api/SF/Shader/Type.html","text":"enum SF::Shader::Type # Types of shaders Members # Vertex # Vertex shader Geometry # Geometry shader Fragment # Fragment (pixel) shader Methods # #fragment? # [ View source ] #geometry? # [ View source ] #vertex? # [ View source ]","title":"Type"},{"location":"api/SF/Shader/Type.html#SF::Shader::Type","text":"Types of shaders","title":"Type"},{"location":"api/SF/Shader/Type.html#members","text":"","title":"Members"},{"location":"api/SF/Shader/Type.html#SF::Shader::Type::Vertex","text":"Vertex shader","title":"Vertex"},{"location":"api/SF/Shader/Type.html#SF::Shader::Type::Geometry","text":"Geometry shader","title":"Geometry"},{"location":"api/SF/Shader/Type.html#SF::Shader::Type::Fragment","text":"Fragment (pixel) shader","title":"Fragment"},{"location":"api/SF/Shader/Type.html#methods","text":"","title":"Methods"},{"location":"api/SF/Shader/Type.html#SF::Shader::Type#fragment?()","text":"[ View source ]","title":"#fragment?"},{"location":"api/SF/Shader/Type.html#SF::Shader::Type#geometry?()","text":"[ View source ]","title":"#geometry?"},{"location":"api/SF/Shader/Type.html#SF::Shader::Type#vertex?()","text":"[ View source ]","title":"#vertex?"},{"location":"api/SF/Socket/Status.html","text":"enum SF::Socket::Status # Status codes that may be returned by socket functions Members # Done # The socket has sent / received the data NotReady # The socket is not ready to send / receive data yet Partial # The socket sent a part of the data Disconnected # The TCP socket has been disconnected Error # An unexpected error happened Methods # #disconnected? # [ View source ] #done? # [ View source ] #error? # [ View source ] #not_ready? # [ View source ] #partial? # [ View source ]","title":"Status"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status","text":"Status codes that may be returned by socket functions","title":"Status"},{"location":"api/SF/Socket/Status.html#members","text":"","title":"Members"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status::Done","text":"The socket has sent / received the data","title":"Done"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status::NotReady","text":"The socket is not ready to send / receive data yet","title":"NotReady"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status::Partial","text":"The socket sent a part of the data","title":"Partial"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status::Disconnected","text":"The TCP socket has been disconnected","title":"Disconnected"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status::Error","text":"An unexpected error happened","title":"Error"},{"location":"api/SF/Socket/Status.html#methods","text":"","title":"Methods"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status#disconnected?()","text":"[ View source ]","title":"#disconnected?"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status#done?()","text":"[ View source ]","title":"#done?"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status#error?()","text":"[ View source ]","title":"#error?"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status#not_ready?()","text":"[ View source ]","title":"#not_ready?"},{"location":"api/SF/Socket/Status.html#SF::Socket::Status#partial?()","text":"[ View source ]","title":"#partial?"},{"location":"api/SF/Socket/Type.html","text":"enum SF::Socket::Type # Types of protocols that the socket can use Members # Tcp # TCP protocol Udp # UDP protocol Methods # #tcp? # [ View source ] #udp? # [ View source ]","title":"Type"},{"location":"api/SF/Socket/Type.html#SF::Socket::Type","text":"Types of protocols that the socket can use","title":"Type"},{"location":"api/SF/Socket/Type.html#members","text":"","title":"Members"},{"location":"api/SF/Socket/Type.html#SF::Socket::Type::Tcp","text":"TCP protocol","title":"Tcp"},{"location":"api/SF/Socket/Type.html#SF::Socket::Type::Udp","text":"UDP protocol","title":"Udp"},{"location":"api/SF/Socket/Type.html#methods","text":"","title":"Methods"},{"location":"api/SF/Socket/Type.html#SF::Socket::Type#tcp?()","text":"[ View source ]","title":"#tcp?"},{"location":"api/SF/Socket/Type.html#SF::Socket::Type#udp?()","text":"[ View source ]","title":"#udp?"},{"location":"api/SF/SoundSource/Status.html","text":"enum SF::SoundSource::Status # Enumeration of the sound source states Members # Stopped # Sound is not playing Paused # Sound is paused Playing # Sound is playing Methods # #paused? # [ View source ] #playing? # [ View source ] #stopped? # [ View source ]","title":"Status"},{"location":"api/SF/SoundSource/Status.html#SF::SoundSource::Status","text":"Enumeration of the sound source states","title":"Status"},{"location":"api/SF/SoundSource/Status.html#members","text":"","title":"Members"},{"location":"api/SF/SoundSource/Status.html#SF::SoundSource::Status::Stopped","text":"Sound is not playing","title":"Stopped"},{"location":"api/SF/SoundSource/Status.html#SF::SoundSource::Status::Paused","text":"Sound is paused","title":"Paused"},{"location":"api/SF/SoundSource/Status.html#SF::SoundSource::Status::Playing","text":"Sound is playing","title":"Playing"},{"location":"api/SF/SoundSource/Status.html#methods","text":"","title":"Methods"},{"location":"api/SF/SoundSource/Status.html#SF::SoundSource::Status#paused?()","text":"[ View source ]","title":"#paused?"},{"location":"api/SF/SoundSource/Status.html#SF::SoundSource::Status#playing?()","text":"[ View source ]","title":"#playing?"},{"location":"api/SF/SoundSource/Status.html#SF::SoundSource::Status#stopped?()","text":"[ View source ]","title":"#stopped?"},{"location":"api/SF/Text/Style.html","text":"enum SF::Text::Style # Enumeration of the string drawing styles Members # Regular # Regular characters, no style Bold # Bold characters Italic # Italic characters Underlined # Underlined characters StrikeThrough # Strike through characters Methods # #bold? # [ View source ] #italic? # [ View source ] #none? # [ View source ] #regular? # [ View source ] #strike_through? # [ View source ] #underlined? # [ View source ]","title":"Style"},{"location":"api/SF/Text/Style.html#SF::Text::Style","text":"Enumeration of the string drawing styles","title":"Style"},{"location":"api/SF/Text/Style.html#members","text":"","title":"Members"},{"location":"api/SF/Text/Style.html#SF::Text::Style::Regular","text":"Regular characters, no style","title":"Regular"},{"location":"api/SF/Text/Style.html#SF::Text::Style::Bold","text":"Bold characters","title":"Bold"},{"location":"api/SF/Text/Style.html#SF::Text::Style::Italic","text":"Italic characters","title":"Italic"},{"location":"api/SF/Text/Style.html#SF::Text::Style::Underlined","text":"Underlined characters","title":"Underlined"},{"location":"api/SF/Text/Style.html#SF::Text::Style::StrikeThrough","text":"Strike through characters","title":"StrikeThrough"},{"location":"api/SF/Text/Style.html#methods","text":"","title":"Methods"},{"location":"api/SF/Text/Style.html#SF::Text::Style#bold?()","text":"[ View source ]","title":"#bold?"},{"location":"api/SF/Text/Style.html#SF::Text::Style#italic?()","text":"[ View source ]","title":"#italic?"},{"location":"api/SF/Text/Style.html#SF::Text::Style#none?()","text":"[ View source ]","title":"#none?"},{"location":"api/SF/Text/Style.html#SF::Text::Style#regular?()","text":"[ View source ]","title":"#regular?"},{"location":"api/SF/Text/Style.html#SF::Text::Style#strike_through?()","text":"[ View source ]","title":"#strike_through?"},{"location":"api/SF/Text/Style.html#SF::Text::Style#underlined?()","text":"[ View source ]","title":"#underlined?"},{"location":"api/SF/Texture/CoordinateType.html","text":"enum SF::Texture::CoordinateType # Types of texture coordinates that can be used for rendering Members # Normalized # Texture coordinates in range 0.0 .. 1.0 Pixels # Texture coordinates in range 0.0 .. size Methods # #normalized? # [ View source ] #pixels? # [ View source ]","title":"CoordinateType"},{"location":"api/SF/Texture/CoordinateType.html#SF::Texture::CoordinateType","text":"Types of texture coordinates that can be used for rendering","title":"CoordinateType"},{"location":"api/SF/Texture/CoordinateType.html#members","text":"","title":"Members"},{"location":"api/SF/Texture/CoordinateType.html#SF::Texture::CoordinateType::Normalized","text":"Texture coordinates in range 0.0 .. 1.0","title":"Normalized"},{"location":"api/SF/Texture/CoordinateType.html#SF::Texture::CoordinateType::Pixels","text":"Texture coordinates in range 0.0 .. size","title":"Pixels"},{"location":"api/SF/Texture/CoordinateType.html#methods","text":"","title":"Methods"},{"location":"api/SF/Texture/CoordinateType.html#SF::Texture::CoordinateType#normalized?()","text":"[ View source ]","title":"#normalized?"},{"location":"api/SF/Texture/CoordinateType.html#SF::Texture::CoordinateType#pixels?()","text":"[ View source ]","title":"#pixels?"},{"location":"api/SF/VertexBuffer/Usage.html","text":"enum SF::VertexBuffer::Usage # Usage specifiers If data is going to be updated once or more every frame, set the usage to Stream. If data is going to be set once and used for a long time without being modified, set the usage to Static. For everything else Dynamic should be a good compromise. Members # Stream # Constantly changing data Dynamic # Occasionally changing data Static # Rarely changing data Methods # #dynamic? # [ View source ] #static? # [ View source ] #stream? # [ View source ]","title":"Usage"},{"location":"api/SF/VertexBuffer/Usage.html#SF::VertexBuffer::Usage","text":"Usage specifiers If data is going to be updated once or more every frame, set the usage to Stream. If data is going to be set once and used for a long time without being modified, set the usage to Static. For everything else Dynamic should be a good compromise.","title":"Usage"},{"location":"api/SF/VertexBuffer/Usage.html#members","text":"","title":"Members"},{"location":"api/SF/VertexBuffer/Usage.html#SF::VertexBuffer::Usage::Stream","text":"Constantly changing data","title":"Stream"},{"location":"api/SF/VertexBuffer/Usage.html#SF::VertexBuffer::Usage::Dynamic","text":"Occasionally changing data","title":"Dynamic"},{"location":"api/SF/VertexBuffer/Usage.html#SF::VertexBuffer::Usage::Static","text":"Rarely changing data","title":"Static"},{"location":"api/SF/VertexBuffer/Usage.html#methods","text":"","title":"Methods"},{"location":"api/SF/VertexBuffer/Usage.html#SF::VertexBuffer::Usage#dynamic?()","text":"[ View source ]","title":"#dynamic?"},{"location":"api/SF/VertexBuffer/Usage.html#SF::VertexBuffer::Usage#static?()","text":"[ View source ]","title":"#static?"},{"location":"api/SF/VertexBuffer/Usage.html#SF::VertexBuffer::Usage#stream?()","text":"[ View source ]","title":"#stream?"},{"location":"tutorials/audio/recording.html","text":"Recording audio # Relevant example: sound_capture Recording to a sound buffer # The most common use for captured audio data is for it to be saved to a sound buffer ( SF::SoundBuffer ) so that it can either be played or saved to a file. This can be achieved with the very simple interface of the SF::SoundBufferRecorder class: # first check if an input audio device is available on the system if ! SF :: SoundBufferRecorder . available? # error: audio capture is not available on this system ... end # create the recorder recorder = SF :: SoundBufferRecorder . new # start the capture recorder . start # wait... # stop the capture recorder . stop # retrieve the buffer that contains the captured audio data buffer = recorder . buffer The SoundBufferRecorder.available? class method checks if audio recording is supported by the system. It if returns false , you won't be able to use the SF::SoundBufferRecorder class at all. The start and stop methods are self-explanatory. The capture runs in its own thread, which means that you can do whatever you want between start and stop. After the end of the capture, the recorded audio data is available in a sound buffer that you can get with the buffer method. With the recorded data, you can then: Save it to a file buffer . save_to_file ( \"my_record.ogg\" ) Play it directly sound = SF :: Sound . new ( buffer ) sound . play Access the raw audio data and analyze it, transform it, etc. samples = buffer . samples count = buffer . sample_count do_something ( samples , count ) If you want to use the captured audio data after the recorder is destroyed or restarted, don't forget to make a copy of the buffer. Selecting the input device # If you have multiple sound input devices connected to your computer (for example a microphone, a sound interface (external soundcard) or a webcam microphone) you can specify the device that is used for recording. A sound input device is identified by its name. An Array(String) containing the names of all connected devices is available through the class method SoundBufferRecorder.available_devices . You can then select a device from the list for recording, by passing the chosen device name to the device= method. It is even possible to change the device on the fly (i.e. while recording). The name of the currently used device can be obtained by calling device . If you don't choose a device yourself, the default device will be used. Its name can be obtained through the default_device class method. Here is a small example of how to set the input device: # get the available sound input device names available_devices = SF :: SoundRecorder . available_devices # choose a device input_device = available_devices [ 0 ] # create the recorder recorder = SF :: SoundBufferRecorder . new # set the device unless recorder . device = input_device # error: device selection failed ... end # use recorder as usual","title":"Recording audio"},{"location":"tutorials/audio/recording.html#recording-audio","text":"Relevant example: sound_capture","title":"Recording audio"},{"location":"tutorials/audio/recording.html#recording-to-a-sound-buffer","text":"The most common use for captured audio data is for it to be saved to a sound buffer ( SF::SoundBuffer ) so that it can either be played or saved to a file. This can be achieved with the very simple interface of the SF::SoundBufferRecorder class: # first check if an input audio device is available on the system if ! SF :: SoundBufferRecorder . available? # error: audio capture is not available on this system ... end # create the recorder recorder = SF :: SoundBufferRecorder . new # start the capture recorder . start # wait... # stop the capture recorder . stop # retrieve the buffer that contains the captured audio data buffer = recorder . buffer The SoundBufferRecorder.available? class method checks if audio recording is supported by the system. It if returns false , you won't be able to use the SF::SoundBufferRecorder class at all. The start and stop methods are self-explanatory. The capture runs in its own thread, which means that you can do whatever you want between start and stop. After the end of the capture, the recorded audio data is available in a sound buffer that you can get with the buffer method. With the recorded data, you can then: Save it to a file buffer . save_to_file ( \"my_record.ogg\" ) Play it directly sound = SF :: Sound . new ( buffer ) sound . play Access the raw audio data and analyze it, transform it, etc. samples = buffer . samples count = buffer . sample_count do_something ( samples , count ) If you want to use the captured audio data after the recorder is destroyed or restarted, don't forget to make a copy of the buffer.","title":"Recording to a sound buffer"},{"location":"tutorials/audio/recording.html#selecting-the-input-device","text":"If you have multiple sound input devices connected to your computer (for example a microphone, a sound interface (external soundcard) or a webcam microphone) you can specify the device that is used for recording. A sound input device is identified by its name. An Array(String) containing the names of all connected devices is available through the class method SoundBufferRecorder.available_devices . You can then select a device from the list for recording, by passing the chosen device name to the device= method. It is even possible to change the device on the fly (i.e. while recording). The name of the currently used device can be obtained by calling device . If you don't choose a device yourself, the default device will be used. Its name can be obtained through the default_device class method. Here is a small example of how to set the input device: # get the available sound input device names available_devices = SF :: SoundRecorder . available_devices # choose a device input_device = available_devices [ 0 ] # create the recorder recorder = SF :: SoundBufferRecorder . new # set the device unless recorder . device = input_device # error: device selection failed ... end # use recorder as usual","title":"Selecting the input device"},{"location":"tutorials/audio/sounds.html","text":"Playing sounds and music # Sound or music? # SFML provides two classes for playing audio: SF::Sound and SF::Music . They both provide more or less the same features, the main difference is how they work. SF::Sound is a lightweight object that plays loaded audio data from a SF::SoundBuffer . It should be used for small sounds that can fit in memory and should suffer no lag when they are played. Examples are gun shots, foot steps, etc. SF::Music doesn't load all the audio data into memory, instead it streams it on the fly from the source file. It is typically used to play compressed music that lasts several minutes, and would otherwise take many seconds to load and eat hundreds of MB in memory. Loading and playing a sound # As mentioned above, the sound data is not stored directly in SF::Sound but in a separate class named SF::SoundBuffer . This class encapsulates the audio data, which is basically an array of 16-bit signed integers (called \"audio samples\"). A sample is the amplitude of the sound signal at a given point in time, and an array of samples therefore represents a full sound. In fact, the SF::Sound / SF::SoundBuffer classes work the same way as SF::Sprite / SF::Texture from the graphics module. So if you understand how sprites and textures work together, you can apply the same concept to sounds and sound buffers. You can load a sound buffer from a file on disk with its from_file class method: SF :: SoundBuffer . from_file ( \"sound.wav\" ) As with everything else, you can also load an audio file from memory ( from_memory ) or from a custom input stream ( from_stream ). SFML supports the audio file formats WAV, OGG/Vorbis and FLAC. Due to licensing issues MP3 is not supported. You can also load a sound buffer directly from an array of samples, in the case they originate from another source: buffer . from_samples ( samples , samples . size , 2 , 44100 ) Since from_samples loads a raw array of samples rather than an audio file, it requires additional arguments in order to have a complete description of the sound. The first one (third argument) is the number of channels; 1 channel defines a mono sound, 2 channels define a stereo sound, etc. The second additional attribute (fourth argument) is the sample rate; it defines how many samples must be played per second in order to reconstruct the original sound. Now that the audio data is loaded, we can play it with a SF::Sound instance. # load something into the sound buffer... buffer = ... sound = SF :: Sound . new ( buffer ) sound . play The cool thing is that you can assign the same sound buffer to multiple sounds if you want. You can even play them together without any issues. Sounds (and music) are played in a separate thread. This means that you are free to do whatever you want after calling play (except destroying the sound or its data, of course), the sound will continue to play until it's finished or explicitly stopped. Playing a music # Unlike SF::Sound , SF::Music doesn't pre-load the audio data, instead it streams the data directly from the source. The initialization of music is thus more direct: music = SF :: Music . from_file ( \"music.ogg\" ) music . play It is important to note that, unlike all other SFML resources, the loading class method only opens the file. The music is not really loaded, this method merely opens it. The data is only loaded later, when the music is played. It also helps to keep in mind that the audio file has to remain available as long as it is played. The other loading methods of SF::Music follow the same convention: from_memory , from_stream . What's next? # Now that you are able to load and play a sound or music, let's see what you can do with it. To control playback, the following methods are available: play starts or resumes playback pause pauses playback stop stops playback and rewind playing_offset= changes the current playing position Example: # start playback sound . play # advance to 2 seconds sound . playing_offset = SF . seconds ( 2 ) # pause playback sound . pause # resume playback sound . play # stop playback and rewind sound . stop The status method returns the current status of a sound or music, you can use it to know whether it is stopped, playing or paused. Sound and music playback is also controlled by a few attributes which can be changed at any moment. The pitch is a factor that changes the perceived frequency of the sound: greater than 1 plays the sound at a higher pitch, less than 1 plays the sound at a lower pitch, and 1 leaves it unchanged. Changing the pitch has a side effect: it impacts the playing speed. sound . pitch = 1.2 The volume is... the volume. The value ranges from 0 (mute) to 100 (full volume). The default value is 100, which means that you can't make a sound louder than its initial volume. sound . volume = 50 The loop attribute controls whether the sound/music automatically loops or not. If it loops, it will restart playing from the beginning when it's finished, again and again until you explicitly call stop . If not set to loop, it will stop automatically when it's finished. sound . loop = true More attributes are available, but they are related to spatialization and are explained in the corresponding tutorial . Common mistakes # Too many sounds # One source of error is when you try to create a huge number of sounds. SFML internally has a limit; it can vary depending on the OS, but you should never exceed 256. This limit is the number of SF::Sound and SF::Music instances that can exist simultaneously. A good way to stay below the limit is to destroy (or recycle) unused sounds when they are no longer needed. This only applies if you have to manage a really large amount of sounds and music, of course. Destroying the music source while it plays # Remember that a music needs its source as long as it is played. A music file on your disk probably won't be deleted or moved while your application plays it, however things get more complicated when you play a music from a file in memory, or from a custom input stream: # we start with a music file in memory (imagine that we extracted it from a zip archive) file_data = ... # we play it music = SF :: Music . from_memory ( file_data ) music . play # \"ok, it seems that we don't need the source file any longer\" file_data . clear # ERROR: the music was still streaming the contents of file_data! The behavior is now undefined","title":"Playing sounds and music"},{"location":"tutorials/audio/sounds.html#playing-sounds-and-music","text":"","title":"Playing sounds and music"},{"location":"tutorials/audio/sounds.html#sound-or-music","text":"SFML provides two classes for playing audio: SF::Sound and SF::Music . They both provide more or less the same features, the main difference is how they work. SF::Sound is a lightweight object that plays loaded audio data from a SF::SoundBuffer . It should be used for small sounds that can fit in memory and should suffer no lag when they are played. Examples are gun shots, foot steps, etc. SF::Music doesn't load all the audio data into memory, instead it streams it on the fly from the source file. It is typically used to play compressed music that lasts several minutes, and would otherwise take many seconds to load and eat hundreds of MB in memory.","title":"Sound or music?"},{"location":"tutorials/audio/sounds.html#loading-and-playing-a-sound","text":"As mentioned above, the sound data is not stored directly in SF::Sound but in a separate class named SF::SoundBuffer . This class encapsulates the audio data, which is basically an array of 16-bit signed integers (called \"audio samples\"). A sample is the amplitude of the sound signal at a given point in time, and an array of samples therefore represents a full sound. In fact, the SF::Sound / SF::SoundBuffer classes work the same way as SF::Sprite / SF::Texture from the graphics module. So if you understand how sprites and textures work together, you can apply the same concept to sounds and sound buffers. You can load a sound buffer from a file on disk with its from_file class method: SF :: SoundBuffer . from_file ( \"sound.wav\" ) As with everything else, you can also load an audio file from memory ( from_memory ) or from a custom input stream ( from_stream ). SFML supports the audio file formats WAV, OGG/Vorbis and FLAC. Due to licensing issues MP3 is not supported. You can also load a sound buffer directly from an array of samples, in the case they originate from another source: buffer . from_samples ( samples , samples . size , 2 , 44100 ) Since from_samples loads a raw array of samples rather than an audio file, it requires additional arguments in order to have a complete description of the sound. The first one (third argument) is the number of channels; 1 channel defines a mono sound, 2 channels define a stereo sound, etc. The second additional attribute (fourth argument) is the sample rate; it defines how many samples must be played per second in order to reconstruct the original sound. Now that the audio data is loaded, we can play it with a SF::Sound instance. # load something into the sound buffer... buffer = ... sound = SF :: Sound . new ( buffer ) sound . play The cool thing is that you can assign the same sound buffer to multiple sounds if you want. You can even play them together without any issues. Sounds (and music) are played in a separate thread. This means that you are free to do whatever you want after calling play (except destroying the sound or its data, of course), the sound will continue to play until it's finished or explicitly stopped.","title":"Loading and playing a sound"},{"location":"tutorials/audio/sounds.html#playing-a-music","text":"Unlike SF::Sound , SF::Music doesn't pre-load the audio data, instead it streams the data directly from the source. The initialization of music is thus more direct: music = SF :: Music . from_file ( \"music.ogg\" ) music . play It is important to note that, unlike all other SFML resources, the loading class method only opens the file. The music is not really loaded, this method merely opens it. The data is only loaded later, when the music is played. It also helps to keep in mind that the audio file has to remain available as long as it is played. The other loading methods of SF::Music follow the same convention: from_memory , from_stream .","title":"Playing a music"},{"location":"tutorials/audio/sounds.html#whats-next","text":"Now that you are able to load and play a sound or music, let's see what you can do with it. To control playback, the following methods are available: play starts or resumes playback pause pauses playback stop stops playback and rewind playing_offset= changes the current playing position Example: # start playback sound . play # advance to 2 seconds sound . playing_offset = SF . seconds ( 2 ) # pause playback sound . pause # resume playback sound . play # stop playback and rewind sound . stop The status method returns the current status of a sound or music, you can use it to know whether it is stopped, playing or paused. Sound and music playback is also controlled by a few attributes which can be changed at any moment. The pitch is a factor that changes the perceived frequency of the sound: greater than 1 plays the sound at a higher pitch, less than 1 plays the sound at a lower pitch, and 1 leaves it unchanged. Changing the pitch has a side effect: it impacts the playing speed. sound . pitch = 1.2 The volume is... the volume. The value ranges from 0 (mute) to 100 (full volume). The default value is 100, which means that you can't make a sound louder than its initial volume. sound . volume = 50 The loop attribute controls whether the sound/music automatically loops or not. If it loops, it will restart playing from the beginning when it's finished, again and again until you explicitly call stop . If not set to loop, it will stop automatically when it's finished. sound . loop = true More attributes are available, but they are related to spatialization and are explained in the corresponding tutorial .","title":"What's next?"},{"location":"tutorials/audio/sounds.html#common-mistakes","text":"","title":"Common mistakes"},{"location":"tutorials/audio/sounds.html#too-many-sounds","text":"One source of error is when you try to create a huge number of sounds. SFML internally has a limit; it can vary depending on the OS, but you should never exceed 256. This limit is the number of SF::Sound and SF::Music instances that can exist simultaneously. A good way to stay below the limit is to destroy (or recycle) unused sounds when they are no longer needed. This only applies if you have to manage a really large amount of sounds and music, of course.","title":"Too many sounds"},{"location":"tutorials/audio/sounds.html#destroying-the-music-source-while-it-plays","text":"Remember that a music needs its source as long as it is played. A music file on your disk probably won't be deleted or moved while your application plays it, however things get more complicated when you play a music from a file in memory, or from a custom input stream: # we start with a music file in memory (imagine that we extracted it from a zip archive) file_data = ... # we play it music = SF :: Music . from_memory ( file_data ) music . play # \"ok, it seems that we don't need the source file any longer\" file_data . clear # ERROR: the music was still streaming the contents of file_data! The behavior is now undefined","title":"Destroying the music source while it plays"},{"location":"tutorials/audio/spatialization.html","text":"Spatialization: Sounds in 3D # Introduction # By default, sounds and music are played at full volume in each speaker; they are not spatialized . If a sound is emitted by an entity which is to the right of the screen, you would probably want to hear it from the right speaker. If a music is being played behind the player, you would want to hear it from the rear speakers of your Dolby 5.1 sound system. How can this be achieved? Spatialized sounds are mono # A sound can be spatialized only if it has a single channel, i.e. if it's a mono sound. Spatialization is disabled for sounds with more channels, since they already explicitly decide how to use the speakers. This is very important to keep in mind. The listener # All the sounds and music in your audio environment will be heard by a single actor: the listener . What is output from your speakers is determined by what the listener hears. The class which defines the listener's properties is SF::Listener . Since the listener is unique in the environment, this class only contains class methods and is not meant to be instantiated. First, you can set the listener's position in the scene: SF :: Listener . position = SF . vector3f ( 10.0 , 0.0 , 5.0 ) If you have a 2D world you can just use the same Y value everywhere, usually 0. In addition to its position, you can define the listener's orientation: SF :: Listener . direction = SF . vector3f ( 1.0 , 0.0 , 0.0 ) Here, the listener is oriented along the +X axis. This means that, for example, a sound emitted at (15, 0, 5) will be heard from the right speaker. The \"up\" vector of the listener is set to (0, 1, 0) by default, in other words, the top of the listener's head is pointing towards +Y. You can change the \"up\" vector if you want. It is rarely necessary though. SF :: Listener . up_vector = SF . vector3f ( 1.0 , 1.0 , 0.0 ) This corresponds to the listener tilting their head towards the right (+X). Finally, the listener can adjust the global volume of the scene: SF :: Listener . global_volume = 50.0 The value of the volume is in the range [0 .. 100], so setting it to 50 reduces it to half of the original volume. Of course, all these properties can be read with the corresponding getter methods. Audio sources # Every audio source provided by SFML (sounds, music, streams) defines the same properties for spatialization. The main property is the position of the audio source. sound . position = SF . vector3f ( 2.0 , 0.0 , - 5.0 ) This position is absolute by default, but it can be relative to the listener if needed. sound . relative_to_listener = true This can be useful for sounds emitted by the listener itself (like a gun shot, or foot steps). It also has the interesting side-effect of disabling spatialization if you set the position of the audio source to (0, 0, 0). Non-spatialized sounds can be required in various situations: GUI sounds (clicks), ambient music, etc. You can also set the factor by which audio sources will be attenuated depending on their distance to the listener. sound . min_distance = 5.0 sound . attenuation = 10.0 The minimum distance is the distance under which the sound will be heard at its maximum volume. As an example, louder sounds such as explosions should have a higher minimum distance to ensure that they will be heard from far away. Please note that a minimum distance of 0 (the sound is inside the head of the listener!) would lead to an incorrect spatialization and result in a non-attenuated sound. 0 is an invalid value, never use it. The attenuation is a multiplicative factor. The greater the attenuation, the less it will be heard when the sound moves away from the listener. To get a non-attenuated sound, you can use 0. On the other hand, using a value like 100 will highly attenuate the sound, which means that it will be heard only if very close to the listener. Here is the exact attenuation formula, in case you need accurate values: MinDistance is the sound's minimum distance, set with min_distance= Attenuation is the sound's attenuation, set with attenuation= Distance is the distance between the sound and the listener Volume factor is the calculated factor, in range [0 .. 1], that will be applied to the sound's volume Volume factor = MinDistance / (MinDistance + Attenuation * (max(Distance, MinDistance) - MinDistance))","title":"Spatialization: Sounds in 3D"},{"location":"tutorials/audio/spatialization.html#spatialization-sounds-in-3d","text":"","title":"Spatialization: Sounds in 3D"},{"location":"tutorials/audio/spatialization.html#introduction","text":"By default, sounds and music are played at full volume in each speaker; they are not spatialized . If a sound is emitted by an entity which is to the right of the screen, you would probably want to hear it from the right speaker. If a music is being played behind the player, you would want to hear it from the rear speakers of your Dolby 5.1 sound system. How can this be achieved?","title":"Introduction"},{"location":"tutorials/audio/spatialization.html#spatialized-sounds-are-mono","text":"A sound can be spatialized only if it has a single channel, i.e. if it's a mono sound. Spatialization is disabled for sounds with more channels, since they already explicitly decide how to use the speakers. This is very important to keep in mind.","title":"Spatialized sounds are mono"},{"location":"tutorials/audio/spatialization.html#the-listener","text":"All the sounds and music in your audio environment will be heard by a single actor: the listener . What is output from your speakers is determined by what the listener hears. The class which defines the listener's properties is SF::Listener . Since the listener is unique in the environment, this class only contains class methods and is not meant to be instantiated. First, you can set the listener's position in the scene: SF :: Listener . position = SF . vector3f ( 10.0 , 0.0 , 5.0 ) If you have a 2D world you can just use the same Y value everywhere, usually 0. In addition to its position, you can define the listener's orientation: SF :: Listener . direction = SF . vector3f ( 1.0 , 0.0 , 0.0 ) Here, the listener is oriented along the +X axis. This means that, for example, a sound emitted at (15, 0, 5) will be heard from the right speaker. The \"up\" vector of the listener is set to (0, 1, 0) by default, in other words, the top of the listener's head is pointing towards +Y. You can change the \"up\" vector if you want. It is rarely necessary though. SF :: Listener . up_vector = SF . vector3f ( 1.0 , 1.0 , 0.0 ) This corresponds to the listener tilting their head towards the right (+X). Finally, the listener can adjust the global volume of the scene: SF :: Listener . global_volume = 50.0 The value of the volume is in the range [0 .. 100], so setting it to 50 reduces it to half of the original volume. Of course, all these properties can be read with the corresponding getter methods.","title":"The listener"},{"location":"tutorials/audio/spatialization.html#audio-sources","text":"Every audio source provided by SFML (sounds, music, streams) defines the same properties for spatialization. The main property is the position of the audio source. sound . position = SF . vector3f ( 2.0 , 0.0 , - 5.0 ) This position is absolute by default, but it can be relative to the listener if needed. sound . relative_to_listener = true This can be useful for sounds emitted by the listener itself (like a gun shot, or foot steps). It also has the interesting side-effect of disabling spatialization if you set the position of the audio source to (0, 0, 0). Non-spatialized sounds can be required in various situations: GUI sounds (clicks), ambient music, etc. You can also set the factor by which audio sources will be attenuated depending on their distance to the listener. sound . min_distance = 5.0 sound . attenuation = 10.0 The minimum distance is the distance under which the sound will be heard at its maximum volume. As an example, louder sounds such as explosions should have a higher minimum distance to ensure that they will be heard from far away. Please note that a minimum distance of 0 (the sound is inside the head of the listener!) would lead to an incorrect spatialization and result in a non-attenuated sound. 0 is an invalid value, never use it. The attenuation is a multiplicative factor. The greater the attenuation, the less it will be heard when the sound moves away from the listener. To get a non-attenuated sound, you can use 0. On the other hand, using a value like 100 will highly attenuate the sound, which means that it will be heard only if very close to the listener. Here is the exact attenuation formula, in case you need accurate values: MinDistance is the sound's minimum distance, set with min_distance= Attenuation is the sound's attenuation, set with attenuation= Distance is the distance between the sound and the listener Volume factor is the calculated factor, in range [0 .. 1], that will be applied to the sound's volume Volume factor = MinDistance / (MinDistance + Attenuation * (max(Distance, MinDistance) - MinDistance))","title":"Audio sources"},{"location":"tutorials/audio/streams.html","text":"Custom audio streams # Relevant example: echo Audio stream? What's that? # An audio stream is similar to music (remember the SF::Music class?). It has almost the same methods and behaves the same. The only difference is that an audio stream doesn't play an audio file: Instead, it plays a custom audio source that you directly provide. In other words, defining your own audio stream allows you to play from more than just a file: A sound streamed over the network, music generated by your program, an audio format that SFML doesn't support, etc. In fact, the SF::Music class is just a specialized audio stream that gets its audio samples from a file. Since we're talking about streaming , we'll deal with audio data that cannot be loaded entirely in memory, and will instead be loaded in small chunks while it is being played. If your sound can be loaded completely and can fit in memory, then audio streams won't help you: Just load the audio data into a SF::SoundBuffer and use a regular SF::Sound to play it. SF::SoundStream # In order to define your own audio stream, you need to inherit from the SF::SoundStream abstract base class. There are two methods to override in your derived class: on_get_data and on_seek . class MyAudioStream < SF :: SoundStream def on_get_data () : Slice ( Int16 )? end def on_seek ( time_offset : Time ) end end on_get_data is called by the base class whenever it runs out of audio samples and needs more of them. You must provide new audio samples by returning a slice with data: class MyAudioStream < SF :: SoundStream def get_data () samples_array . to_slice end end You must return a non-empty slice when everything is all right, or nil if playback must be stopped, either because an error has occurred or because there's simply no more audio data to play. SFML makes an internal copy of the audio samples as soon as on_get_data returns, so you don't have to keep the original data alive if you don't want to. The on_seek method is called when the playing_offset= public method is called. Its purpose is to change the current playing position in the source data. The parameter is a time value representing the new position, from the beginning of the sound ( not from the current position). This method is sometimes impossible to implement. In those cases leave it empty, and tell the users of your class that changing the playing position is not supported. Now your class is almost ready to work. The only thing that SF::SoundStream needs to know now is the channel count and sample rate of your stream, so that it can be played as expected. # where this is done totally depends on how your stream class is designed MyAudioStream . new ( channel_count : ... , sample_rate : ... ) Threading issues # Audio streams are always played in a separate thread, therefore it is important to know what happens exactly, and where. on_seek is called directly by the playing_offset= function, so it is always executed in the caller thread. However, the on_get_data function will be called repeatedly as long as the stream is being played, in a separate thread created by SFML. If your stream uses data that may be accessed concurrently in both the caller thread and in the playing thread, you have to protect it (with a mutex for example) in order to avoid concurrent access, which may cause undefined behavior -- corrupt data being played, crashes, etc. If you're not familiar enough with threading, you can refer to the corresponding tutorial for more information. Using your audio stream # Now that you have defined your own audio stream class, let's see how to use it. In fact, things are very similar to what's shown in the tutorial about SF::Music . You can control playback with the play , pause , stop and playing_offset= methods. You can also play with the sound's properties, such as the volume or the pitch. You can refer to the API documentation or to the other audio tutorials for more details. A simple example # Here is a very simple example of a custom audio stream class which plays the data of a sound buffer. Such a class might seem totally useless, but the point here is to focus on how the data is streamed by the class, regardless of where it comes from. require \"crsfml/system\" require \"crsfml/audio\" # custom audio stream that plays a loaded buffer class MyStream < SF :: SoundStream @samples : Slice ( Int16 ) def initialize ( @buffer : SF :: SoundBuffer ) # get a slice that points to the buffer with samples @samples = buffer . samples . to_slice ( buffer . sample_count ) # reset the current playing position @current_sample = 0 # initialize the base class super ( buffer . channel_count , buffer . sample_rate ) end def on_get_data () # number of samples to stream every time the function is called; # in a more robust implementation, it should be a fixed # amount of time rather than an arbitrary number of samples to_stream = { 50000 , @samples . size - @current_sample } . min # if the end is close, set the number to play the remaining samples # if nothing left to play return nil unless to_stream > 0 # the next audio samples to be played result = ( @samples . to_unsafe + @current_sample ) . to_slice ( to_stream ) # advance the position @current_sample += to_stream result end def on_seek ( time_offset ) # compute the corresponding sample index according to the # sample rate and channel count @current_sample = ( time_offset . as_seconds * sample_rate * channel_count ) . to_i end end # load an audio buffer from a sound file buffer = SF :: SoundBuffer . from_file ( \"canary.wav\" ) # initialize and play our custom stream stream = MyStream . new ( buffer ) stream . play # let it play until it is finished while stream . status == SF :: SoundSource :: Playing SF . sleep ( SF . seconds ( 1 )) # jump back every so often stream . playing_offset -= SF . seconds ( 0.7 ) end","title":"Custom audio streams"},{"location":"tutorials/audio/streams.html#custom-audio-streams","text":"Relevant example: echo","title":"Custom audio streams"},{"location":"tutorials/audio/streams.html#audio-stream-whats-that","text":"An audio stream is similar to music (remember the SF::Music class?). It has almost the same methods and behaves the same. The only difference is that an audio stream doesn't play an audio file: Instead, it plays a custom audio source that you directly provide. In other words, defining your own audio stream allows you to play from more than just a file: A sound streamed over the network, music generated by your program, an audio format that SFML doesn't support, etc. In fact, the SF::Music class is just a specialized audio stream that gets its audio samples from a file. Since we're talking about streaming , we'll deal with audio data that cannot be loaded entirely in memory, and will instead be loaded in small chunks while it is being played. If your sound can be loaded completely and can fit in memory, then audio streams won't help you: Just load the audio data into a SF::SoundBuffer and use a regular SF::Sound to play it.","title":"Audio stream? What's that?"},{"location":"tutorials/audio/streams.html#sfsoundstream","text":"In order to define your own audio stream, you need to inherit from the SF::SoundStream abstract base class. There are two methods to override in your derived class: on_get_data and on_seek . class MyAudioStream < SF :: SoundStream def on_get_data () : Slice ( Int16 )? end def on_seek ( time_offset : Time ) end end on_get_data is called by the base class whenever it runs out of audio samples and needs more of them. You must provide new audio samples by returning a slice with data: class MyAudioStream < SF :: SoundStream def get_data () samples_array . to_slice end end You must return a non-empty slice when everything is all right, or nil if playback must be stopped, either because an error has occurred or because there's simply no more audio data to play. SFML makes an internal copy of the audio samples as soon as on_get_data returns, so you don't have to keep the original data alive if you don't want to. The on_seek method is called when the playing_offset= public method is called. Its purpose is to change the current playing position in the source data. The parameter is a time value representing the new position, from the beginning of the sound ( not from the current position). This method is sometimes impossible to implement. In those cases leave it empty, and tell the users of your class that changing the playing position is not supported. Now your class is almost ready to work. The only thing that SF::SoundStream needs to know now is the channel count and sample rate of your stream, so that it can be played as expected. # where this is done totally depends on how your stream class is designed MyAudioStream . new ( channel_count : ... , sample_rate : ... )","title":"SF::SoundStream"},{"location":"tutorials/audio/streams.html#threading-issues","text":"Audio streams are always played in a separate thread, therefore it is important to know what happens exactly, and where. on_seek is called directly by the playing_offset= function, so it is always executed in the caller thread. However, the on_get_data function will be called repeatedly as long as the stream is being played, in a separate thread created by SFML. If your stream uses data that may be accessed concurrently in both the caller thread and in the playing thread, you have to protect it (with a mutex for example) in order to avoid concurrent access, which may cause undefined behavior -- corrupt data being played, crashes, etc. If you're not familiar enough with threading, you can refer to the corresponding tutorial for more information.","title":"Threading issues"},{"location":"tutorials/audio/streams.html#using-your-audio-stream","text":"Now that you have defined your own audio stream class, let's see how to use it. In fact, things are very similar to what's shown in the tutorial about SF::Music . You can control playback with the play , pause , stop and playing_offset= methods. You can also play with the sound's properties, such as the volume or the pitch. You can refer to the API documentation or to the other audio tutorials for more details.","title":"Using your audio stream"},{"location":"tutorials/audio/streams.html#a-simple-example","text":"Here is a very simple example of a custom audio stream class which plays the data of a sound buffer. Such a class might seem totally useless, but the point here is to focus on how the data is streamed by the class, regardless of where it comes from. require \"crsfml/system\" require \"crsfml/audio\" # custom audio stream that plays a loaded buffer class MyStream < SF :: SoundStream @samples : Slice ( Int16 ) def initialize ( @buffer : SF :: SoundBuffer ) # get a slice that points to the buffer with samples @samples = buffer . samples . to_slice ( buffer . sample_count ) # reset the current playing position @current_sample = 0 # initialize the base class super ( buffer . channel_count , buffer . sample_rate ) end def on_get_data () # number of samples to stream every time the function is called; # in a more robust implementation, it should be a fixed # amount of time rather than an arbitrary number of samples to_stream = { 50000 , @samples . size - @current_sample } . min # if the end is close, set the number to play the remaining samples # if nothing left to play return nil unless to_stream > 0 # the next audio samples to be played result = ( @samples . to_unsafe + @current_sample ) . to_slice ( to_stream ) # advance the position @current_sample += to_stream result end def on_seek ( time_offset ) # compute the corresponding sample index according to the # sample rate and channel count @current_sample = ( time_offset . as_seconds * sample_rate * channel_count ) . to_i end end # load an audio buffer from a sound file buffer = SF :: SoundBuffer . from_file ( \"canary.wav\" ) # initialize and play our custom stream stream = MyStream . new ( buffer ) stream . play # let it play until it is finished while stream . status == SF :: SoundSource :: Playing SF . sleep ( SF . seconds ( 1 )) # jump back every so often stream . playing_offset -= SF . seconds ( 0.7 ) end","title":"A simple example"},{"location":"tutorials/graphics/draw.html","text":"Drawing 2D stuff # Introduction # As you learnt in the previous tutorials, CrSFML's window module provides an easy way to open an OpenGL window and handle its events, but it doesn't help when it comes to drawing something. The only option which is left to you is to use the powerful, yet complex and low level OpenGL API. Fortunately, CrSFML provides a graphics module which will help you draw 2D entities in a much simpler way than with OpenGL. The drawing window # To draw the entities provided by the graphics module, you must use a specialized window class: SF::RenderWindow . This class is derived from SF::Window , and inherits all its methods. Everything that you've learnt about SF::Window (creation, event handling, controlling the framerate, mixing with OpenGL, etc.) is applicable to SF::RenderWindow as well. On top of that, SF::RenderWindow adds high-level methods to help you draw things easily. In this tutorial we'll focus on two of these methods: clear and draw . They are as simple as their name implies: clear clears the whole window with the chosen color, and draw draws whatever object you pass to it. Here is what a typical main loop looks like with a render window: require \"crsfml\" # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) # run the program as long as the window is open while window . open? # check all the window's events that were triggered since the last iteration of the loop while event = window . poll_event # \"close requested\" event: we close the window if event . is_a? SF :: Event :: Closed window . close end end # clear the window with black color window . clear ( SF :: Color :: Black ) # draw everything here... window . draw ( ... ) # end the current frame window . display end Calling clear before drawing anything is mandatory, otherwise the contents from previous frames will be present behind anything you draw. The only exception is when you cover the entire window with what you draw, so that no pixel is not drawn to. In this case you can avoid calling clear (although it won't have a noticeable impact on performance). Calling display is also mandatory, it takes what was drawn since the last call to display and displays it on the window. Indeed, things are not drawn directly to the window, but to a hidden buffer. This buffer is then copied to the window when you call display \u2013 this is called double-buffering . This clear/draw/display cycle is the only good way to draw things. Don't try other strategies, such as keeping pixels from the previous frame, \"erasing\" pixels, or drawing once and calling display multiple times. You'll get strange results due to double-buffering. Modern graphics hardware and APIs are really made for repeated clear/draw/display cycles where everything is completely refreshed at each iteration of the main loop. Don't be scared to draw 1000 sprites 60 times per second, you're far below the millions of triangles that your computer can handle. What can I draw now? # Now that you have a main loop which is ready to draw, let's see what, and how, you can actually draw there. SFML provides four kinds of drawable entities: three of them are ready to be used ( sprites , text and shapes ), the last one is the building block that will help you create your own drawable entities ( vertex arrays ). Although they share some common properties, each of these entities come with their own nuances and are therefore explained in dedicated tutorials: Sprite tutorial Text tutorial Shape tutorial Vertex array tutorial Off-screen drawing # SFML also provides a way to draw to a texture instead of directly to a window. To do so, use a SF::RenderTexture instead of a SF::RenderWindow . It has the same methods for drawing, inherited from their common base: SF::RenderTarget . # create a 500x500 render-texture render_texture = SF :: RenderTexture . new ( 500 , 500 ) # drawing uses the same methods render_texture . clear ( SF :: Color :: Blue ) render_texture . draw ( sprite ) # or any other drawable render_texture . display # get the target texture (where the stuff has been drawn) texture = render_texture . texture # draw it to the window sprite = SF :: Sprite . new ( texture ) window . draw ( sprite ) The texture method returns a read-only texture, which means that you can only use it, not modify it. If you need to modify it before using it, you can copy it to your own SF::Texture instance and modify that instead. SF::RenderTexture also has the same methods as SF::RenderWindow for handling views and OpenGL (see the corresponding tutorials for more details). If you use OpenGL to draw to the render-texture, you can request creation of a depth buffer by using the third optional argument of the constructor. SF :: RenderTexture . new ( 500 , 500 , true ) # enable depth buffer Drawing from threads # CrSFML supports multi-threaded drawing, and you don't even have to do anything to make it work. The only thing to remember is to deactivate a window before using it in another thread. That's because a window (more precisely its OpenGL context) cannot be active in more than one thread at the same time. def render_thread ( window ) # the rendering loop while window . open? # draw... # end the current frame window . display end end # create the window (remember: it's safer to create it in the main thread due to OS limitations) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" ) # deactivate its OpenGL context window . active = false # launch the rendering thread thread = SF :: Thread . new ( -> { render_thread ( window ) }) thread . launch # the event/logic/whatever loop while window . open? ... end As you can see, you don't even need to bother with the activation of the window in the rendering thread, CrSFML does it automatically for you whenever it needs to be done. Remember to always create the window and handle its events in the main thread for maximum portability. This is explained in the window tutorial .","title":"Drawing 2D stuff"},{"location":"tutorials/graphics/draw.html#drawing-2d-stuff","text":"","title":"Drawing 2D stuff"},{"location":"tutorials/graphics/draw.html#introduction","text":"As you learnt in the previous tutorials, CrSFML's window module provides an easy way to open an OpenGL window and handle its events, but it doesn't help when it comes to drawing something. The only option which is left to you is to use the powerful, yet complex and low level OpenGL API. Fortunately, CrSFML provides a graphics module which will help you draw 2D entities in a much simpler way than with OpenGL.","title":"Introduction"},{"location":"tutorials/graphics/draw.html#the-drawing-window","text":"To draw the entities provided by the graphics module, you must use a specialized window class: SF::RenderWindow . This class is derived from SF::Window , and inherits all its methods. Everything that you've learnt about SF::Window (creation, event handling, controlling the framerate, mixing with OpenGL, etc.) is applicable to SF::RenderWindow as well. On top of that, SF::RenderWindow adds high-level methods to help you draw things easily. In this tutorial we'll focus on two of these methods: clear and draw . They are as simple as their name implies: clear clears the whole window with the chosen color, and draw draws whatever object you pass to it. Here is what a typical main loop looks like with a render window: require \"crsfml\" # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) # run the program as long as the window is open while window . open? # check all the window's events that were triggered since the last iteration of the loop while event = window . poll_event # \"close requested\" event: we close the window if event . is_a? SF :: Event :: Closed window . close end end # clear the window with black color window . clear ( SF :: Color :: Black ) # draw everything here... window . draw ( ... ) # end the current frame window . display end Calling clear before drawing anything is mandatory, otherwise the contents from previous frames will be present behind anything you draw. The only exception is when you cover the entire window with what you draw, so that no pixel is not drawn to. In this case you can avoid calling clear (although it won't have a noticeable impact on performance). Calling display is also mandatory, it takes what was drawn since the last call to display and displays it on the window. Indeed, things are not drawn directly to the window, but to a hidden buffer. This buffer is then copied to the window when you call display \u2013 this is called double-buffering . This clear/draw/display cycle is the only good way to draw things. Don't try other strategies, such as keeping pixels from the previous frame, \"erasing\" pixels, or drawing once and calling display multiple times. You'll get strange results due to double-buffering. Modern graphics hardware and APIs are really made for repeated clear/draw/display cycles where everything is completely refreshed at each iteration of the main loop. Don't be scared to draw 1000 sprites 60 times per second, you're far below the millions of triangles that your computer can handle.","title":"The drawing window"},{"location":"tutorials/graphics/draw.html#what-can-i-draw-now","text":"Now that you have a main loop which is ready to draw, let's see what, and how, you can actually draw there. SFML provides four kinds of drawable entities: three of them are ready to be used ( sprites , text and shapes ), the last one is the building block that will help you create your own drawable entities ( vertex arrays ). Although they share some common properties, each of these entities come with their own nuances and are therefore explained in dedicated tutorials: Sprite tutorial Text tutorial Shape tutorial Vertex array tutorial","title":"What can I draw now?"},{"location":"tutorials/graphics/draw.html#off-screen-drawing","text":"SFML also provides a way to draw to a texture instead of directly to a window. To do so, use a SF::RenderTexture instead of a SF::RenderWindow . It has the same methods for drawing, inherited from their common base: SF::RenderTarget . # create a 500x500 render-texture render_texture = SF :: RenderTexture . new ( 500 , 500 ) # drawing uses the same methods render_texture . clear ( SF :: Color :: Blue ) render_texture . draw ( sprite ) # or any other drawable render_texture . display # get the target texture (where the stuff has been drawn) texture = render_texture . texture # draw it to the window sprite = SF :: Sprite . new ( texture ) window . draw ( sprite ) The texture method returns a read-only texture, which means that you can only use it, not modify it. If you need to modify it before using it, you can copy it to your own SF::Texture instance and modify that instead. SF::RenderTexture also has the same methods as SF::RenderWindow for handling views and OpenGL (see the corresponding tutorials for more details). If you use OpenGL to draw to the render-texture, you can request creation of a depth buffer by using the third optional argument of the constructor. SF :: RenderTexture . new ( 500 , 500 , true ) # enable depth buffer","title":"Off-screen drawing"},{"location":"tutorials/graphics/draw.html#drawing-from-threads","text":"CrSFML supports multi-threaded drawing, and you don't even have to do anything to make it work. The only thing to remember is to deactivate a window before using it in another thread. That's because a window (more precisely its OpenGL context) cannot be active in more than one thread at the same time. def render_thread ( window ) # the rendering loop while window . open? # draw... # end the current frame window . display end end # create the window (remember: it's safer to create it in the main thread due to OS limitations) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" ) # deactivate its OpenGL context window . active = false # launch the rendering thread thread = SF :: Thread . new ( -> { render_thread ( window ) }) thread . launch # the event/logic/whatever loop while window . open? ... end As you can see, you don't even need to bother with the activation of the window in the rendering thread, CrSFML does it automatically for you whenever it needs to be done. Remember to always create the window and handle its events in the main thread for maximum portability. This is explained in the window tutorial .","title":"Drawing from threads"},{"location":"tutorials/graphics/shader.html","text":"Adding special effects with shaders # Relevant example: shader Introduction # A shader is a small program that is executed on the graphics card. It provides the programmer with more control over the drawing process and in a more flexible and simple way than using the fixed set of states and operations provided by OpenGL. With this additional flexibility, shaders are used to create effects that would be too complicated, if not impossible, to describe with regular OpenGL functions: Per-pixel lighting, shadows, etc. Today's graphics cards and newer versions of OpenGL are already entirely shader-based, and the fixed set of states and functions (which is called the \"fixed pipeline\") that you might know of has been deprecated and will likely be removed in the future. Shaders are written in GLSL ( OpenGL Shading Language ), which is very similar to the C programming language. There are two types of shaders: vertex shaders and fragment (or pixel) shaders. Vertex shaders are run for each vertex, while fragment shaders are run for every generated fragment (pixel). Depending on what kind of effect you want to achieve, you can provide a vertex shader, a fragment shader, or both. To understand what shaders do and how to use them efficiently, it is important to understand the basics of the rendering pipeline. You must also learn how to write GLSL programs and find good tutorials and examples to get started. You can also have a look at the \"Shader\" example that comes with the SFML SDK. This tutorial will only focus on the CrSFML specific part: Loading and applying your shaders -- not writing them. Loading shaders # In CrSFML, shaders are represented by the SF::Shader class. It handles both the vertex and fragment shaders: A SF::Shader object is a combination of both (or only one, if the other is not provided). Even though shaders have become commonplace, there are still old graphics cards that might not support them. The first thing you should do in your program is check if shaders are available on the system: if ! SF :: Shader . available? # shaders are not available... end Any attempt to use the SF::Shader class will fail if SF::Shader.available? returns false . The most common way of loading a shader is from a file on disk, which is done with the from_file class method. # load only the vertex shader shader = SF :: Shader . from_file ( \"vertex_shader.vert\" , SF :: Shader :: Vertex ) # load only the fragment shader shader = SF :: Shader . from_file ( \"fragment_shader.frag\" , SF :: Shader :: Fragment ) # load both shaders shader = SF :: Shader . from_file ( \"vertex_shader.vert\" , \"fragment_shader.frag\" ) Shader source is contained in simple text files (like your Crystal code). Their extension doesn't really matter, it can be anything you want, you can even omit it. \".vert\" and \".frag\" are just examples of possible extensions. The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is: When you run the application from your desktop environment, the working directory is the executable folder. Shaders can also be loaded directly from strings, with the from_memory class method. This can be useful if you want to embed the shader source directly into your program. vertex_shader = \" void main() { ... } \" fragment_shader = \" void main() { ... } \" # load only the vertex shader shader = SF :: Shader . from_memory ( vertex_shader , SF :: Shader :: Vertex ) # load only the fragment shader shader = SF :: Shader . from_memory ( fragment_shader , SF :: Shader :: Fragment ) # load both shaders shader = SF :: Shader . from_memory ( vertex_shader , fragment_shader ) And finally, like all other SFML resources, shaders can also be loaded from a custom input stream with the from_stream class method. If loading fails, don't forget to check the standard error output (the console) to see a detailed report from the GLSL compiler. Using a shader # Using a shader is simple, just pass it as an additional argument to the draw method. window . draw ( whatever , SF :: RenderStates . new ( shader : shader )) Passing variables to a shader # Like any other program, a shader can take parameters so that it is able to behave differently from one draw to another. These parameters are declared as global variables known as uniforms in the shader. uniform float myvar ; void main () { // use myvar... } Uniforms can be set by the Crystal program, using the various overloads of the set_parameter method in the SF::Shader class. shader . set_parameter ( \"my_var\" , 5.0 ) # shorthand: shader . my_var 5.0 set_parameter 's overloads support all the types provided by CrSFML: Float (GLSL type float ) 2 Float s or SF::Vector2f (GLSL type vec2 ) 3 Float s or SF::Vector3f (GLSL type vec3 ) 4 Float s (GLSL type vec4 ) SF::Color (GLSL type vec4 ) SF::Transform (GLSL type mat4 ) SF::Texture (GLSL type sampler2D ) The GLSL compiler optimizes out unused variables (here, \"unused\" means \"not involved in the calculation of the final vertex/pixel\"). So don't be surprised if you get error messages such as Failed to find variable \"xxx\" in shader when you call set_parameter during your tests. Minimal shaders # You won't learn how to write GLSL shaders here, but it is essential that you know what input SFML provides to the shaders and what it expects you to do with it. Vertex shader # SFML has a fixed vertex format which is described by the SF::Vertex structure. A SFML vertex contains a 2D position, a color, and 2D texture coordinates. This is the exact input that you will get in the vertex shader, stored in the built-in gl_Vertex , gl_Color and gl_MultiTexCoord0 variables (you don't need to declare them). void main () { // transform the vertex position gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex ; // transform the texture coordinates gl_TexCoord [ 0 ] = gl_TextureMatrix [ 0 ] * gl_MultiTexCoord0 ; // forward the vertex color gl_FrontColor = gl_Color ; } The position usually needs to be transformed by the model-view and projection matrices, which contain the entity transform combined with the current view. The texture coordinates need to be transformed by the texture matrix (this matrix likely doesn't mean anything to you, it is just an SFML implementation detail). And finally, the color just needs to be forwarded. Of course, you can ignore the texture coordinates and/or the color if you don't make use of them. All these variables will then be interpolated over the primitive by the graphics card, and passed to the fragment shader. Fragment shader # The fragment shader functions quite similarly: It receives the texture coordinates and the color of a generated fragment. There's no position any more, at this point the graphics card has already computed the final raster position of the fragment. However if you deal with textured entities, you'll also need the current texture. uniform sampler2D texture ; void main () { // lookup the pixel in the texture vec4 pixel = texture2D ( texture , gl_TexCoord [ 0 ]. xy ); // multiply it by the color gl_FragColor = gl_Color * pixel ; } The current texture is not automatic, you need to treat it like you do the other input variables, and explicitly set it from your C++ program. Since each entity can have a different texture, and worse, there might be no way for you to get it and pass it to the shader, SFML provides a special overload of the set_parameter method that does this job for you. shader.set_parameter \"texture\", SF::Shader::CurrentTexture This special parameter automatically sets the texture of the entity being drawn to the shader variable with the given name. Every time you draw a new entity, SFML will update the shader texture variable accordingly. If you want to see nice examples of shaders in action, you can have a look at the Shader example in the SFML SDK. Using a SF::Shader with OpenGL code # If you're using OpenGL rather than the graphics entities of SFML, you can still use SF::Shader as a wrapper around an OpenGL program object and use it within your OpenGL code. To activate a SF::Shader for drawing (the equivalent of glUseProgram ), you have to call the bind class method: shader = SF :: Shader . new ... # bind the shader SF :: Shader . bind ( shader ) # draw your OpenGL entity here... # bind no shader SF :: Shader . bind ( nil )","title":"Adding special effects with shaders"},{"location":"tutorials/graphics/shader.html#adding-special-effects-with-shaders","text":"Relevant example: shader","title":"Adding special effects with shaders"},{"location":"tutorials/graphics/shader.html#introduction","text":"A shader is a small program that is executed on the graphics card. It provides the programmer with more control over the drawing process and in a more flexible and simple way than using the fixed set of states and operations provided by OpenGL. With this additional flexibility, shaders are used to create effects that would be too complicated, if not impossible, to describe with regular OpenGL functions: Per-pixel lighting, shadows, etc. Today's graphics cards and newer versions of OpenGL are already entirely shader-based, and the fixed set of states and functions (which is called the \"fixed pipeline\") that you might know of has been deprecated and will likely be removed in the future. Shaders are written in GLSL ( OpenGL Shading Language ), which is very similar to the C programming language. There are two types of shaders: vertex shaders and fragment (or pixel) shaders. Vertex shaders are run for each vertex, while fragment shaders are run for every generated fragment (pixel). Depending on what kind of effect you want to achieve, you can provide a vertex shader, a fragment shader, or both. To understand what shaders do and how to use them efficiently, it is important to understand the basics of the rendering pipeline. You must also learn how to write GLSL programs and find good tutorials and examples to get started. You can also have a look at the \"Shader\" example that comes with the SFML SDK. This tutorial will only focus on the CrSFML specific part: Loading and applying your shaders -- not writing them.","title":"Introduction"},{"location":"tutorials/graphics/shader.html#loading-shaders","text":"In CrSFML, shaders are represented by the SF::Shader class. It handles both the vertex and fragment shaders: A SF::Shader object is a combination of both (or only one, if the other is not provided). Even though shaders have become commonplace, there are still old graphics cards that might not support them. The first thing you should do in your program is check if shaders are available on the system: if ! SF :: Shader . available? # shaders are not available... end Any attempt to use the SF::Shader class will fail if SF::Shader.available? returns false . The most common way of loading a shader is from a file on disk, which is done with the from_file class method. # load only the vertex shader shader = SF :: Shader . from_file ( \"vertex_shader.vert\" , SF :: Shader :: Vertex ) # load only the fragment shader shader = SF :: Shader . from_file ( \"fragment_shader.frag\" , SF :: Shader :: Fragment ) # load both shaders shader = SF :: Shader . from_file ( \"vertex_shader.vert\" , \"fragment_shader.frag\" ) Shader source is contained in simple text files (like your Crystal code). Their extension doesn't really matter, it can be anything you want, you can even omit it. \".vert\" and \".frag\" are just examples of possible extensions. The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is: When you run the application from your desktop environment, the working directory is the executable folder. Shaders can also be loaded directly from strings, with the from_memory class method. This can be useful if you want to embed the shader source directly into your program. vertex_shader = \" void main() { ... } \" fragment_shader = \" void main() { ... } \" # load only the vertex shader shader = SF :: Shader . from_memory ( vertex_shader , SF :: Shader :: Vertex ) # load only the fragment shader shader = SF :: Shader . from_memory ( fragment_shader , SF :: Shader :: Fragment ) # load both shaders shader = SF :: Shader . from_memory ( vertex_shader , fragment_shader ) And finally, like all other SFML resources, shaders can also be loaded from a custom input stream with the from_stream class method. If loading fails, don't forget to check the standard error output (the console) to see a detailed report from the GLSL compiler.","title":"Loading shaders"},{"location":"tutorials/graphics/shader.html#using-a-shader","text":"Using a shader is simple, just pass it as an additional argument to the draw method. window . draw ( whatever , SF :: RenderStates . new ( shader : shader ))","title":"Using a shader"},{"location":"tutorials/graphics/shader.html#passing-variables-to-a-shader","text":"Like any other program, a shader can take parameters so that it is able to behave differently from one draw to another. These parameters are declared as global variables known as uniforms in the shader. uniform float myvar ; void main () { // use myvar... } Uniforms can be set by the Crystal program, using the various overloads of the set_parameter method in the SF::Shader class. shader . set_parameter ( \"my_var\" , 5.0 ) # shorthand: shader . my_var 5.0 set_parameter 's overloads support all the types provided by CrSFML: Float (GLSL type float ) 2 Float s or SF::Vector2f (GLSL type vec2 ) 3 Float s or SF::Vector3f (GLSL type vec3 ) 4 Float s (GLSL type vec4 ) SF::Color (GLSL type vec4 ) SF::Transform (GLSL type mat4 ) SF::Texture (GLSL type sampler2D ) The GLSL compiler optimizes out unused variables (here, \"unused\" means \"not involved in the calculation of the final vertex/pixel\"). So don't be surprised if you get error messages such as Failed to find variable \"xxx\" in shader when you call set_parameter during your tests.","title":"Passing variables to a shader"},{"location":"tutorials/graphics/shader.html#minimal-shaders","text":"You won't learn how to write GLSL shaders here, but it is essential that you know what input SFML provides to the shaders and what it expects you to do with it.","title":"Minimal shaders"},{"location":"tutorials/graphics/shader.html#vertex-shader","text":"SFML has a fixed vertex format which is described by the SF::Vertex structure. A SFML vertex contains a 2D position, a color, and 2D texture coordinates. This is the exact input that you will get in the vertex shader, stored in the built-in gl_Vertex , gl_Color and gl_MultiTexCoord0 variables (you don't need to declare them). void main () { // transform the vertex position gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex ; // transform the texture coordinates gl_TexCoord [ 0 ] = gl_TextureMatrix [ 0 ] * gl_MultiTexCoord0 ; // forward the vertex color gl_FrontColor = gl_Color ; } The position usually needs to be transformed by the model-view and projection matrices, which contain the entity transform combined with the current view. The texture coordinates need to be transformed by the texture matrix (this matrix likely doesn't mean anything to you, it is just an SFML implementation detail). And finally, the color just needs to be forwarded. Of course, you can ignore the texture coordinates and/or the color if you don't make use of them. All these variables will then be interpolated over the primitive by the graphics card, and passed to the fragment shader.","title":"Vertex shader"},{"location":"tutorials/graphics/shader.html#fragment-shader","text":"The fragment shader functions quite similarly: It receives the texture coordinates and the color of a generated fragment. There's no position any more, at this point the graphics card has already computed the final raster position of the fragment. However if you deal with textured entities, you'll also need the current texture. uniform sampler2D texture ; void main () { // lookup the pixel in the texture vec4 pixel = texture2D ( texture , gl_TexCoord [ 0 ]. xy ); // multiply it by the color gl_FragColor = gl_Color * pixel ; } The current texture is not automatic, you need to treat it like you do the other input variables, and explicitly set it from your C++ program. Since each entity can have a different texture, and worse, there might be no way for you to get it and pass it to the shader, SFML provides a special overload of the set_parameter method that does this job for you. shader.set_parameter \"texture\", SF::Shader::CurrentTexture This special parameter automatically sets the texture of the entity being drawn to the shader variable with the given name. Every time you draw a new entity, SFML will update the shader texture variable accordingly. If you want to see nice examples of shaders in action, you can have a look at the Shader example in the SFML SDK.","title":"Fragment shader"},{"location":"tutorials/graphics/shader.html#using-a-sfshader-with-opengl-code","text":"If you're using OpenGL rather than the graphics entities of SFML, you can still use SF::Shader as a wrapper around an OpenGL program object and use it within your OpenGL code. To activate a SF::Shader for drawing (the equivalent of glUseProgram ), you have to call the bind class method: shader = SF :: Shader . new ... # bind the shader SF :: Shader . bind ( shader ) # draw your OpenGL entity here... # bind no shader SF :: Shader . bind ( nil )","title":"Using a SF::Shader with OpenGL code"},{"location":"tutorials/graphics/shape.html","text":"Shapes # Introduction # CrSFML provides a set of classes that represent simple shape entities. Each type of shape is a separate class, but they all derive from the same base class so that they have access to the same subset of common features. Each class then adds its own specifics: a radius property for the circle class, a size for the rectangle class, points for the polygon class, etc. Common shape properties # Transformation (position, rotation, scale) # These properties are common to all the CrSFML graphical classes, so they are explained in a separate tutorial: Transforming entities . Color # One of the basic properties of a shape is its color. You can change with the fill_color= method. shape = SF :: CircleShape . new ( 50 ) # set the shape color to green shape . fill_color = SF . color ( 100 , 250 , 50 ) Outline # Shapes can have an outline. You can set the thickness and color of the outline with the outline_thickness= and outline_color= methods. shape = SF :: CircleShape . new ( 50 ) shape . fill_color = SF . color ( 150 , 50 , 250 ) # set a 10-pixel wide orange outline shape . outline_thickness = 10 shape . outline_color = SF . color ( 250 , 150 , 100 ) By default, the outline is extruded outwards from the shape (e.g. if you have a circle with a radius of 10 and an outline thickness of 5, the total radius of the circle will be 15). You can make it extrude towards the center of the shape instead, by setting a negative thickness. To disable the outline, set its thickness to 0. If you only want the outline, you can set the fill color to SF::Color::Transparent . Texture # Shapes can also be textured, just like sprites. To specify a part of the texture to be mapped to the shape, you must use the texture_rect= method. It takes the texture rectangle to map to the bounding rectangle of the shape. This method doesn't offer maximum flexibility, but it is much easier to use than individually setting the texture coordinates of each point of the shape. shape = SF :: CircleShape . new ( 50 ) # map a 100x100 textured rectangle to the shape shape . set_texture ( texture , reset_rect : false ) # texture is a SF::Texture shape . texture_rect = SF . int_rect ( 10 , 10 , 100 , 100 ) Note that the outline is not textured. It is important to know that the texture is modulated (multiplied) with the shape's fill color. If its fill color is SF::Color::White , the texture will appear unmodified. To disable texturing, call set_texture(nil, false) . Drawing a shape # Drawing a shape is as simple as drawing any other SFML entity: window . draw ( shape ) Built-in shape types # Rectangles # To draw rectangles, you can use the SF::RectangleShape class. It has a single attribute: The size of the rectangle. # define a 120x50 rectangle rectangle = SF :: RectangleShape . new ( SF . vector2 ( 120 , 50 )) # change the size to 100x100 rectangle . size = SF . vector2 ( 100 , 100 ) Circles # Relevant example: snakes Circles are represented by the SF::CircleShape class. It has two attributes: The radius and the number of sides. The number of sides is an optional attribute, it allows you to adjust the \"quality\" of the circle: Circles have to be approximated by polygons with many sides (the graphics card is unable to draw a perfect circle directly), and this attribute defines how many sides your circle approximation will have. If you draw small circles, you'll probably only need a few sides. If you draw big circles, or zoom on regular circles, you'll most likely need more sides. # define a circle with radius = 200 circle = SF :: CircleShape . new ( 200 ) # change the radius to 40 circle . radius = 40 # change the number of sides (points) to 100 circle . point_count = 100 Regular polygons # There's no dedicated class for regular polygons, in fact you can represent a regular polygon with any number of sides using the SF::CircleShape class: Since circles are approximated by polygons with many sides, you just have to play with the number of sides to get the desired polygons. A SF::CircleShape with 3 points is a triangle, with 4 points it's a square, etc. # define a triangle triangle = SF :: CircleShape . new ( 80 , 3 ) # define a square square = SF :: CircleShape . new ( 80 , 4 ) # define an octagon octagon = SF :: CircleShape . new ( 80 , 8 ) Convex shapes # Relevant example: rounded_rectangle The SF::ConvexShape class is the ultimate shape class: It allows you to define any convex shape. SFML is unable to draw concave shapes. If you need to draw a concave shape, you'll have to split it into multiple convex polygons. To construct a convex shape, you must first set the number of points it should have and then define the points. # create an empty shape convex = SF :: ConvexShape . new # resize it to 5 points convex . point_count = 5 # define the points convex [ 0 ] = SF . vector2 ( 0 , 0 ) convex [ 1 ] = SF . vector2 ( 150 , 10 ) convex [ 2 ] = SF . vector2 ( 120 , 90 ) convex [ 3 ] = SF . vector2 ( 30 , 100 ) convex [ 4 ] = SF . vector2 ( 0 , 50 ) The order in which you define the points is very important. They must all be defined either in clockwise or counter-clockwise order. If you define them in an inconsistent order, the shape will be constructed incorrectly. Although the name of SF::ConvexShape implies that it should only be used to represent convex shapes, its requirements are a little more relaxed. In fact, the only requirement that your shape must meet is that if you went ahead and drew lines from its center of gravity to all of its points, these lines must be drawn in the same order. You are not allowed to \"jump behind a previous line\". Internally, convex shapes are automatically constructed using triangle fans , so if your shape is representable by a triangle fan, you can use SF::ConvexShape . With this relaxed definition, you can draw stars using SF::ConvexShape for example. Lines # There's no shape class for lines. The reason is simple: If your line has a thickness, it is a rectangle. If it doesn't, it can be drawn with a line primitive. Line with thickness: line = SF :: RectangleShape . new ( SF . vector2 ( 150 , 5 )) line . rotate ( 45 ) Line without thickness: line = [ SF :: Vertex . new ( SF . vector2 ( 10 , 10 )), SF :: Vertex . new ( SF . vector2 ( 150 , 150 )) ] window . draw ( line , SF :: Lines ) To learn more about vertices and primitives, you can read the tutorial on vertex arrays . Custom shape types # Relevant example: shapes You can extend the set of shape classes with your own shape types. To do so, you must derive from SF::Shape and override two methods: point_count : return the number of points in the shape get_point : return a point of the shape You must also call the update() method whenever any point in your shape changes, so that the base class is informed and can update its internal geometry. Here is a complete example of a custom shape class: EllipseShape . class EllipseShape < SF :: Shape def initialize ( @radius : SF :: Vector2f ) super () update () end def radius @radius end def radius = ( radius : SF :: Vector2f ) @radius = radius update end def point_count 40 # fixed, but could be an attribute of the class if needed end def get_point ( index ) angle = index * 2 * Math :: PI / point_count # origin is {0, 0}, center is @radius @radius + @radius * { Math . cos ( angle ), Math . sin ( angle )} end end Antialiased shapes # Relevant example: snakes There's no option to anti-alias a single shape. To get anti-aliased shapes (i.e. shapes with smoothed edges), you have to enable anti-aliasing globally when you create the window, with the corresponding attribute of the structure. window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML shapes\" , settings : SF :: ContextSettings . new ( depth : 24 , antialiasing : 8 ) ) Remember that anti-aliasing availability depends on the graphics card: It might not support it, or have it forced to disabled in the driver settings. Sometimes antialiasing does not work if depth_bits is not specified (use 24 if unsure).","title":"Shapes"},{"location":"tutorials/graphics/shape.html#shapes","text":"","title":"Shapes"},{"location":"tutorials/graphics/shape.html#introduction","text":"CrSFML provides a set of classes that represent simple shape entities. Each type of shape is a separate class, but they all derive from the same base class so that they have access to the same subset of common features. Each class then adds its own specifics: a radius property for the circle class, a size for the rectangle class, points for the polygon class, etc.","title":"Introduction"},{"location":"tutorials/graphics/shape.html#common-shape-properties","text":"","title":"Common shape properties"},{"location":"tutorials/graphics/shape.html#transformation-position-rotation-scale","text":"These properties are common to all the CrSFML graphical classes, so they are explained in a separate tutorial: Transforming entities .","title":"Transformation (position, rotation, scale)"},{"location":"tutorials/graphics/shape.html#color","text":"One of the basic properties of a shape is its color. You can change with the fill_color= method. shape = SF :: CircleShape . new ( 50 ) # set the shape color to green shape . fill_color = SF . color ( 100 , 250 , 50 )","title":"Color"},{"location":"tutorials/graphics/shape.html#outline","text":"Shapes can have an outline. You can set the thickness and color of the outline with the outline_thickness= and outline_color= methods. shape = SF :: CircleShape . new ( 50 ) shape . fill_color = SF . color ( 150 , 50 , 250 ) # set a 10-pixel wide orange outline shape . outline_thickness = 10 shape . outline_color = SF . color ( 250 , 150 , 100 ) By default, the outline is extruded outwards from the shape (e.g. if you have a circle with a radius of 10 and an outline thickness of 5, the total radius of the circle will be 15). You can make it extrude towards the center of the shape instead, by setting a negative thickness. To disable the outline, set its thickness to 0. If you only want the outline, you can set the fill color to SF::Color::Transparent .","title":"Outline"},{"location":"tutorials/graphics/shape.html#texture","text":"Shapes can also be textured, just like sprites. To specify a part of the texture to be mapped to the shape, you must use the texture_rect= method. It takes the texture rectangle to map to the bounding rectangle of the shape. This method doesn't offer maximum flexibility, but it is much easier to use than individually setting the texture coordinates of each point of the shape. shape = SF :: CircleShape . new ( 50 ) # map a 100x100 textured rectangle to the shape shape . set_texture ( texture , reset_rect : false ) # texture is a SF::Texture shape . texture_rect = SF . int_rect ( 10 , 10 , 100 , 100 ) Note that the outline is not textured. It is important to know that the texture is modulated (multiplied) with the shape's fill color. If its fill color is SF::Color::White , the texture will appear unmodified. To disable texturing, call set_texture(nil, false) .","title":"Texture"},{"location":"tutorials/graphics/shape.html#drawing-a-shape","text":"Drawing a shape is as simple as drawing any other SFML entity: window . draw ( shape )","title":"Drawing a shape"},{"location":"tutorials/graphics/shape.html#built-in-shape-types","text":"","title":"Built-in shape types"},{"location":"tutorials/graphics/shape.html#rectangles","text":"To draw rectangles, you can use the SF::RectangleShape class. It has a single attribute: The size of the rectangle. # define a 120x50 rectangle rectangle = SF :: RectangleShape . new ( SF . vector2 ( 120 , 50 )) # change the size to 100x100 rectangle . size = SF . vector2 ( 100 , 100 )","title":"Rectangles"},{"location":"tutorials/graphics/shape.html#circles","text":"Relevant example: snakes Circles are represented by the SF::CircleShape class. It has two attributes: The radius and the number of sides. The number of sides is an optional attribute, it allows you to adjust the \"quality\" of the circle: Circles have to be approximated by polygons with many sides (the graphics card is unable to draw a perfect circle directly), and this attribute defines how many sides your circle approximation will have. If you draw small circles, you'll probably only need a few sides. If you draw big circles, or zoom on regular circles, you'll most likely need more sides. # define a circle with radius = 200 circle = SF :: CircleShape . new ( 200 ) # change the radius to 40 circle . radius = 40 # change the number of sides (points) to 100 circle . point_count = 100","title":"Circles"},{"location":"tutorials/graphics/shape.html#regular-polygons","text":"There's no dedicated class for regular polygons, in fact you can represent a regular polygon with any number of sides using the SF::CircleShape class: Since circles are approximated by polygons with many sides, you just have to play with the number of sides to get the desired polygons. A SF::CircleShape with 3 points is a triangle, with 4 points it's a square, etc. # define a triangle triangle = SF :: CircleShape . new ( 80 , 3 ) # define a square square = SF :: CircleShape . new ( 80 , 4 ) # define an octagon octagon = SF :: CircleShape . new ( 80 , 8 )","title":"Regular polygons"},{"location":"tutorials/graphics/shape.html#convex-shapes","text":"Relevant example: rounded_rectangle The SF::ConvexShape class is the ultimate shape class: It allows you to define any convex shape. SFML is unable to draw concave shapes. If you need to draw a concave shape, you'll have to split it into multiple convex polygons. To construct a convex shape, you must first set the number of points it should have and then define the points. # create an empty shape convex = SF :: ConvexShape . new # resize it to 5 points convex . point_count = 5 # define the points convex [ 0 ] = SF . vector2 ( 0 , 0 ) convex [ 1 ] = SF . vector2 ( 150 , 10 ) convex [ 2 ] = SF . vector2 ( 120 , 90 ) convex [ 3 ] = SF . vector2 ( 30 , 100 ) convex [ 4 ] = SF . vector2 ( 0 , 50 ) The order in which you define the points is very important. They must all be defined either in clockwise or counter-clockwise order. If you define them in an inconsistent order, the shape will be constructed incorrectly. Although the name of SF::ConvexShape implies that it should only be used to represent convex shapes, its requirements are a little more relaxed. In fact, the only requirement that your shape must meet is that if you went ahead and drew lines from its center of gravity to all of its points, these lines must be drawn in the same order. You are not allowed to \"jump behind a previous line\". Internally, convex shapes are automatically constructed using triangle fans , so if your shape is representable by a triangle fan, you can use SF::ConvexShape . With this relaxed definition, you can draw stars using SF::ConvexShape for example.","title":"Convex shapes"},{"location":"tutorials/graphics/shape.html#lines","text":"There's no shape class for lines. The reason is simple: If your line has a thickness, it is a rectangle. If it doesn't, it can be drawn with a line primitive. Line with thickness: line = SF :: RectangleShape . new ( SF . vector2 ( 150 , 5 )) line . rotate ( 45 ) Line without thickness: line = [ SF :: Vertex . new ( SF . vector2 ( 10 , 10 )), SF :: Vertex . new ( SF . vector2 ( 150 , 150 )) ] window . draw ( line , SF :: Lines ) To learn more about vertices and primitives, you can read the tutorial on vertex arrays .","title":"Lines"},{"location":"tutorials/graphics/shape.html#custom-shape-types","text":"Relevant example: shapes You can extend the set of shape classes with your own shape types. To do so, you must derive from SF::Shape and override two methods: point_count : return the number of points in the shape get_point : return a point of the shape You must also call the update() method whenever any point in your shape changes, so that the base class is informed and can update its internal geometry. Here is a complete example of a custom shape class: EllipseShape . class EllipseShape < SF :: Shape def initialize ( @radius : SF :: Vector2f ) super () update () end def radius @radius end def radius = ( radius : SF :: Vector2f ) @radius = radius update end def point_count 40 # fixed, but could be an attribute of the class if needed end def get_point ( index ) angle = index * 2 * Math :: PI / point_count # origin is {0, 0}, center is @radius @radius + @radius * { Math . cos ( angle ), Math . sin ( angle )} end end","title":"Custom shape types"},{"location":"tutorials/graphics/shape.html#antialiased-shapes","text":"Relevant example: snakes There's no option to anti-alias a single shape. To get anti-aliased shapes (i.e. shapes with smoothed edges), you have to enable anti-aliasing globally when you create the window, with the corresponding attribute of the structure. window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML shapes\" , settings : SF :: ContextSettings . new ( depth : 24 , antialiasing : 8 ) ) Remember that anti-aliasing availability depends on the graphics card: It might not support it, or have it forced to disabled in the driver settings. Sometimes antialiasing does not work if depth_bits is not specified (use 24 if unsure).","title":"Antialiased shapes"},{"location":"tutorials/graphics/sprite.html","text":"Sprites and textures # Relevant example: flippy_bird Vocabulary # Most (if not all) of you are already familiar with these two very common objects, so let's define them very briefly. A texture is an image. But we call it \"texture\" because it has a very specific role: being mapped to a 2D entity. A sprite is nothing more than a textured rectangle. Ok, that was short but if you really don't understand what sprites and textures are, then you'll find a much better description on Wikipedia. Loading a texture # Before creating any sprite, we need a valid texture. The class that encapsulates textures in CrSFML is, unsurprisingly, SF::Texture . Since the only role of a texture is to be loaded and mapped to graphical entities, almost all its methods are about loading and updating it. The most common way of loading a texture is from an image file on disk, which is done with the from_file class method. texture = SF :: Texture . from_file ( \"image.png\" ) The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is. You can also load an image file from memory ( from_memory ), from a custom input stream ( from_stream ), or from an image that has already been loaded ( from_image ). The latter loads the texture from an SF::Image , which is a utility class that helps store and manipulate image data (modify pixels, create transparency channel, etc.). The pixels of an SF::Image stay in system memory, which ensures that operations on them will be as fast as possible, in contrast to the pixels of a texture which reside in video memory and are therefore slow to retrieve or update but very fast to draw. SFML supports most common image file formats. The full list is available in the API documentation. All these loading class methods have an optional argument, which can be used if you want to load a smaller part of the image. # load a 32x32 rectangle that starts at (10, 10) texture = SF :: Texture . from_file ( \"image.png\" , SF . int_rect ( 10 , 10 , 32 , 32 )) The SF::IntRect class is a simple utility type that represents a rectangle. Its constructor takes the coordinates of the top-left corner, and the size of the rectangle. If you don't want to load a texture from an image, but instead want to update it directly from an array of pixels, you can create it empty and update it later: # create an empty 200x200 texture texture = SF :: Texture . new ( 200 , 200 ) Note that the contents of the texture are undefined at this point. To update the pixels of an existing texture, you have to use the update method. It has overloads for many kinds of data sources: # update a texture from an array of pixels texture . update ( pixels ) # update a texture from a SF::Image texture . update ( image ) # update the texture from the current contents of the window texture . update ( window ) These examples all assume that the source is of the same size as the texture. If this is not the case, i.e. if you want to update only a part of the texture, you can specify the coordinates of the sub-rectangle that you want to update. You can refer to the documentation for further details. Additionally, a texture has two properties that change how it is rendered. The first property allows one to smooth the texture. Smoothing a texture makes pixel boundaries less visible (but the image a little more blurry), which can be desirable if it is up-scaled. texture . smooth = true Since smoothing samples from adjacent pixels in the texture as well, it can lead to the unwanted side effect of factoring in pixels outside the selected texture area. This can happen when your sprite is located at non-integer coordinates. The second property allows a texture to be repeatedly tiled within a single sprite. texture . repeated = true This only works if your sprite is configured to show a rectangle which is larger than the texture, otherwise this property has no effect. Ok, can I have my sprite now? # Yes, you can now create your sprite. sprite = SF :: Sprite . new ( texture ) ... and finally draw it. # inside the main loop, between window.clear() and window.display() window . draw ( sprite ) If you don't want your sprite to use the entire texture, you can set its texture rectangle. sprite . texture_rect = SF . int_rect ( 10 , 10 , 32 , 32 ) You can also change the color of a sprite. The color that you set is modulated (multiplied) with the texture of the sprite. This can also be used to change the global transparency (alpha) of the sprite. sprite . color = SF . color ( 0 , 255 , 0 ) # green sprite . color = SF . color ( 255 , 255 , 255 , 128 ) # half transparent These sprites all use the same texture, but have a different color: Sprites can also be transformed: They have a position, an orientation and a scale. # position sprite . position = SF . vector2 ( 10 , 50 ) # absolute position sprite . move ( SF . vector2 ( 5 , 10 )) # offset relative to the current position # rotation sprite . rotation = 90 # absolute angle sprite . rotate ( 15 ) # offset relative to the current angle # scale sprite . scale = SF . vector2 ( 0.5 , 2.0 ) # absolute scale factor sprite . scale ( SF . vector2 ( 1.5 , 3.0 )) # factor relative to the current scale By default, the origin for these three transformations is the top-left corner of the sprite. If you want to set the origin to a different point (for example the center of the sprite, or another corner), you can use the origin= method. sprite . origin = SF . vector2 ( 25 , 25 ) Since transformation methods are common to all CrSFML entities, they are explained in a separate tutorial: Transforming entities . The importance of using as few textures as possible # Using as few textures as possible is a good strategy, and the reason is simple: Changing the current texture is an expensive operation for the graphics card. Drawing many sprites that use the same texture will yield the best performance. Additionally, using a single texture allows you to group static geometry into a single entity (you can only use one texture per draw call), which will be much faster to draw than a set of many entities. Batching static geometry involves other classes and is therefore beyond the scope of this tutorial, for further details see the vertex array tutorial. Try to keep this in mind when you create your animation sheets or your tilesets: Use as few textures as possible. Using SF::Texture with OpenGL code # If you're using OpenGL rather than the graphics entities of CrSFML, you can still use SF::Texture as a wrapper around an OpenGL texture object and use it along with the rest of your OpenGL code. To bind a SF::Texture for drawing (basically glBindTexture ), you call the bind class method: texture = ... # bind the texture SF :: Texture . bind texture # draw your textured OpenGL entity here... # bind no texture SF :: Texture . bind nil","title":"Sprites and textures"},{"location":"tutorials/graphics/sprite.html#sprites-and-textures","text":"Relevant example: flippy_bird","title":"Sprites and textures"},{"location":"tutorials/graphics/sprite.html#vocabulary","text":"Most (if not all) of you are already familiar with these two very common objects, so let's define them very briefly. A texture is an image. But we call it \"texture\" because it has a very specific role: being mapped to a 2D entity. A sprite is nothing more than a textured rectangle. Ok, that was short but if you really don't understand what sprites and textures are, then you'll find a much better description on Wikipedia.","title":"Vocabulary"},{"location":"tutorials/graphics/sprite.html#loading-a-texture","text":"Before creating any sprite, we need a valid texture. The class that encapsulates textures in CrSFML is, unsurprisingly, SF::Texture . Since the only role of a texture is to be loaded and mapped to graphical entities, almost all its methods are about loading and updating it. The most common way of loading a texture is from an image file on disk, which is done with the from_file class method. texture = SF :: Texture . from_file ( \"image.png\" ) The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is. You can also load an image file from memory ( from_memory ), from a custom input stream ( from_stream ), or from an image that has already been loaded ( from_image ). The latter loads the texture from an SF::Image , which is a utility class that helps store and manipulate image data (modify pixels, create transparency channel, etc.). The pixels of an SF::Image stay in system memory, which ensures that operations on them will be as fast as possible, in contrast to the pixels of a texture which reside in video memory and are therefore slow to retrieve or update but very fast to draw. SFML supports most common image file formats. The full list is available in the API documentation. All these loading class methods have an optional argument, which can be used if you want to load a smaller part of the image. # load a 32x32 rectangle that starts at (10, 10) texture = SF :: Texture . from_file ( \"image.png\" , SF . int_rect ( 10 , 10 , 32 , 32 )) The SF::IntRect class is a simple utility type that represents a rectangle. Its constructor takes the coordinates of the top-left corner, and the size of the rectangle. If you don't want to load a texture from an image, but instead want to update it directly from an array of pixels, you can create it empty and update it later: # create an empty 200x200 texture texture = SF :: Texture . new ( 200 , 200 ) Note that the contents of the texture are undefined at this point. To update the pixels of an existing texture, you have to use the update method. It has overloads for many kinds of data sources: # update a texture from an array of pixels texture . update ( pixels ) # update a texture from a SF::Image texture . update ( image ) # update the texture from the current contents of the window texture . update ( window ) These examples all assume that the source is of the same size as the texture. If this is not the case, i.e. if you want to update only a part of the texture, you can specify the coordinates of the sub-rectangle that you want to update. You can refer to the documentation for further details. Additionally, a texture has two properties that change how it is rendered. The first property allows one to smooth the texture. Smoothing a texture makes pixel boundaries less visible (but the image a little more blurry), which can be desirable if it is up-scaled. texture . smooth = true Since smoothing samples from adjacent pixels in the texture as well, it can lead to the unwanted side effect of factoring in pixels outside the selected texture area. This can happen when your sprite is located at non-integer coordinates. The second property allows a texture to be repeatedly tiled within a single sprite. texture . repeated = true This only works if your sprite is configured to show a rectangle which is larger than the texture, otherwise this property has no effect.","title":"Loading a texture"},{"location":"tutorials/graphics/sprite.html#ok-can-i-have-my-sprite-now","text":"Yes, you can now create your sprite. sprite = SF :: Sprite . new ( texture ) ... and finally draw it. # inside the main loop, between window.clear() and window.display() window . draw ( sprite ) If you don't want your sprite to use the entire texture, you can set its texture rectangle. sprite . texture_rect = SF . int_rect ( 10 , 10 , 32 , 32 ) You can also change the color of a sprite. The color that you set is modulated (multiplied) with the texture of the sprite. This can also be used to change the global transparency (alpha) of the sprite. sprite . color = SF . color ( 0 , 255 , 0 ) # green sprite . color = SF . color ( 255 , 255 , 255 , 128 ) # half transparent These sprites all use the same texture, but have a different color: Sprites can also be transformed: They have a position, an orientation and a scale. # position sprite . position = SF . vector2 ( 10 , 50 ) # absolute position sprite . move ( SF . vector2 ( 5 , 10 )) # offset relative to the current position # rotation sprite . rotation = 90 # absolute angle sprite . rotate ( 15 ) # offset relative to the current angle # scale sprite . scale = SF . vector2 ( 0.5 , 2.0 ) # absolute scale factor sprite . scale ( SF . vector2 ( 1.5 , 3.0 )) # factor relative to the current scale By default, the origin for these three transformations is the top-left corner of the sprite. If you want to set the origin to a different point (for example the center of the sprite, or another corner), you can use the origin= method. sprite . origin = SF . vector2 ( 25 , 25 ) Since transformation methods are common to all CrSFML entities, they are explained in a separate tutorial: Transforming entities .","title":"Ok, can I have my sprite now?"},{"location":"tutorials/graphics/sprite.html#the-importance-of-using-as-few-textures-as-possible","text":"Using as few textures as possible is a good strategy, and the reason is simple: Changing the current texture is an expensive operation for the graphics card. Drawing many sprites that use the same texture will yield the best performance. Additionally, using a single texture allows you to group static geometry into a single entity (you can only use one texture per draw call), which will be much faster to draw than a set of many entities. Batching static geometry involves other classes and is therefore beyond the scope of this tutorial, for further details see the vertex array tutorial. Try to keep this in mind when you create your animation sheets or your tilesets: Use as few textures as possible.","title":"The importance of using as few textures as possible"},{"location":"tutorials/graphics/sprite.html#using-sftexture-with-opengl-code","text":"If you're using OpenGL rather than the graphics entities of CrSFML, you can still use SF::Texture as a wrapper around an OpenGL texture object and use it along with the rest of your OpenGL code. To bind a SF::Texture for drawing (basically glBindTexture ), you call the bind class method: texture = ... # bind the texture SF :: Texture . bind texture # draw your textured OpenGL entity here... # bind no texture SF :: Texture . bind nil","title":"Using SF::Texture with OpenGL code"},{"location":"tutorials/graphics/text.html","text":"Text and fonts # Relevant example: typing Loading a font # Before drawing any text, you need to have an available font, just like any other program that prints text. Fonts are encapsulated in the SF::Font class, which provides three main features: loading a font, getting glyphs (i.e. visual characters) from it, and reading its attributes. In a typical program, you'll only have to make use of the first feature, loading the font, so let's focus on that first. The most common way of loading a font is from a file on disk, which is done with the from_file class method. font = SF :: Font . from_file ( \"DejaVuSans.ttf\" ) Note that SFML won't load your system fonts automatically, i.e. SF::Font.from_file(\"Courier New\") won't work. Firstly, because SFML requires file names , not font names, and secondly because SFML doesn't have magical access to your system's font folder. If you want to load a font, you will need to include the font file with your application, just like every other resource (images, sounds, ...). The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is: When you run the application from your desktop environment, the working directory is the executable folder. However, when you launch your program from your IDE (Visual Studio, Code::Blocks, ...) the working directory might sometimes be set to the project directory instead. This can usually be changed quite easily in the project settings. You can also load a font file from memory ( from_memory ), or from a custom input stream ( from_stream ). SFML supports most common font formats. The full list is available in the API documentation. That's all you need to do. Once your font is loaded, you can start drawing text. Drawing text # To draw text, you will be using the SF::Text class. It's very simple to use: text = SF :: Text . new # select the font text . font = font # font is a SF::Font # set the string to display text . string = \"Hello world\" # set the character size text . character_size = 24 # in pixels, not points! # set the color text . color = SF :: Color :: Red # set the text style text . style = ( SF :: Text :: Bold | SF :: Text :: Underlined ) ... # inside the main loop, between window.clear() and window.display() window . draw ( text ) Text can also be transformed: They have a position, an orientation and a scale. The methods involved are the same as for the SF::Sprite class and other CrSFML entities. They are explained in the Transforming entities tutorial. Making your own text class # If SF::Text is too limited, or if you want to do something else with pre-rendered glyphs, SF::Font provides everything that you need. You can retrieve the texture which contains all the pre-rendered glyphs of a certain size: texture = font . get_texture ( character_size ) It is important to note that glyphs are added to the texture when they are requested. There are so many characters (remember, more than 100000) that they can't all be generated when you load the font. Instead, they are rendered on the fly when you call the get_glyph method (see below). To do something meaningful with the font texture, you must get the texture coordinates of glyphs that are contained in it: glyph = font . get_glyph ( character , character_size , bold ) character is the character, the glyph of which you want to get. You must also specify the character size, and whether you want the bold or the regular version of the glyph. The SF::Glyph structure contains three members: texture_rect contains the texture coordinates of the glyph within the texture bounds contains the bounding rectangle of the glyph, which helps position it relative to the baseline of the text advance is the horizontal offset to apply to get the starting position of the next glyph in the text You can also get some of the font's other metrics, such as the kerning between two characters or the line spacing (always for a certain character size): line_spacing = font . get_line_spacing ( character_size ) kerning = font . get_kerning ( character_1 , character_2 , character_size )","title":"Text and fonts"},{"location":"tutorials/graphics/text.html#text-and-fonts","text":"Relevant example: typing","title":"Text and fonts"},{"location":"tutorials/graphics/text.html#loading-a-font","text":"Before drawing any text, you need to have an available font, just like any other program that prints text. Fonts are encapsulated in the SF::Font class, which provides three main features: loading a font, getting glyphs (i.e. visual characters) from it, and reading its attributes. In a typical program, you'll only have to make use of the first feature, loading the font, so let's focus on that first. The most common way of loading a font is from a file on disk, which is done with the from_file class method. font = SF :: Font . from_file ( \"DejaVuSans.ttf\" ) Note that SFML won't load your system fonts automatically, i.e. SF::Font.from_file(\"Courier New\") won't work. Firstly, because SFML requires file names , not font names, and secondly because SFML doesn't have magical access to your system's font folder. If you want to load a font, you will need to include the font file with your application, just like every other resource (images, sounds, ...). The from_file class method can sometimes fail with no obvious reason. First, check the error message that SFML prints to the standard output (check the console). If the message is unable to open file, make sure that the working directory (which is the directory that any file path will be interpreted relative to) is what you think it is: When you run the application from your desktop environment, the working directory is the executable folder. However, when you launch your program from your IDE (Visual Studio, Code::Blocks, ...) the working directory might sometimes be set to the project directory instead. This can usually be changed quite easily in the project settings. You can also load a font file from memory ( from_memory ), or from a custom input stream ( from_stream ). SFML supports most common font formats. The full list is available in the API documentation. That's all you need to do. Once your font is loaded, you can start drawing text.","title":"Loading a font"},{"location":"tutorials/graphics/text.html#drawing-text","text":"To draw text, you will be using the SF::Text class. It's very simple to use: text = SF :: Text . new # select the font text . font = font # font is a SF::Font # set the string to display text . string = \"Hello world\" # set the character size text . character_size = 24 # in pixels, not points! # set the color text . color = SF :: Color :: Red # set the text style text . style = ( SF :: Text :: Bold | SF :: Text :: Underlined ) ... # inside the main loop, between window.clear() and window.display() window . draw ( text ) Text can also be transformed: They have a position, an orientation and a scale. The methods involved are the same as for the SF::Sprite class and other CrSFML entities. They are explained in the Transforming entities tutorial.","title":"Drawing text"},{"location":"tutorials/graphics/text.html#making-your-own-text-class","text":"If SF::Text is too limited, or if you want to do something else with pre-rendered glyphs, SF::Font provides everything that you need. You can retrieve the texture which contains all the pre-rendered glyphs of a certain size: texture = font . get_texture ( character_size ) It is important to note that glyphs are added to the texture when they are requested. There are so many characters (remember, more than 100000) that they can't all be generated when you load the font. Instead, they are rendered on the fly when you call the get_glyph method (see below). To do something meaningful with the font texture, you must get the texture coordinates of glyphs that are contained in it: glyph = font . get_glyph ( character , character_size , bold ) character is the character, the glyph of which you want to get. You must also specify the character size, and whether you want the bold or the regular version of the glyph. The SF::Glyph structure contains three members: texture_rect contains the texture coordinates of the glyph within the texture bounds contains the bounding rectangle of the glyph, which helps position it relative to the baseline of the text advance is the horizontal offset to apply to get the starting position of the next glyph in the text You can also get some of the font's other metrics, such as the kerning between two characters or the line spacing (always for a certain character size): line_spacing = font . get_line_spacing ( character_size ) kerning = font . get_kerning ( character_1 , character_2 , character_size )","title":"Making your own text class"},{"location":"tutorials/graphics/transform.html","text":"Position, rotation, scale: Transforming entities # Relevant example: transformable Transforming CrSFML entities # All CrSFML classes (sprites, text, shapes) use the same interface for transformations: SF::Transformable . This base class provides a simple API to move, rotate and scale your entities. It doesn't provide maximum flexibility, but instead defines an interface which is easy to understand and to use, and which covers 99% of all use cases -- for the remaining 1%, see the last chapters. SF::Transformable (and all its derived classes) defines four properties: position , rotation , scale and origin . They all have their respective getters and setters. These transformation components are all independent of one another: If you want to change the orientation of the entity, you just have to set its rotation property, you don't have to care about the current position and scale. Position # The position is the... position of the entity in the 2D world. I don't think it needs more explanation :). # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute position of the entity entity . position = SF . vector2 ( 10 , 50 ) # move the entity relatively to its current position entity . move ( SF . vector2 ( 5 , 5 )) # retrieve the absolute position of the entity position = entity . position # = (15, 55) By default, entities are positioned relative to their top-left corner. We'll see how to change that with the 'origin' property later. Rotation # The rotation is the orientation of the entity in the 2D world. It is defined in degrees , in clockwise order (because the Y axis is pointing down in SFML). # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute rotation of the entity entity . rotation = 45 # rotate the entity relatively to its current orientation entity . rotate ( 10 ) # retrieve the absolute rotation of the entity rotation = entity . rotation # = 55 Note that SFML always returns an angle in range [0, 360) when you call rotation . As with the position, the rotation is performed around the top-left corner by default, but this can be changed by setting the origin. Scale # The scale factor allows the entity to be resized. The default scale is 1. Setting it to a value less than 1 makes the entity smaller, greater than 1 makes it bigger. Negative scale values are also allowed, so that you can mirror the entity. # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute scale of the entity entity . scale = SF . vector2 ( 4.0 , 1.6 ) # scale the entity relatively to its current scale entity . scale ( SF . vector2 ( 0.5 , 0.5 )) # retrieve the absolute scale of the entity scale = entity . scale # = (2, 0.8) Origin # The origin is the center point of the three other transformations. The entity's position is the position of its origin, its rotation is performed around the origin, and the scale is applied relative to the origin as well. By default, it is the top-left corner of the entity (point (0, 0)), but you can set it to the center of the entity, or any other corner of the entity for example. To keep things simple, there's only a single origin for all three transformation components. This means that you can't position an entity relative to its top-left corner while rotating it around its center for example. If you need to do such things, have a look at the next chapters. # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the origin of the entity entity . origin = SF . vector2 ( 10 , 20 ) # retrieve the origin of the entity origin = entity . origin # = (10, 20) Note that changing the origin also changes where the entity is drawn on screen, even though its position property hasn't changed. If you don't understand why, read this tutorial one more time! Transforming your own classes # SF::Transformable is not only made for CrSFML classes, it can also be a base (or a member) of your own classes. class MyGraphicalEntity < SF :: Transformable # ... end entity . position = SF . vector2 ( 10 , 30 ) entity . rotation = 110 entity . scale = SF . vector2 ( 0.5 , 0.2 ) To retrieve the final transform of the entity (commonly needed when drawing it), call the transform method. This method returns a SF::Transform object. See below for an explanation about it, and how to use it to transform an SFML entity. If you don't need/want the complete set of methods provided by the SF::Transformable interface, don't hesitate to simply use it as a member instead and provide your own methods on top of it. It is not abstract, so it is possible to instantiate it instead of only being able to use it as a base class. Custom transforms # The SF::Transformable class is easy to use, but it is also limited. Some users might need more flexibility. They might need to specify a final transformation as a custom combination of individual transformations. For these users, a lower-level class is available: SF::Transform . It is nothing more than a 3x3 matrix, so it can represent any transformation in 2D space. There are many ways to construct a SF::Transform : by using the predefined methods for the most common transformations (translation, rotation, scale) by combining two transforms by specifying its 9 elements directly Here are a few examples: # the identity transform (does nothing) t1 = SF :: Transform :: Identity # a rotation transform t2 = SF :: Transform . new t2 . rotate ( 45 ) # a custom matrix t3 = SF :: Transform . new ( 2 , 0 , 20 , 0 , 1 , 50 , 0 , 0 , 1 ) # a combined transform t4 = t1 * t2 * t3 You can apply several predefined transformations to the same transform as well. They will all be combined sequentially: t = SF :: Transform . new t . translate ( 10 , 100 ) t . rotate ( 90 ) t . translate ( - 10 , 50 ) t . scale ( 0.5 , 0.75 ) Back to the point: How can a custom transform be applied to a graphical entity? Simple: Pass it to the draw method. states = SF :: RenderStates . new states . transform = transform window . draw ( entity , states ) If your entity is a SF::Transformable (sprite, text, shape), which contains its own internal transform, both the internal and the passed transform are combined to produce the final transform. Bounding boxes # After transforming entities and drawing them, you might want to perform some computations using them e.g. checking for collisions. SFML entities can give you their bounding box. The bounding box is the minimal rectangle that contains all points belonging to the entity, with sides aligned to the X and Y axes. The bounding box is very useful when implementing collision detection: Checks against a point or another axis-aligned rectangle can be done very quickly, and its area is close enough to that of the real entity to provide a good approximation. # get the bounding box of the entity bounding_box = entity . global_bounds # check collision with a point point = ... if bounding_box . contains? point # collision! end # check collision with another box (like the bounding box of another entity) other_box = ... if bounding_box . intersects? other_box # collision! end The method is named global_bounds because it returns the bounding box of the entity in the global coordinate system, i.e. after all of its transformations (position, rotation, scale) have been applied. There's another method that returns the bounding box of the entity in its local coordinate system (before its transformations are applied): local_bounds . This method can be used to get the initial size of an entity, for example, or to perform more specific calculations. Object hierarchies (scene graph) # With the custom transforms seen previously, it becomes easy to implement a hierarchy of objects in which children are transformed relative to their parent. All you have to do is pass the combined transform from parent to children when you draw them, all the way until you reach the final drawable entities (sprites, text, shapes, vertex arrays or your own drawables). # the abstract base class class Node # ... methods to transform the node # ... methods to manage the node's children def draw ( target , parent_transform ) # combine the parent transform with the node's one combined_transform = parent_transform * @transform # let the node draw itself on_draw ( target , combined_transform ) # draw its children @children . each do | child | child . draw ( target , combined_transform ) end end private def on_draw ( target , transform ) ... end end # a simple derived class: a node that draws a sprite class SpriteNode < Node # .. methods to define the sprite private def on_draw ( target , transform ) target . draw ( @sprite , transform ) end end","title":"Position, rotation, scale: transforming entities"},{"location":"tutorials/graphics/transform.html#position-rotation-scale-transforming-entities","text":"Relevant example: transformable","title":"Position, rotation, scale: Transforming entities"},{"location":"tutorials/graphics/transform.html#transforming-crsfml-entities","text":"All CrSFML classes (sprites, text, shapes) use the same interface for transformations: SF::Transformable . This base class provides a simple API to move, rotate and scale your entities. It doesn't provide maximum flexibility, but instead defines an interface which is easy to understand and to use, and which covers 99% of all use cases -- for the remaining 1%, see the last chapters. SF::Transformable (and all its derived classes) defines four properties: position , rotation , scale and origin . They all have their respective getters and setters. These transformation components are all independent of one another: If you want to change the orientation of the entity, you just have to set its rotation property, you don't have to care about the current position and scale.","title":"Transforming CrSFML entities"},{"location":"tutorials/graphics/transform.html#position","text":"The position is the... position of the entity in the 2D world. I don't think it needs more explanation :). # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute position of the entity entity . position = SF . vector2 ( 10 , 50 ) # move the entity relatively to its current position entity . move ( SF . vector2 ( 5 , 5 )) # retrieve the absolute position of the entity position = entity . position # = (15, 55) By default, entities are positioned relative to their top-left corner. We'll see how to change that with the 'origin' property later.","title":"Position"},{"location":"tutorials/graphics/transform.html#rotation","text":"The rotation is the orientation of the entity in the 2D world. It is defined in degrees , in clockwise order (because the Y axis is pointing down in SFML). # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute rotation of the entity entity . rotation = 45 # rotate the entity relatively to its current orientation entity . rotate ( 10 ) # retrieve the absolute rotation of the entity rotation = entity . rotation # = 55 Note that SFML always returns an angle in range [0, 360) when you call rotation . As with the position, the rotation is performed around the top-left corner by default, but this can be changed by setting the origin.","title":"Rotation"},{"location":"tutorials/graphics/transform.html#scale","text":"The scale factor allows the entity to be resized. The default scale is 1. Setting it to a value less than 1 makes the entity smaller, greater than 1 makes it bigger. Negative scale values are also allowed, so that you can mirror the entity. # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the absolute scale of the entity entity . scale = SF . vector2 ( 4.0 , 1.6 ) # scale the entity relatively to its current scale entity . scale ( SF . vector2 ( 0.5 , 0.5 )) # retrieve the absolute scale of the entity scale = entity . scale # = (2, 0.8)","title":"Scale"},{"location":"tutorials/graphics/transform.html#origin","text":"The origin is the center point of the three other transformations. The entity's position is the position of its origin, its rotation is performed around the origin, and the scale is applied relative to the origin as well. By default, it is the top-left corner of the entity (point (0, 0)), but you can set it to the center of the entity, or any other corner of the entity for example. To keep things simple, there's only a single origin for all three transformation components. This means that you can't position an entity relative to its top-left corner while rotating it around its center for example. If you need to do such things, have a look at the next chapters. # 'entity' can be a SF::Sprite, a SF::Text, a SF::Shape or any other transformable class # set the origin of the entity entity . origin = SF . vector2 ( 10 , 20 ) # retrieve the origin of the entity origin = entity . origin # = (10, 20) Note that changing the origin also changes where the entity is drawn on screen, even though its position property hasn't changed. If you don't understand why, read this tutorial one more time!","title":"Origin"},{"location":"tutorials/graphics/transform.html#transforming-your-own-classes","text":"SF::Transformable is not only made for CrSFML classes, it can also be a base (or a member) of your own classes. class MyGraphicalEntity < SF :: Transformable # ... end entity . position = SF . vector2 ( 10 , 30 ) entity . rotation = 110 entity . scale = SF . vector2 ( 0.5 , 0.2 ) To retrieve the final transform of the entity (commonly needed when drawing it), call the transform method. This method returns a SF::Transform object. See below for an explanation about it, and how to use it to transform an SFML entity. If you don't need/want the complete set of methods provided by the SF::Transformable interface, don't hesitate to simply use it as a member instead and provide your own methods on top of it. It is not abstract, so it is possible to instantiate it instead of only being able to use it as a base class.","title":"Transforming your own classes"},{"location":"tutorials/graphics/transform.html#custom-transforms","text":"The SF::Transformable class is easy to use, but it is also limited. Some users might need more flexibility. They might need to specify a final transformation as a custom combination of individual transformations. For these users, a lower-level class is available: SF::Transform . It is nothing more than a 3x3 matrix, so it can represent any transformation in 2D space. There are many ways to construct a SF::Transform : by using the predefined methods for the most common transformations (translation, rotation, scale) by combining two transforms by specifying its 9 elements directly Here are a few examples: # the identity transform (does nothing) t1 = SF :: Transform :: Identity # a rotation transform t2 = SF :: Transform . new t2 . rotate ( 45 ) # a custom matrix t3 = SF :: Transform . new ( 2 , 0 , 20 , 0 , 1 , 50 , 0 , 0 , 1 ) # a combined transform t4 = t1 * t2 * t3 You can apply several predefined transformations to the same transform as well. They will all be combined sequentially: t = SF :: Transform . new t . translate ( 10 , 100 ) t . rotate ( 90 ) t . translate ( - 10 , 50 ) t . scale ( 0.5 , 0.75 ) Back to the point: How can a custom transform be applied to a graphical entity? Simple: Pass it to the draw method. states = SF :: RenderStates . new states . transform = transform window . draw ( entity , states ) If your entity is a SF::Transformable (sprite, text, shape), which contains its own internal transform, both the internal and the passed transform are combined to produce the final transform.","title":"Custom transforms"},{"location":"tutorials/graphics/transform.html#bounding-boxes","text":"After transforming entities and drawing them, you might want to perform some computations using them e.g. checking for collisions. SFML entities can give you their bounding box. The bounding box is the minimal rectangle that contains all points belonging to the entity, with sides aligned to the X and Y axes. The bounding box is very useful when implementing collision detection: Checks against a point or another axis-aligned rectangle can be done very quickly, and its area is close enough to that of the real entity to provide a good approximation. # get the bounding box of the entity bounding_box = entity . global_bounds # check collision with a point point = ... if bounding_box . contains? point # collision! end # check collision with another box (like the bounding box of another entity) other_box = ... if bounding_box . intersects? other_box # collision! end The method is named global_bounds because it returns the bounding box of the entity in the global coordinate system, i.e. after all of its transformations (position, rotation, scale) have been applied. There's another method that returns the bounding box of the entity in its local coordinate system (before its transformations are applied): local_bounds . This method can be used to get the initial size of an entity, for example, or to perform more specific calculations.","title":"Bounding boxes"},{"location":"tutorials/graphics/transform.html#object-hierarchies-scene-graph","text":"With the custom transforms seen previously, it becomes easy to implement a hierarchy of objects in which children are transformed relative to their parent. All you have to do is pass the combined transform from parent to children when you draw them, all the way until you reach the final drawable entities (sprites, text, shapes, vertex arrays or your own drawables). # the abstract base class class Node # ... methods to transform the node # ... methods to manage the node's children def draw ( target , parent_transform ) # combine the parent transform with the node's one combined_transform = parent_transform * @transform # let the node draw itself on_draw ( target , combined_transform ) # draw its children @children . each do | child | child . draw ( target , combined_transform ) end end private def on_draw ( target , transform ) ... end end # a simple derived class: a node that draws a sprite class SpriteNode < Node # .. methods to define the sprite private def on_draw ( target , transform ) target . draw ( @sprite , transform ) end end","title":"Object hierarchies (scene graph)"},{"location":"tutorials/graphics/vertex-array.html","text":"Designing your own entities with vertex arrays # Introduction # SFML provides simple classes for the most common 2D entities. And while more complex entities can easily be created from these building blocks, it isn't always the most efficient solution. For example, you'll reach the limits of your graphics card very quickly if you draw a large number of sprites. The reason is that performance depends in large part on the number of calls to the draw method. Indeed, each call involves setting a set of OpenGL states, resetting matrices, changing textures, etc. All of this is required even when simply drawing two triangles (a sprite). This is far from optimal for your graphics card: Today's GPUs are designed to process large batches of triangles, typically several thousand to millions. To fill this gap, SFML provides a lower-level mechanism to draw things: Vertex arrays. As a matter of fact, vertex arrays are used internally by all other SFML classes. They allow for a more flexible definition of 2D entities, containing as many triangles as you need. They even allow drawing points or lines. What is a vertex, and why are they always in arrays? # A vertex is the smallest graphical entity that you can manipulate. In short, it is a graphical point: Naturally, it has a 2D position (x, y), but also a color, and a pair of texture coordinates. We'll go into the roles of these attributes later. Vertices (plural of vertex) alone don't do much. They are always grouped into primitives : Points (1 vertex), lines (2 vertices), triangles (3 vertices) or quads (4 vertices). You can then combine multiple primitives together to create the final geometry of the entity. Now you understand why we always talk about vertex arrays, and not vertices alone. A simple vertex array # Let's have a look at the SF::Vertex class now. It's simply a container which contains three public members and no functions besides its constructors. These constructors allow you to construct vertices from the set of attributes you care about -- you don't always need to color or texture your entity. # create a new vertex vertex = SF :: Vertex . new # set its position vertex . position = SF . vector2 ( 10 , 50 ) # set its color vertex . color = SF :: Color :: Red # set its texture coordinates vertex . tex_coords = SF . vector2f ( 100 , 100 ) ... or, using the correct constructor: vertex = SF :: Vertex . new ({ 10 , 50 }, SF :: Color :: Red , { 100 , 100 }) Now, let's define a primitive. Remember, a primitive consists of several vertices, therefore we need a vertex array. CrSFML provides a simple wrapper for this: SF::VertexArray . It provides the semantics of an array, and also stores the type of primitive its vertices define. # create an array of 3 vertices that define a triangle primitive triangle = SF :: VertexArray . new ( SF :: Triangles , 3 ) # define the positions and colors of the triangle's points triangle [ 0 ] = SF :: Vertex . new ( SF . vector2 ( 10 , 10 ), SF :: Color :: Red ) triangle [ 1 ] = SF :: Vertex . new ( SF . vector2 ( 100 , 10 ), SF :: Color :: Blue ) triangle [ 2 ] = SF :: Vertex . new ( SF . vector2 ( 100 , 100 ), SF :: Color :: Green ) # no texture coordinates here, we'll see that later Your triangle is ready and you can now draw it. Drawing a vertex array can be done similar to drawing any other CrSFML entity, by using the draw function: window . draw ( triangle ) You can see that the vertices' color is interpolated to fill the primitive. This is a nice way of creating gradients. Note that you don't have to use the SF::VertexArray class. It's just defined for convenience, it's nothing more than an array along with a SF::PrimitiveType . If you need more flexibility, or a normal (or static) array, you can use your own storage. You must then use the overload of the draw function which takes an array of vertices and the primitive type. vertices = [ SF :: Vertex . new ( ... ), SF :: Vertex . new ( ... ) ] window . draw ( vertices , SF :: Lines ) Primitive types # Let's pause for a while and see what kind of primitives you can create. As explained above, you can define the most basic 2D primitives: Point, line, triangle and quad (quad exists merely as a convenience, internally the graphics card breaks it into two triangles). There are also \"chained\" variants of these primitive types which allow for sharing of vertices among two consecutive primitives. This can be useful because consecutive primitives are often connected in some way. Let's have a look at the full list: Primitive type Description Example SF::Points A set of unconnected points. These points have no thickness: They will always occupy a single pixel, regardless of the current transform and view. SF::Lines A set of unconnected lines. These lines have no thickness: They will always be one pixel wide, regardless of the current transform and view. SF::LinesStrip A set of connected lines. The end vertex of one line is used as the start vertex of the next one. SF::Triangles A set of unconnected triangles. SF::TrianglesStrip A set of connected triangles. Each triangle shares its two last vertices with the next one. SF::TrianglesFan A set of triangles connected to a central point. The first vertex is the center, then each new vertex defines a new triangle, using the center and the previous vertex. SF::Quads A set of unconnected quads. The 4 points of each quad must be defined consistently, either in clockwise or counter-clockwise order. Texturing # Like other SFML entities, vertex arrays can also be textured. To do so, you'll need to manipulate the tex_coords attribute of the vertices. This attribute defines which pixel of the texture is mapped to the vertex. # create a quad quad = SF :: VertexArray . new ( SF :: Quads , 4 ) # define it as a rectangle, located at (10, 10) and with size 100x100 # define its texture area to be a 25x50 rectangle starting at (0, 0) quad . append SF :: Vertex . new ({ 10 , 10 }, tex_coords : { 0 , 0 }) quad . append SF :: Vertex . new ({ 110 , 10 }, tex_coords : { 25 , 0 }) quad . append SF :: Vertex . new ({ 110 , 110 }, tex_coords : { 25 , 50 }) quad . append SF :: Vertex . new ({ 10 , 110 }, tex_coords : { 0 , 50 }) Texture coordinates are defined in pixels (just like the texture_rect of sprites and shapes). They are not normalized (between 0 and 1), as people who are used to OpenGL programming might expect. Vertex arrays are low-level entities, they only deal with geometry and do not store additional attributes like a texture. To draw a vertex array with a texture, you must pass it directly to the draw method, through a SF::RenderStates object: vertices = ... # SF::VertexArray texture = ... # SF::Texture ... states = SF :: RenderStates . new states . texture = texture window . draw ( vertices , states ) Transforming a vertex array # Transforming is similar to texturing. The transform is not stored in the vertex array, you must pass it to the draw method. vertices = ... # SF::VertexArray transform = ... # SF::Transform ... states = SF :: RenderStates . new states . transform = transform window . draw ( vertices , states ) To know more about transformations and the SF::Transform class, you can read the tutorial on transforming entities . Creating an SFML-like entity # Now that you know how to define your own textured/colored/transformed entity, wouldn't it be nice to wrap it in an SFML-style class? Fortunately, SFML makes this easy for you by providing the SF::Drawable module and SF::Transformable base class. These two classes are the base of the built-in SFML entities Sprite, Text and Shape. SF::Drawable is an interface: it declares a single abstract method. Including sf::Drawable allows you to draw instances of your class the same way as SFML classes: class MyEntity include SF :: Drawable def draw ( target : SF :: RenderTarget , states : SF :: RenderStates ) end end entity = MyEntity . new window . draw ( entity ) # internally calls entity.draw Subclassing the SF::Transformable class automatically adds the same transformation methods to your class as other CrSFML classes ( position= , rotation= , move , scale , ...). You can learn more about this in the tutorial on transforming entities . Using these two features and a vertex array (in this example we'll also add a texture), here is what a typical CrSFML-like graphical class would look like: class MyEntity < SF :: Transformable include SF :: Drawable # add methods to play with the entity's geometry / colors / texturing... def draw ( target , states ) # apply the entity's transform -- combine it with the one that was passed by the caller states . transform *= transform # transform() is defined by SF::Transformable # apply the texture states . texture = @texture # you may also override states.shader or states.blend_mode if you want # draw the vertex array target . draw ( @vertices , states ) end end You can then use this class as if it were a built-in CrSFML class: entity = MyEntity . new # you can transform it entity . position = SF . vector2 ( 10 , 50 ) entity . rotation = 45 # you can draw it window . draw ( entity ) Example: tile map # Relevant example: minesweeper With what we've seen above, let's create a class that encapsulates a tile map. The whole map will be contained in a single vertex array, therefore it will be super fast to draw. Note that we can apply this strategy only if the whole tile set can fit into a single texture. Otherwise, we would have to use at least one vertex array per texture. class TileMap < SF :: Transformable include SF :: Drawable def initialize ( tileset , tile_size , tiles , width , height ) super () # load the tileset texture @tileset = SF :: Texture . from_file ( tileset ) @vertices = SF :: VertexArray . new ( SF :: Quads ) tiles_per_row = @tileset . size . x / tile_size . x # populate the vertex array, with one quad per tile ( 0 ... height ) . each do | y | ( 0 ... width ) . each do | x | # get the current tile number tile_index = tiles [ width * y + x ] # find its position in the tileset texture tile_pos = SF . vector2 ( tile_index % tiles_per_row , tile_index / tiles_per_row ) destination = SF . vector2 ( x , y ) # define its 4 corners and texture coordinates { { 0 , 0 }, { 1 , 0 }, { 1 , 1 }, { 0 , 1 } } . each do | delta | @vertices . append SF :: Vertex . new ( ( destination + delta ) * tile_size , tex_coords : ( tile_pos + delta ) * tile_size ) end end end end def draw ( target , states ) # apply the transform states . transform *= transform () # apply the tileset texture states . texture = @tileset # draw the vertex array target . draw ( @vertices , states ) end end And now, the application that uses it: # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 512 , 256 ), \"Tilemap\" ) # define the level with an array of tile indices level = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 1 , 0 , 0 , 2 , 0 , 3 , 3 , 3 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 3 , 3 , 3 , 0 , 0 , 0 , 1 , 1 , 1 , 2 , 0 , 0 , 0 , 0 , 1 , 0 , 3 , 0 , 2 , 2 , 0 , 0 , 1 , 1 , 1 , 1 , 2 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 2 , 2 , 2 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 3 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] # create the tilemap from the level definition map = TileMap . new ( \"tileset.png\" , SF . vector2 ( 32 , 32 ), level , 16 , 8 ) # run the main loop while window . open? # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed window . close end end # draw the map window . clear window . draw ( map ) window . display end Example: particle system # This second example implements another common entity: The particle system. This one is very simple, with no texture and as few parameters as possible. It demonstrates the use of the SF::Points primitive type with a dynamic vertex array which changes every frame. struct Particle def initialize ( @velocity , @lifetime , @position ) @total_lifetime = @lifetime end property velocity : SF :: Vector2f property lifetime : SF :: Time property position : SF :: Vector2f getter total_lifetime : SF :: Time end class ParticleSystem < SF :: Transformable include SF :: Drawable def initialize ( @count : Int32 ) super () @particles = [] of Particle @emitter = SF :: Vector2f . new ( 0.0f32 , 0.0f32 ) @random = Random . new end property emitter def update ( elapsed ) @particles . map! do | p | # update the position of the particle p . position += p . velocity * elapsed . as_seconds # update the particle lifetime p . lifetime -= elapsed # if the particle is dead, remove it if p . lifetime <= SF :: Time :: Zero new_particle else p end end if @particles . size < @count @particles << new_particle end end def draw ( target , states ) vertices = @particles . map do | p | # set the alpha (transparency) of the particle according to its lifetime ratio = p . lifetime / p . total_lifetime color = SF . color ( 255 , 255 , 255 , ( ratio * 255 ) . to_u8 ) SF :: Vertex . new ( p . position , color ) end # apply the transform states . transform *= transform () # draw the vertex array target . draw ( vertices , SF :: Points , states ) end private def new_particle # give a random velocity and lifetime to the particle angle = @random . rand ( Math :: PI * 2 ) speed = @random . rand ( 50.0 .. 100.0 ) velocity = SF . vector2f ( Math . cos ( angle ) * speed , Math . sin ( angle ) * speed ) lifetime = SF . seconds ( @random . rand ( 1.0 .. 3.0 )) Particle . new ( velocity , lifetime , @emitter ) end end And a little demo that uses it: # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"Particles\" ) # create the particle system particles = ParticleSystem . new ( 1000 ) # create a clock to track the elapsed time clock = SF :: Clock . new # run the main loop while window . open? # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed window . close end end # make the particle system emitter follow the mouse mouse = SF :: Mouse . get_position ( window ) particles . emitter = window . map_pixel_to_coords ( mouse ) # update it elapsed = clock . restart particles . update ( elapsed ) # draw it window . clear window . draw ( particles ) window . display end","title":"Designing your own entities with vertex arrays"},{"location":"tutorials/graphics/vertex-array.html#designing-your-own-entities-with-vertex-arrays","text":"","title":"Designing your own entities with vertex arrays"},{"location":"tutorials/graphics/vertex-array.html#introduction","text":"SFML provides simple classes for the most common 2D entities. And while more complex entities can easily be created from these building blocks, it isn't always the most efficient solution. For example, you'll reach the limits of your graphics card very quickly if you draw a large number of sprites. The reason is that performance depends in large part on the number of calls to the draw method. Indeed, each call involves setting a set of OpenGL states, resetting matrices, changing textures, etc. All of this is required even when simply drawing two triangles (a sprite). This is far from optimal for your graphics card: Today's GPUs are designed to process large batches of triangles, typically several thousand to millions. To fill this gap, SFML provides a lower-level mechanism to draw things: Vertex arrays. As a matter of fact, vertex arrays are used internally by all other SFML classes. They allow for a more flexible definition of 2D entities, containing as many triangles as you need. They even allow drawing points or lines.","title":"Introduction"},{"location":"tutorials/graphics/vertex-array.html#what-is-a-vertex-and-why-are-they-always-in-arrays","text":"A vertex is the smallest graphical entity that you can manipulate. In short, it is a graphical point: Naturally, it has a 2D position (x, y), but also a color, and a pair of texture coordinates. We'll go into the roles of these attributes later. Vertices (plural of vertex) alone don't do much. They are always grouped into primitives : Points (1 vertex), lines (2 vertices), triangles (3 vertices) or quads (4 vertices). You can then combine multiple primitives together to create the final geometry of the entity. Now you understand why we always talk about vertex arrays, and not vertices alone.","title":"What is a vertex, and why are they always in arrays?"},{"location":"tutorials/graphics/vertex-array.html#a-simple-vertex-array","text":"Let's have a look at the SF::Vertex class now. It's simply a container which contains three public members and no functions besides its constructors. These constructors allow you to construct vertices from the set of attributes you care about -- you don't always need to color or texture your entity. # create a new vertex vertex = SF :: Vertex . new # set its position vertex . position = SF . vector2 ( 10 , 50 ) # set its color vertex . color = SF :: Color :: Red # set its texture coordinates vertex . tex_coords = SF . vector2f ( 100 , 100 ) ... or, using the correct constructor: vertex = SF :: Vertex . new ({ 10 , 50 }, SF :: Color :: Red , { 100 , 100 }) Now, let's define a primitive. Remember, a primitive consists of several vertices, therefore we need a vertex array. CrSFML provides a simple wrapper for this: SF::VertexArray . It provides the semantics of an array, and also stores the type of primitive its vertices define. # create an array of 3 vertices that define a triangle primitive triangle = SF :: VertexArray . new ( SF :: Triangles , 3 ) # define the positions and colors of the triangle's points triangle [ 0 ] = SF :: Vertex . new ( SF . vector2 ( 10 , 10 ), SF :: Color :: Red ) triangle [ 1 ] = SF :: Vertex . new ( SF . vector2 ( 100 , 10 ), SF :: Color :: Blue ) triangle [ 2 ] = SF :: Vertex . new ( SF . vector2 ( 100 , 100 ), SF :: Color :: Green ) # no texture coordinates here, we'll see that later Your triangle is ready and you can now draw it. Drawing a vertex array can be done similar to drawing any other CrSFML entity, by using the draw function: window . draw ( triangle ) You can see that the vertices' color is interpolated to fill the primitive. This is a nice way of creating gradients. Note that you don't have to use the SF::VertexArray class. It's just defined for convenience, it's nothing more than an array along with a SF::PrimitiveType . If you need more flexibility, or a normal (or static) array, you can use your own storage. You must then use the overload of the draw function which takes an array of vertices and the primitive type. vertices = [ SF :: Vertex . new ( ... ), SF :: Vertex . new ( ... ) ] window . draw ( vertices , SF :: Lines )","title":"A simple vertex array"},{"location":"tutorials/graphics/vertex-array.html#primitive-types","text":"Let's pause for a while and see what kind of primitives you can create. As explained above, you can define the most basic 2D primitives: Point, line, triangle and quad (quad exists merely as a convenience, internally the graphics card breaks it into two triangles). There are also \"chained\" variants of these primitive types which allow for sharing of vertices among two consecutive primitives. This can be useful because consecutive primitives are often connected in some way. Let's have a look at the full list: Primitive type Description Example SF::Points A set of unconnected points. These points have no thickness: They will always occupy a single pixel, regardless of the current transform and view. SF::Lines A set of unconnected lines. These lines have no thickness: They will always be one pixel wide, regardless of the current transform and view. SF::LinesStrip A set of connected lines. The end vertex of one line is used as the start vertex of the next one. SF::Triangles A set of unconnected triangles. SF::TrianglesStrip A set of connected triangles. Each triangle shares its two last vertices with the next one. SF::TrianglesFan A set of triangles connected to a central point. The first vertex is the center, then each new vertex defines a new triangle, using the center and the previous vertex. SF::Quads A set of unconnected quads. The 4 points of each quad must be defined consistently, either in clockwise or counter-clockwise order.","title":"Primitive types"},{"location":"tutorials/graphics/vertex-array.html#texturing","text":"Like other SFML entities, vertex arrays can also be textured. To do so, you'll need to manipulate the tex_coords attribute of the vertices. This attribute defines which pixel of the texture is mapped to the vertex. # create a quad quad = SF :: VertexArray . new ( SF :: Quads , 4 ) # define it as a rectangle, located at (10, 10) and with size 100x100 # define its texture area to be a 25x50 rectangle starting at (0, 0) quad . append SF :: Vertex . new ({ 10 , 10 }, tex_coords : { 0 , 0 }) quad . append SF :: Vertex . new ({ 110 , 10 }, tex_coords : { 25 , 0 }) quad . append SF :: Vertex . new ({ 110 , 110 }, tex_coords : { 25 , 50 }) quad . append SF :: Vertex . new ({ 10 , 110 }, tex_coords : { 0 , 50 }) Texture coordinates are defined in pixels (just like the texture_rect of sprites and shapes). They are not normalized (between 0 and 1), as people who are used to OpenGL programming might expect. Vertex arrays are low-level entities, they only deal with geometry and do not store additional attributes like a texture. To draw a vertex array with a texture, you must pass it directly to the draw method, through a SF::RenderStates object: vertices = ... # SF::VertexArray texture = ... # SF::Texture ... states = SF :: RenderStates . new states . texture = texture window . draw ( vertices , states )","title":"Texturing"},{"location":"tutorials/graphics/vertex-array.html#transforming-a-vertex-array","text":"Transforming is similar to texturing. The transform is not stored in the vertex array, you must pass it to the draw method. vertices = ... # SF::VertexArray transform = ... # SF::Transform ... states = SF :: RenderStates . new states . transform = transform window . draw ( vertices , states ) To know more about transformations and the SF::Transform class, you can read the tutorial on transforming entities .","title":"Transforming a vertex array"},{"location":"tutorials/graphics/vertex-array.html#creating-an-sfml-like-entity","text":"Now that you know how to define your own textured/colored/transformed entity, wouldn't it be nice to wrap it in an SFML-style class? Fortunately, SFML makes this easy for you by providing the SF::Drawable module and SF::Transformable base class. These two classes are the base of the built-in SFML entities Sprite, Text and Shape. SF::Drawable is an interface: it declares a single abstract method. Including sf::Drawable allows you to draw instances of your class the same way as SFML classes: class MyEntity include SF :: Drawable def draw ( target : SF :: RenderTarget , states : SF :: RenderStates ) end end entity = MyEntity . new window . draw ( entity ) # internally calls entity.draw Subclassing the SF::Transformable class automatically adds the same transformation methods to your class as other CrSFML classes ( position= , rotation= , move , scale , ...). You can learn more about this in the tutorial on transforming entities . Using these two features and a vertex array (in this example we'll also add a texture), here is what a typical CrSFML-like graphical class would look like: class MyEntity < SF :: Transformable include SF :: Drawable # add methods to play with the entity's geometry / colors / texturing... def draw ( target , states ) # apply the entity's transform -- combine it with the one that was passed by the caller states . transform *= transform # transform() is defined by SF::Transformable # apply the texture states . texture = @texture # you may also override states.shader or states.blend_mode if you want # draw the vertex array target . draw ( @vertices , states ) end end You can then use this class as if it were a built-in CrSFML class: entity = MyEntity . new # you can transform it entity . position = SF . vector2 ( 10 , 50 ) entity . rotation = 45 # you can draw it window . draw ( entity )","title":"Creating an SFML-like entity"},{"location":"tutorials/graphics/vertex-array.html#example-tile-map","text":"Relevant example: minesweeper With what we've seen above, let's create a class that encapsulates a tile map. The whole map will be contained in a single vertex array, therefore it will be super fast to draw. Note that we can apply this strategy only if the whole tile set can fit into a single texture. Otherwise, we would have to use at least one vertex array per texture. class TileMap < SF :: Transformable include SF :: Drawable def initialize ( tileset , tile_size , tiles , width , height ) super () # load the tileset texture @tileset = SF :: Texture . from_file ( tileset ) @vertices = SF :: VertexArray . new ( SF :: Quads ) tiles_per_row = @tileset . size . x / tile_size . x # populate the vertex array, with one quad per tile ( 0 ... height ) . each do | y | ( 0 ... width ) . each do | x | # get the current tile number tile_index = tiles [ width * y + x ] # find its position in the tileset texture tile_pos = SF . vector2 ( tile_index % tiles_per_row , tile_index / tiles_per_row ) destination = SF . vector2 ( x , y ) # define its 4 corners and texture coordinates { { 0 , 0 }, { 1 , 0 }, { 1 , 1 }, { 0 , 1 } } . each do | delta | @vertices . append SF :: Vertex . new ( ( destination + delta ) * tile_size , tex_coords : ( tile_pos + delta ) * tile_size ) end end end end def draw ( target , states ) # apply the transform states . transform *= transform () # apply the tileset texture states . texture = @tileset # draw the vertex array target . draw ( @vertices , states ) end end And now, the application that uses it: # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 512 , 256 ), \"Tilemap\" ) # define the level with an array of tile indices level = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 0 , 1 , 0 , 0 , 2 , 0 , 3 , 3 , 3 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 3 , 3 , 3 , 0 , 0 , 0 , 1 , 1 , 1 , 2 , 0 , 0 , 0 , 0 , 1 , 0 , 3 , 0 , 2 , 2 , 0 , 0 , 1 , 1 , 1 , 1 , 2 , 0 , 2 , 0 , 1 , 0 , 3 , 0 , 2 , 2 , 2 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 3 , 2 , 2 , 2 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ] # create the tilemap from the level definition map = TileMap . new ( \"tileset.png\" , SF . vector2 ( 32 , 32 ), level , 16 , 8 ) # run the main loop while window . open? # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed window . close end end # draw the map window . clear window . draw ( map ) window . display end","title":"Example: tile map"},{"location":"tutorials/graphics/vertex-array.html#example-particle-system","text":"This second example implements another common entity: The particle system. This one is very simple, with no texture and as few parameters as possible. It demonstrates the use of the SF::Points primitive type with a dynamic vertex array which changes every frame. struct Particle def initialize ( @velocity , @lifetime , @position ) @total_lifetime = @lifetime end property velocity : SF :: Vector2f property lifetime : SF :: Time property position : SF :: Vector2f getter total_lifetime : SF :: Time end class ParticleSystem < SF :: Transformable include SF :: Drawable def initialize ( @count : Int32 ) super () @particles = [] of Particle @emitter = SF :: Vector2f . new ( 0.0f32 , 0.0f32 ) @random = Random . new end property emitter def update ( elapsed ) @particles . map! do | p | # update the position of the particle p . position += p . velocity * elapsed . as_seconds # update the particle lifetime p . lifetime -= elapsed # if the particle is dead, remove it if p . lifetime <= SF :: Time :: Zero new_particle else p end end if @particles . size < @count @particles << new_particle end end def draw ( target , states ) vertices = @particles . map do | p | # set the alpha (transparency) of the particle according to its lifetime ratio = p . lifetime / p . total_lifetime color = SF . color ( 255 , 255 , 255 , ( ratio * 255 ) . to_u8 ) SF :: Vertex . new ( p . position , color ) end # apply the transform states . transform *= transform () # draw the vertex array target . draw ( vertices , SF :: Points , states ) end private def new_particle # give a random velocity and lifetime to the particle angle = @random . rand ( Math :: PI * 2 ) speed = @random . rand ( 50.0 .. 100.0 ) velocity = SF . vector2f ( Math . cos ( angle ) * speed , Math . sin ( angle ) * speed ) lifetime = SF . seconds ( @random . rand ( 1.0 .. 3.0 )) Particle . new ( velocity , lifetime , @emitter ) end end And a little demo that uses it: # create the window window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"Particles\" ) # create the particle system particles = ParticleSystem . new ( 1000 ) # create a clock to track the elapsed time clock = SF :: Clock . new # run the main loop while window . open? # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed window . close end end # make the particle system emitter follow the mouse mouse = SF :: Mouse . get_position ( window ) particles . emitter = window . map_pixel_to_coords ( mouse ) # update it elapsed = clock . restart particles . update ( elapsed ) # draw it window . clear window . draw ( particles ) window . display end","title":"Example: particle system"},{"location":"tutorials/graphics/view.html","text":"Controlling the 2D camera with views # What is a view? # In games, it is not uncommon to have levels which are much bigger than the window itself. You only see is a small part of them. This is typically the case in RPGs, platform games, and many other genres. What developers might tend to forget is that they define entities in a 2D world , not directly in the window. The window is just a view, it shows a specific area of the whole world. It is perfectly fine to draw several views of the same world in parallel, or draw the world to a texture rather than to a window. The world itself remains unchanged, what changes is just the way it is seen. Since what is seen in the window is just a small part of the entire 2D world, you need a way to specify which part of the world is shown in the window. Additionally, you may also want to define where/how this area will be shown within the window. These are the two main features of SFML views. To summarize, views are what you need if you want to scroll, rotate or zoom your world. They are also the key to creating split screens and mini-maps. Defining what the view views # The class which encapsulates views in SFML is SF::View . It can be constructed directly with a definition of the area to view: # create a view with the rectangular area of the 2D world to show view1 = SF :: View . new ( SF . float_rect ( 200 , 200 , 300 , 200 )) # create a view with its center and size view2 = SF :: View . new ( SF . vector2 ( 350 , 300 ), SF . vector2 ( 300 , 200 )) These two definitions are equivalent: Both views will show the same area of the 2D world, a 300x200 rectangle centered on the point (350, 300). If you don't want to define the view upon construction or want to modify it later, you can use the equivalent setters: view1 . reset ( SF . float_rect ( 200 , 200 , 300 , 200 )) view2 . center = SF . vector2 ( 350 , 300 ) view2 . size = SF . vector2 ( 200 , 200 ) Once your view is defined, you can transform it to make it show a translated/rotated/scaled version of your 2D world. Moving (scrolling) the view # Unlike drawable entities, such as sprites or shapes whose positions are defined by their top-left corner (and can be changed to any other point), views are always manipulated by their center -- this is simply more convenient. That's why the method to change the position of a view is named center= , and not position= . # move the view at point (200, 200) view . center = SF . vector2 ( 200 , 200 ) # move the view by an offset of (100, 100) (so its final position is (300, 300)) view . move ( SF . vector2 ( 100 , 100 )) Rotating the view # To rotate a view, use the rotation= method. # rotate the view at 20 degrees view . rotation = 20 # rotate the view by 5 degrees relatively to its current orientation (so its final orientation is 25 degrees) view . rotate ( 5 ) Zooming (scaling) the view # Zooming in (or out) a view is done through to resizing it, so the method to use is size= . # resize the view to show a 1200x800 area (we see a bigger area, so this is a zoom out) view . size = SF . vector2 ( 1200 , 800 ) # zoom the view relatively to its current size (apply a factor 0.5, so its final size is 600x400) view . zoom ( 0.5 ) Defining how the view is viewed # Now that you've defined which part of the 2D world is seen in the window, let's define where it is shown. By default, the viewed contents occupy the full window. If the view has the same size as the window, everything is rendered 1:1. If the view is smaller or larger than the window, everything is scaled to fit in the window. This default behavior is suitable for most situations, but it might need to be changed sometimes. For example, to split the screen in a multiplayer game, you may want to use two views which each only occupy half of the window. You can also implement a minimap by drawing your entire world to a view which is rendered in a small area in a corner of the window. The area in which the contents of the view is shown is called the viewport . To set the viewport of a view, you can use the viewport= method. # define a centered viewport, with half the size of the window view . viewport = SF . float_rect ( 0.25 , 0.25 , 0.5 , 0.5 ) You might have noticed something very important: The viewport is not defined in pixels, but instead as a ratio of the window size. This is more convenient: It allows you to not have to track resize events in order to update the size of the viewport every time the size of the window changes. It is also more intuitive: You would probably define your viewport as a fraction of the entire window area anyway, not as a fixed-size rectangle. Using a viewport, it is straightforward to split the screen for multiplayer games: # player 1 (left side of the screen) player1_view . viewport = SF . float_rect ( 0 , 0 , 0.5 , 1 ) # player 2 (right side of the screen) player2_view . viewport = SF . float_rect ( 0.5 , 0 , 0.5 , 1 ) ... or a mini-map: # the game view (full window) game_view . viewport = SF . float_rect ( 0 , 0 , 1 , 1 ) # mini-map (upper-right corner) minimap_view . viewport = SF . float_rect ( 0.75 , 0 , 0.25 , 0.25 ) Using a view # To draw something using a view, you must draw it after calling the view= method of the target to which you are drawing ( SF::RenderWindow or SF::RenderTexture ). # let's define a view view = SF :: View . new ( SF . float_rect ( 0 , 0 , 1000 , 600 )) # activate it window . view = view # draw something to that view window . draw ( some_sprite ) # want to do visibility checks? retrieve the view current_view = window . view ... The view remains active until you set another one. This means that there is always a view which defines what appears in the target, and where it is drawn. If you don't explicitly set any view, the render-target uses its own default view, which matches its size 1:1. You can get the default view of a render-target with the default_view method. This can be useful if you want to define your own view based on it, or restore it to draw fixed entities (like a GUI) on top of your scene. # create a view half the size of the default view view = window . default_view view . zoom ( 0.5 ) window . view = view # restore the default view window . view = window . default_view When you call view= , the render-target makes a copy of the view, and doesn't store a pointer to the one that is passed. This means that whenever you update your view, you need to call view= again to apply the modifications. Don't be afraid to copy views or create them on the fly, they aren't expensive objects (they just hold a few floats). Showing more when the window is resized # Since the default view never changes after the window is created, the viewed contents are always the same. So when the window is resized, everything is squeezed/stretched to the new size. If, instead of this default behavior, you'd like to show more/less stuff depending on the new size of the window, all you have to do is update the size of the view with the size of the window. # the event loop while event = window . poll_event ... # catch the resize events if event . is_a? SF :: Event :: Resized # update the view to the new size of the window visible_area = SF . float_rect ( 0 , 0 , event . width , event . height ) window . view = SF :: View . new ( visible_area ) end end Coordinates conversions # When you use a custom view, or when you resize the window without using the code above, pixels displayed on the target no longer match units in the 2D world. For example, clicking on pixel (10, 50) may hit the point (26.5, -84) of your world. You end up having to use a conversion method to map your pixel coordinates to world coordinates: map_pixel_to_coords . # get the current mouse position in the window pixel_pos = SF :: Mouse . get_position ( window ) # convert it to world coordinates world_pos = window . map_pixel_to_coords ( pixel_pos , window . view ) By default, map_pixel_to_coords uses the current view. If you want to convert the coordinates using view which is not the active one, you can pass it as an additional argument to the method. The opposite, converting world coordinates to pixel coordinates, is also possible with the map_coords_to_pixel method.","title":"Controlling the 2D camera with views"},{"location":"tutorials/graphics/view.html#controlling-the-2d-camera-with-views","text":"","title":"Controlling the 2D camera with views"},{"location":"tutorials/graphics/view.html#what-is-a-view","text":"In games, it is not uncommon to have levels which are much bigger than the window itself. You only see is a small part of them. This is typically the case in RPGs, platform games, and many other genres. What developers might tend to forget is that they define entities in a 2D world , not directly in the window. The window is just a view, it shows a specific area of the whole world. It is perfectly fine to draw several views of the same world in parallel, or draw the world to a texture rather than to a window. The world itself remains unchanged, what changes is just the way it is seen. Since what is seen in the window is just a small part of the entire 2D world, you need a way to specify which part of the world is shown in the window. Additionally, you may also want to define where/how this area will be shown within the window. These are the two main features of SFML views. To summarize, views are what you need if you want to scroll, rotate or zoom your world. They are also the key to creating split screens and mini-maps.","title":"What is a view?"},{"location":"tutorials/graphics/view.html#defining-what-the-view-views","text":"The class which encapsulates views in SFML is SF::View . It can be constructed directly with a definition of the area to view: # create a view with the rectangular area of the 2D world to show view1 = SF :: View . new ( SF . float_rect ( 200 , 200 , 300 , 200 )) # create a view with its center and size view2 = SF :: View . new ( SF . vector2 ( 350 , 300 ), SF . vector2 ( 300 , 200 )) These two definitions are equivalent: Both views will show the same area of the 2D world, a 300x200 rectangle centered on the point (350, 300). If you don't want to define the view upon construction or want to modify it later, you can use the equivalent setters: view1 . reset ( SF . float_rect ( 200 , 200 , 300 , 200 )) view2 . center = SF . vector2 ( 350 , 300 ) view2 . size = SF . vector2 ( 200 , 200 ) Once your view is defined, you can transform it to make it show a translated/rotated/scaled version of your 2D world.","title":"Defining what the view views"},{"location":"tutorials/graphics/view.html#moving-scrolling-the-view","text":"Unlike drawable entities, such as sprites or shapes whose positions are defined by their top-left corner (and can be changed to any other point), views are always manipulated by their center -- this is simply more convenient. That's why the method to change the position of a view is named center= , and not position= . # move the view at point (200, 200) view . center = SF . vector2 ( 200 , 200 ) # move the view by an offset of (100, 100) (so its final position is (300, 300)) view . move ( SF . vector2 ( 100 , 100 ))","title":"Moving (scrolling) the view"},{"location":"tutorials/graphics/view.html#rotating-the-view","text":"To rotate a view, use the rotation= method. # rotate the view at 20 degrees view . rotation = 20 # rotate the view by 5 degrees relatively to its current orientation (so its final orientation is 25 degrees) view . rotate ( 5 )","title":"Rotating the view"},{"location":"tutorials/graphics/view.html#zooming-scaling-the-view","text":"Zooming in (or out) a view is done through to resizing it, so the method to use is size= . # resize the view to show a 1200x800 area (we see a bigger area, so this is a zoom out) view . size = SF . vector2 ( 1200 , 800 ) # zoom the view relatively to its current size (apply a factor 0.5, so its final size is 600x400) view . zoom ( 0.5 )","title":"Zooming (scaling) the view"},{"location":"tutorials/graphics/view.html#defining-how-the-view-is-viewed","text":"Now that you've defined which part of the 2D world is seen in the window, let's define where it is shown. By default, the viewed contents occupy the full window. If the view has the same size as the window, everything is rendered 1:1. If the view is smaller or larger than the window, everything is scaled to fit in the window. This default behavior is suitable for most situations, but it might need to be changed sometimes. For example, to split the screen in a multiplayer game, you may want to use two views which each only occupy half of the window. You can also implement a minimap by drawing your entire world to a view which is rendered in a small area in a corner of the window. The area in which the contents of the view is shown is called the viewport . To set the viewport of a view, you can use the viewport= method. # define a centered viewport, with half the size of the window view . viewport = SF . float_rect ( 0.25 , 0.25 , 0.5 , 0.5 ) You might have noticed something very important: The viewport is not defined in pixels, but instead as a ratio of the window size. This is more convenient: It allows you to not have to track resize events in order to update the size of the viewport every time the size of the window changes. It is also more intuitive: You would probably define your viewport as a fraction of the entire window area anyway, not as a fixed-size rectangle. Using a viewport, it is straightforward to split the screen for multiplayer games: # player 1 (left side of the screen) player1_view . viewport = SF . float_rect ( 0 , 0 , 0.5 , 1 ) # player 2 (right side of the screen) player2_view . viewport = SF . float_rect ( 0.5 , 0 , 0.5 , 1 ) ... or a mini-map: # the game view (full window) game_view . viewport = SF . float_rect ( 0 , 0 , 1 , 1 ) # mini-map (upper-right corner) minimap_view . viewport = SF . float_rect ( 0.75 , 0 , 0.25 , 0.25 )","title":"Defining how the view is viewed"},{"location":"tutorials/graphics/view.html#using-a-view","text":"To draw something using a view, you must draw it after calling the view= method of the target to which you are drawing ( SF::RenderWindow or SF::RenderTexture ). # let's define a view view = SF :: View . new ( SF . float_rect ( 0 , 0 , 1000 , 600 )) # activate it window . view = view # draw something to that view window . draw ( some_sprite ) # want to do visibility checks? retrieve the view current_view = window . view ... The view remains active until you set another one. This means that there is always a view which defines what appears in the target, and where it is drawn. If you don't explicitly set any view, the render-target uses its own default view, which matches its size 1:1. You can get the default view of a render-target with the default_view method. This can be useful if you want to define your own view based on it, or restore it to draw fixed entities (like a GUI) on top of your scene. # create a view half the size of the default view view = window . default_view view . zoom ( 0.5 ) window . view = view # restore the default view window . view = window . default_view When you call view= , the render-target makes a copy of the view, and doesn't store a pointer to the one that is passed. This means that whenever you update your view, you need to call view= again to apply the modifications. Don't be afraid to copy views or create them on the fly, they aren't expensive objects (they just hold a few floats).","title":"Using a view"},{"location":"tutorials/graphics/view.html#showing-more-when-the-window-is-resized","text":"Since the default view never changes after the window is created, the viewed contents are always the same. So when the window is resized, everything is squeezed/stretched to the new size. If, instead of this default behavior, you'd like to show more/less stuff depending on the new size of the window, all you have to do is update the size of the view with the size of the window. # the event loop while event = window . poll_event ... # catch the resize events if event . is_a? SF :: Event :: Resized # update the view to the new size of the window visible_area = SF . float_rect ( 0 , 0 , event . width , event . height ) window . view = SF :: View . new ( visible_area ) end end","title":"Showing more when the window is resized"},{"location":"tutorials/graphics/view.html#coordinates-conversions","text":"When you use a custom view, or when you resize the window without using the code above, pixels displayed on the target no longer match units in the 2D world. For example, clicking on pixel (10, 50) may hit the point (26.5, -84) of your world. You end up having to use a conversion method to map your pixel coordinates to world coordinates: map_pixel_to_coords . # get the current mouse position in the window pixel_pos = SF :: Mouse . get_position ( window ) # convert it to world coordinates world_pos = window . map_pixel_to_coords ( pixel_pos , window . view ) By default, map_pixel_to_coords uses the current view. If you want to convert the coordinates using view which is not the active one, you can pass it as an additional argument to the method. The opposite, converting world coordinates to pixel coordinates, is also possible with the map_coords_to_pixel method.","title":"Coordinates conversions"},{"location":"tutorials/network/ftp.html","text":"File transfers with FTP # FTP for dummies # If you know what FTP is, and just want to know how to use the FTP class that SFML provides, you can skip this section. FTP ( File Transfer Protocol ) is a simple protocol that allows manipulation of files and directories on a remote server. The protocol consists of commands such as \"create directory\", \"delete file\", \"download file\", etc. You can't send FTP commands to any remote computer, it needs to have an FTP server running which can understand and execute the commands that clients send. So what can you do with FTP, and how can it be helpful to your program? Basically, with FTP you can access existing remote file systems, or even create your own. This can be useful if you want your network game to download resources (maps, images, ...) from a server, or your program to update itself automatically when it's connected to the internet. If you want to know more about the FTP protocol, the Wikipedia article provides more detailed information than this short introduction. The FTP client class # The class provided by CrSFML is SF::Ftp (surprising, isn't it?). It's a client, which means that it can connect to an FTP server, send commands to it and upload or download files. Every method of the SF::Ftp class wraps an FTP command, and returns a standard FTP response. An FTP response contains a status code (similar to HTTP status codes but not identical), and a message that informs the user of what happened. FTP responses are encapsulated in the SF::Ftp::Response class. ftp = SF :: Ftp . new ... response = ftp . login ( \"username\" , \"password\" ) # just an example, could be any method puts \"Response status: #{ response . status } \" puts \"Response message: #{ response . message } \" The status code can be used to check whether the command was successful or failed: Codes lower than 400 represent success, all others represent errors. You can use the ok? method as a shortcut to test a status code for success. response = ftp . login ( \"username\" , \"password\" ) if response . ok? # success! else # error... end If you don't care about the details of the response, you can check for success with even less code: if ftp . login ( \"username\" , \"password\" ) . ok? # success! else # error... end For readability, these checks won't be performed in the following examples in this tutorial. Don't forget to perform them in your code! Now that you understand how the class works, let's have a look at what it can do. Connecting to the FTP server # The first thing to do is connect to an FTP server. ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address ) The server address can be any valid SF::IpAddress : A URL, an IP address, a network name, ... The standard port for FTP is 21. If, for some reason, your server uses a different port, you can specify it as an additional argument: ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address , 45000 ) You can also pass a third parameter, which is a time out value. This prevents you from having to wait forever (or at least a very long time) if the server doesn't respond. ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address , 21 , SF . seconds ( 5 )) Once you're connected to the server, the next step is to authenticate yourself: # authenticate with name and password ftp . login ( \"username\" , \"password\" ) # or login anonymously, if the server allows it ftp . login FTP commands # Here is a short description of all the commands available in the SF::Ftp class. Remember one thing: All these commands are performed relative to the current working directory , exactly as if you were executing file or directory commands in a console on your operating system. Getting the current working directory: response = ftp . working_directory if response . ok? puts \"Current directory: \" + response . directory end SF::Ftp::DirectoryResponse is a specialized SF::Ftp::Response that also contains the requested directory. Getting the list of directories and files contained in the current directory: response = ftp . get_directory_listing if response . ok? listing = response . listing listing . each do | item | puts \"- \" + item end end # you can also get the listing of a sub-directory of the current directory: response = ftp . get_directory_listing ( \"subfolder\" ) SF::Ftp::ListingResponse is a specialized SF::Ftp::Response that also contains the requested directory/file names. Changing the current directory: ftp . change_directory ( \"path/to/new_directory\" ) # the given path is relative to the current directory Going to the parent directory of the current one: ftp . parent_directory Creating a new directory (as a child of the current one): ftp . create_directory ( \"name_of_new_directory\" ) Deleting an existing directory: ftp . delete_directory ( \"name_of_directory_to_delete\" ) Renaming an existing file: ftp . rename_file ( \"old_name.txt\" , \"new_name.txt\" ) Deleting an existing file: ftp . delete_file ( \"file_name.txt\" ) Downloading (receiving from the server) a file: ftp . download ( \"remote_file_name.txt\" , \"local/destination/path\" , SF :: Ftp :: Ascii ) The last argument is the transfer mode. It can be either Ascii (for text files), Ebcdic (for text files using the EBCDIC character set) or Binary (for non-text files). The Ascii and Ebcdic modes can transform the file (line endings, encoding) during the transfer to match the client environment. The Binary mode is a direct byte-for-byte transfer. Uploading (sending to the server) a file: ftp . upload ( \"local_file_name.pdf\" , \"remote/destination/path\" , SF :: Ftp :: Binary ) FTP servers usually close connections that are inactive for a while. If you want to avoid being disconnected, you can send a no-op command periodically: ftp . keep_alive () Disconnecting from the FTP server # You can close the connection with the server at any moment with the disconnect method. ftp . disconnect ()","title":"File transfers with FTP"},{"location":"tutorials/network/ftp.html#file-transfers-with-ftp","text":"","title":"File transfers with FTP"},{"location":"tutorials/network/ftp.html#ftp-for-dummies","text":"If you know what FTP is, and just want to know how to use the FTP class that SFML provides, you can skip this section. FTP ( File Transfer Protocol ) is a simple protocol that allows manipulation of files and directories on a remote server. The protocol consists of commands such as \"create directory\", \"delete file\", \"download file\", etc. You can't send FTP commands to any remote computer, it needs to have an FTP server running which can understand and execute the commands that clients send. So what can you do with FTP, and how can it be helpful to your program? Basically, with FTP you can access existing remote file systems, or even create your own. This can be useful if you want your network game to download resources (maps, images, ...) from a server, or your program to update itself automatically when it's connected to the internet. If you want to know more about the FTP protocol, the Wikipedia article provides more detailed information than this short introduction.","title":"FTP for dummies"},{"location":"tutorials/network/ftp.html#the-ftp-client-class","text":"The class provided by CrSFML is SF::Ftp (surprising, isn't it?). It's a client, which means that it can connect to an FTP server, send commands to it and upload or download files. Every method of the SF::Ftp class wraps an FTP command, and returns a standard FTP response. An FTP response contains a status code (similar to HTTP status codes but not identical), and a message that informs the user of what happened. FTP responses are encapsulated in the SF::Ftp::Response class. ftp = SF :: Ftp . new ... response = ftp . login ( \"username\" , \"password\" ) # just an example, could be any method puts \"Response status: #{ response . status } \" puts \"Response message: #{ response . message } \" The status code can be used to check whether the command was successful or failed: Codes lower than 400 represent success, all others represent errors. You can use the ok? method as a shortcut to test a status code for success. response = ftp . login ( \"username\" , \"password\" ) if response . ok? # success! else # error... end If you don't care about the details of the response, you can check for success with even less code: if ftp . login ( \"username\" , \"password\" ) . ok? # success! else # error... end For readability, these checks won't be performed in the following examples in this tutorial. Don't forget to perform them in your code! Now that you understand how the class works, let's have a look at what it can do.","title":"The FTP client class"},{"location":"tutorials/network/ftp.html#connecting-to-the-ftp-server","text":"The first thing to do is connect to an FTP server. ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address ) The server address can be any valid SF::IpAddress : A URL, an IP address, a network name, ... The standard port for FTP is 21. If, for some reason, your server uses a different port, you can specify it as an additional argument: ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address , 45000 ) You can also pass a third parameter, which is a time out value. This prevents you from having to wait forever (or at least a very long time) if the server doesn't respond. ftp = SF :: Ftp . new ip_address = SF :: IpAddress . new ( \"ftp.myserver.org\" ) ftp . connect ( ip_address , 21 , SF . seconds ( 5 )) Once you're connected to the server, the next step is to authenticate yourself: # authenticate with name and password ftp . login ( \"username\" , \"password\" ) # or login anonymously, if the server allows it ftp . login","title":"Connecting to the FTP server"},{"location":"tutorials/network/ftp.html#ftp-commands","text":"Here is a short description of all the commands available in the SF::Ftp class. Remember one thing: All these commands are performed relative to the current working directory , exactly as if you were executing file or directory commands in a console on your operating system. Getting the current working directory: response = ftp . working_directory if response . ok? puts \"Current directory: \" + response . directory end SF::Ftp::DirectoryResponse is a specialized SF::Ftp::Response that also contains the requested directory. Getting the list of directories and files contained in the current directory: response = ftp . get_directory_listing if response . ok? listing = response . listing listing . each do | item | puts \"- \" + item end end # you can also get the listing of a sub-directory of the current directory: response = ftp . get_directory_listing ( \"subfolder\" ) SF::Ftp::ListingResponse is a specialized SF::Ftp::Response that also contains the requested directory/file names. Changing the current directory: ftp . change_directory ( \"path/to/new_directory\" ) # the given path is relative to the current directory Going to the parent directory of the current one: ftp . parent_directory Creating a new directory (as a child of the current one): ftp . create_directory ( \"name_of_new_directory\" ) Deleting an existing directory: ftp . delete_directory ( \"name_of_directory_to_delete\" ) Renaming an existing file: ftp . rename_file ( \"old_name.txt\" , \"new_name.txt\" ) Deleting an existing file: ftp . delete_file ( \"file_name.txt\" ) Downloading (receiving from the server) a file: ftp . download ( \"remote_file_name.txt\" , \"local/destination/path\" , SF :: Ftp :: Ascii ) The last argument is the transfer mode. It can be either Ascii (for text files), Ebcdic (for text files using the EBCDIC character set) or Binary (for non-text files). The Ascii and Ebcdic modes can transform the file (line endings, encoding) during the transfer to match the client environment. The Binary mode is a direct byte-for-byte transfer. Uploading (sending to the server) a file: ftp . upload ( \"local_file_name.pdf\" , \"remote/destination/path\" , SF :: Ftp :: Binary ) FTP servers usually close connections that are inactive for a while. If you want to avoid being disconnected, you can send a no-op command periodically: ftp . keep_alive ()","title":"FTP commands"},{"location":"tutorials/network/ftp.html#disconnecting-from-the-ftp-server","text":"You can close the connection with the server at any moment with the disconnect method. ftp . disconnect ()","title":"Disconnecting from the FTP server"},{"location":"tutorials/network/http.html","text":"Web requests with HTTP # Relevant example: shader Introduction # CrSFML provides a simple HTTP client class which you can use to communicate with HTTP servers. \"Simple\" means that it supports the most basic features of HTTP: POST, GET and HEAD request types, accessing HTTP header fields, and reading/writing the pages body. If you need more advanced features, such as secured HTTP (HTTPS) for example, you're better off using a true HTTP library. For basic interaction between your program and an HTTP server, it should be enough. SF::Http # To communicate with an HTTP server you must use the SF::Http class. http = SF :: Http . new http . set_host ( \"http://example.org/\" ) # or http = SF :: Http . new ( \"http://example.org/\" ) Note that setting the host doesn't trigger any connection. A temporary connection is created for each request. The only other method in SF::Http , sends requests. This is basically all that the class does. request = SF :: Http :: Request . new # fill the request... response = http . send_request ( request ) Requests # An HTTP request, represented by the SF::Http::Request class, contains the following information: The method: POST (send content), GET (retrieve a resource), HEAD (retrieve a resource header, without its body) The URI: the address of the resource (page, image, ...) to get/post, relative to the root directory The HTTP version (it is 1.0 by default but you can choose a different version if you use specific features) The header: a set of fields with key and value The body of the page (used only with the POST method) request = SF :: Http :: Request . new request . method = SF :: Http :: Request :: Post request . uri = \"/index.html\" request . set_http_version ( 1 , 1 ) # HTTP 1.1 request . set_field ( \"From\" , \"me\" ) request . set_field ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) request . body = \"para1=value1&param2=value2\" response = http . send_request ( request ) SFML automatically fills mandatory header fields, such as \"Host\", \"Content-Length\", etc. You can send your requests without worrying about them. SFML will do its best to make sure they are valid. Responses # If the SF::Http class could successfully connect to the host and send the request, a response is sent back and returned to the user, encapsulated in an instance of the SF::Http::Response class. Responses contain the following members: A status code which precisely indicates how the server processed the request (OK, redirected, not found, etc.) The HTTP version of the server The header: a set of fields with key and value The body of the response response = http . send_request ( request ) puts \"Status: #{ response . status } \" puts \"HTTP version: #{ response . major_http_version } . #{ response . minor_http_version } \" puts \"Content-Type header: \" + response . get_field ( \"Content-Type\" ) puts \"Body: \\n \" + response . body The status code can be used to check whether the request was successfully processed or not: codes 2xx represent success, codes 3xx represent a redirection, codes 4xx represent client errors, codes 5xx represent server errors, and codes 10xx represent SFML specific errors which are not part of the HTTP standard. Example: sending scores to an online server # Here is a short example that demonstrates how to perform a simple task: Sending a score to an online database. def send_score ( score , name ) # prepare the request request = SF :: Http :: Request . new ( \"/send-score.html\" , SF :: Http :: Request :: Post ) # encode the parameters in the request body request . body = \"name=\" + name + \"&score=\" + score # send the request http = SF :: Http . new ( \"http://www.myserver.com/\" ) response = http . send_request ( request ) # check the status if response . status . ok? # check the contents of the response puts response . body else puts \"request failed\" end end Of course, this is a very simple way to handle online scores. There's no protection: Anybody could easily send a false score. A more robust approach would probably involve an extra parameter, like a hash code that ensures that the request was sent by the program. That is beyond the scope of this tutorial. And finally, here is a very simple example of what the PHP page on server might look like. <?php $name = $_POST [ 'name' ]; $score = $_POST [ 'score' ]; if ( write_to_database ( $name , $score )) { // this is not a PHP tutorial :) echo 'name and score added!' ; } else { echo 'failed to write name and score to database...' ; }","title":"Web requests with HTTP"},{"location":"tutorials/network/http.html#web-requests-with-http","text":"Relevant example: shader","title":"Web requests with HTTP"},{"location":"tutorials/network/http.html#introduction","text":"CrSFML provides a simple HTTP client class which you can use to communicate with HTTP servers. \"Simple\" means that it supports the most basic features of HTTP: POST, GET and HEAD request types, accessing HTTP header fields, and reading/writing the pages body. If you need more advanced features, such as secured HTTP (HTTPS) for example, you're better off using a true HTTP library. For basic interaction between your program and an HTTP server, it should be enough.","title":"Introduction"},{"location":"tutorials/network/http.html#sfhttp","text":"To communicate with an HTTP server you must use the SF::Http class. http = SF :: Http . new http . set_host ( \"http://example.org/\" ) # or http = SF :: Http . new ( \"http://example.org/\" ) Note that setting the host doesn't trigger any connection. A temporary connection is created for each request. The only other method in SF::Http , sends requests. This is basically all that the class does. request = SF :: Http :: Request . new # fill the request... response = http . send_request ( request )","title":"SF::Http"},{"location":"tutorials/network/http.html#requests","text":"An HTTP request, represented by the SF::Http::Request class, contains the following information: The method: POST (send content), GET (retrieve a resource), HEAD (retrieve a resource header, without its body) The URI: the address of the resource (page, image, ...) to get/post, relative to the root directory The HTTP version (it is 1.0 by default but you can choose a different version if you use specific features) The header: a set of fields with key and value The body of the page (used only with the POST method) request = SF :: Http :: Request . new request . method = SF :: Http :: Request :: Post request . uri = \"/index.html\" request . set_http_version ( 1 , 1 ) # HTTP 1.1 request . set_field ( \"From\" , \"me\" ) request . set_field ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) request . body = \"para1=value1&param2=value2\" response = http . send_request ( request ) SFML automatically fills mandatory header fields, such as \"Host\", \"Content-Length\", etc. You can send your requests without worrying about them. SFML will do its best to make sure they are valid.","title":"Requests"},{"location":"tutorials/network/http.html#responses","text":"If the SF::Http class could successfully connect to the host and send the request, a response is sent back and returned to the user, encapsulated in an instance of the SF::Http::Response class. Responses contain the following members: A status code which precisely indicates how the server processed the request (OK, redirected, not found, etc.) The HTTP version of the server The header: a set of fields with key and value The body of the response response = http . send_request ( request ) puts \"Status: #{ response . status } \" puts \"HTTP version: #{ response . major_http_version } . #{ response . minor_http_version } \" puts \"Content-Type header: \" + response . get_field ( \"Content-Type\" ) puts \"Body: \\n \" + response . body The status code can be used to check whether the request was successfully processed or not: codes 2xx represent success, codes 3xx represent a redirection, codes 4xx represent client errors, codes 5xx represent server errors, and codes 10xx represent SFML specific errors which are not part of the HTTP standard.","title":"Responses"},{"location":"tutorials/network/http.html#example-sending-scores-to-an-online-server","text":"Here is a short example that demonstrates how to perform a simple task: Sending a score to an online database. def send_score ( score , name ) # prepare the request request = SF :: Http :: Request . new ( \"/send-score.html\" , SF :: Http :: Request :: Post ) # encode the parameters in the request body request . body = \"name=\" + name + \"&score=\" + score # send the request http = SF :: Http . new ( \"http://www.myserver.com/\" ) response = http . send_request ( request ) # check the status if response . status . ok? # check the contents of the response puts response . body else puts \"request failed\" end end Of course, this is a very simple way to handle online scores. There's no protection: Anybody could easily send a false score. A more robust approach would probably involve an extra parameter, like a hash code that ensures that the request was sent by the program. That is beyond the scope of this tutorial. And finally, here is a very simple example of what the PHP page on server might look like. <?php $name = $_POST [ 'name' ]; $score = $_POST [ 'score' ]; if ( write_to_database ( $name , $score )) { // this is not a PHP tutorial :) echo 'name and score added!' ; } else { echo 'failed to write name and score to database...' ; }","title":"Example: sending scores to an online server"},{"location":"tutorials/network/packet.html","text":"Using packets # Problems that need to be solved # Exchanging data on a network is more tricky than it seems. The reason is that different machines, with different operating systems and processors, can be involved. Several problems arise if you want to exchange data reliably between these different machines. The first problem is the endianness. The endianness is the order in which a particular processor interprets the bytes of primitive types that occupy more than a single byte (integers and floating point numbers). There are two main families: \"big endian\" processors, which store the most significant byte first, and \"little endian\" processors, which store the least significant byte first. There are other, more exotic byte orders, but you'll probably never have to deal with them. The problem is obvious: If you send a variable between two computers whose endianness doesn't match, they won't see the same value. For example, the 16-bit integer \"42\" in big endian notation is 00000000 00101010, but if you send this to a little endian machine, it will be interpreted as \"10752\". The second problem is specific to how the TCP protocol works. Because it doesn't preserve message boundaries, and can split or combine chunks of data, receivers must properly reconstruct incoming messages before interpreting them. Otherwise bad things might happen, like reading incomplete variables, or ignoring useful bytes. You may of course face other problems with network programming, but these are the lowest-level ones, that almost everybody will have to solve. This is the reason why SFML provides some simple tools to avoid them. Packets # The two problems (endianness and message boundaries) are solved by using a specific class to pack your data: SF::Packet . As a bonus, it provides a much nicer interface than plain old byte arrays. # on sending side x = 10_u16 s = \"hello\" d = 0.6_f64 packet = SF :: Packet . new () packet . write ( x ) packet . write ( s ) packet . write ( d ) # on receiving side x = packet . read ( UInt16 ) s = packet . read ( String ) d = packet . read ( Float64 ) pp x , s , d Unlike writing, reading from a packet can fail if you try to extract more bytes than the packet contains. If a reading operation fails, the packet error flag is set. To check the error flag of a packet, use the valid? method: x = packet . read ( Int32 ) unless packet . valid? # error end Sending and receiving packets is as easy as sending/receiving an array of bytes: sockets have send and receive methods that directly accept a SF::Packet . # with a TCP socket status = tcp_socket . send ( packet ) packet = SF :: Packet . new status = tcp_socket . receive ( packet ) # with a UDP socket status = udp_socket . send ( packet , recipient_address , recipient_port ) packet = SF :: Packet . new status , sender_address , sender_port = udp_socket . receive ( packet ) Packets solve the \"message boundaries\" problem, which means that when you send a packet on a TCP socket, you receive the exact same packet on the other end, it cannot contain less bytes, or bytes from the next packet that you send. However, it has a slight drawback: To preserve message boundaries, SF::Packet has to send some extra bytes along with your data, which implies that you can only receive them with a SF::Packet if you want them to be properly decoded. Simply put, you can't send an SFML packet to a non-SFML packet recipient, it has to use an SFML packet for receiving too. Note that this applies to TCP only, UDP is fine since the protocol itself preserves message boundaries. Extending packets to handle user types # Packets have overloads of their methods for the most common primitive types and the most common standard types, but what about your own classes? It is easy to subclass or reopen SF::Packet and add your own overloads. record Character , age : UInt8 , name : String , weight : Float32 class SF:: Packet def write ( c : Character ) write c . age write c . name write c . weight end def read ( type : Character . class ) : Character Character . new ( read ( UInt8 ), read ( String ), read ( Float32 )) end end Now that these methods are defined, you can insert/extract a Character instance to/from a packet like any other primitive type: bob = Character . new ( 65_u8 , \"Bob\" , 12.34_f32 ) packet . write ( bob ) packet . read ( Character )","title":"Using packets"},{"location":"tutorials/network/packet.html#using-packets","text":"","title":"Using packets"},{"location":"tutorials/network/packet.html#problems-that-need-to-be-solved","text":"Exchanging data on a network is more tricky than it seems. The reason is that different machines, with different operating systems and processors, can be involved. Several problems arise if you want to exchange data reliably between these different machines. The first problem is the endianness. The endianness is the order in which a particular processor interprets the bytes of primitive types that occupy more than a single byte (integers and floating point numbers). There are two main families: \"big endian\" processors, which store the most significant byte first, and \"little endian\" processors, which store the least significant byte first. There are other, more exotic byte orders, but you'll probably never have to deal with them. The problem is obvious: If you send a variable between two computers whose endianness doesn't match, they won't see the same value. For example, the 16-bit integer \"42\" in big endian notation is 00000000 00101010, but if you send this to a little endian machine, it will be interpreted as \"10752\". The second problem is specific to how the TCP protocol works. Because it doesn't preserve message boundaries, and can split or combine chunks of data, receivers must properly reconstruct incoming messages before interpreting them. Otherwise bad things might happen, like reading incomplete variables, or ignoring useful bytes. You may of course face other problems with network programming, but these are the lowest-level ones, that almost everybody will have to solve. This is the reason why SFML provides some simple tools to avoid them.","title":"Problems that need to be solved"},{"location":"tutorials/network/packet.html#packets","text":"The two problems (endianness and message boundaries) are solved by using a specific class to pack your data: SF::Packet . As a bonus, it provides a much nicer interface than plain old byte arrays. # on sending side x = 10_u16 s = \"hello\" d = 0.6_f64 packet = SF :: Packet . new () packet . write ( x ) packet . write ( s ) packet . write ( d ) # on receiving side x = packet . read ( UInt16 ) s = packet . read ( String ) d = packet . read ( Float64 ) pp x , s , d Unlike writing, reading from a packet can fail if you try to extract more bytes than the packet contains. If a reading operation fails, the packet error flag is set. To check the error flag of a packet, use the valid? method: x = packet . read ( Int32 ) unless packet . valid? # error end Sending and receiving packets is as easy as sending/receiving an array of bytes: sockets have send and receive methods that directly accept a SF::Packet . # with a TCP socket status = tcp_socket . send ( packet ) packet = SF :: Packet . new status = tcp_socket . receive ( packet ) # with a UDP socket status = udp_socket . send ( packet , recipient_address , recipient_port ) packet = SF :: Packet . new status , sender_address , sender_port = udp_socket . receive ( packet ) Packets solve the \"message boundaries\" problem, which means that when you send a packet on a TCP socket, you receive the exact same packet on the other end, it cannot contain less bytes, or bytes from the next packet that you send. However, it has a slight drawback: To preserve message boundaries, SF::Packet has to send some extra bytes along with your data, which implies that you can only receive them with a SF::Packet if you want them to be properly decoded. Simply put, you can't send an SFML packet to a non-SFML packet recipient, it has to use an SFML packet for receiving too. Note that this applies to TCP only, UDP is fine since the protocol itself preserves message boundaries.","title":"Packets"},{"location":"tutorials/network/packet.html#extending-packets-to-handle-user-types","text":"Packets have overloads of their methods for the most common primitive types and the most common standard types, but what about your own classes? It is easy to subclass or reopen SF::Packet and add your own overloads. record Character , age : UInt8 , name : String , weight : Float32 class SF:: Packet def write ( c : Character ) write c . age write c . name write c . weight end def read ( type : Character . class ) : Character Character . new ( read ( UInt8 ), read ( String ), read ( Float32 )) end end Now that these methods are defined, you can insert/extract a Character instance to/from a packet like any other primitive type: bob = Character . new ( 65_u8 , \"Bob\" , 12.34_f32 ) packet . write ( bob ) packet . read ( Character )","title":"Extending packets to handle user types"},{"location":"tutorials/network/socket.html","text":"Communicating with sockets # Sockets # A socket is the interface between your application and the outside world: through a socket, you can send and receive data. Therefore, any network program will most likely have to deal with sockets, they are the central element of network communication. There are several kinds of sockets, each providing specific features. SFML implements the most common ones: TCP sockets and UDP sockets. TCP vs UDP # It is important to know what TCP and UDP sockets can do, and what they can't do, so that you can choose the best socket type according to the requirements of your application. The main difference is that TCP sockets are connection-based. You can't send or receive anything until you are connected to another TCP socket on the remote machine. Once connected, a TCP socket can only send and receive to/from the remote machine. This means that you'll need one TCP socket for each client in your application. UDP is not connection-based, you can send and receive to/from anyone at any time with the same socket. The second difference is that TCP is reliable unlike UDP. It ensures that what you send is always received, without corruption and in the same order. UDP performs less checks, and doesn't provide any reliability: what you send might be received multiple times (duplication), or in a different order, or be lost and never reach the remote computer. However, UDP does guarantee that data which is received is always valid (not corrupted). UDP may seem scary, but keep in mind that almost all the time , data arrives correctly and in the right order. The third difference is a direct consequence of the second one: UDP is faster and more lightweight than TCP. Because it has less requirements, thus less overhead. The last difference is about the way data is transported. TCP is a stream protocol: there's no message boundary, if you send \"Hello\" and then \"SFML\", the remote machine might receive \"HelloSFML\", \"Hel\" + \"loSFML\", or even \"He\" + \"loS\" + \"FML\". UDP is a datagram protocol. Datagrams are packets that can't be mixed with each other. If you receive a datagram with UDP, it is guaranteed to be exactly the same as it was sent. Oh, and one last thing: since UDP is not connection-based, it allows broadcasting messages to multiple recipients, or even to an entire network. The one-to-one communication of TCP sockets doesn't allow that. Connecting a TCP socket # As you can guess, this part is specific to TCP sockets. There are two sides to a connection: the one that waits for the incoming connection (let's call it the server), and the one that triggers it (let's call it the client). On client side, things are simple: the user just needs to have a SF::TcpSocket and call its connect method to start the connection attempt. require \"crsfml/network\" socket = SF :: TcpSocket . new status = socket . connect ( SF :: IpAddress . new ( \"192.168.0.5\" ), 53000 ) unless status == SF :: Socket :: Done # error end The first argument is the address of the host to connect to. It is an SF::IpAddress , which can represent any valid address: a URL, an IP address, or a network host name. See its documentation for more details. The second argument is the port to connect to on the remote machine. The connection will succeed only if the server is accepting connections on that port. There's an optional third argument, a time out value. If set, and the connection attempt doesn't succeed before the time out is over, the method returns an error. If not specified, the default operating system time out is used. Once connected, you can retrieve the address and port of the remote computer if needed, with the remote_address and remote_port methods. All methods of socket classes are blocking by default. This means that your program (more specifically the thread that contains the method call) will be stuck until the operation is complete. This is important because some methods may take very long: For example, trying to connect to an unreachable host will only return after a few seconds, receiving will wait until there's data available, etc. You can change this behavior and make all methods non-blocking by using the blocking= method of the socket. See the next chapters for more details. On the server side, a few more things have to be done. Multiple sockets are required: One that listens for incoming connections, and one for each connected client. To listen for connections, you must use the special SF::TcpListener class. Its only role is to wait for incoming connection attempts on a given port, it can't send or receive data. listener = SF :: TcpListener . new # bind the listener to a port unless listener . listen ( 53000 ) == SF :: Socket :: Done # error... end # accept a new connection client = SF :: TcpSocket . new unless listener . accept ( client ) == SF :: Socket :: Done # error... end # use \"client\" to communicate with the connected client, # and continue to accept new connections with the listener The accept method blocks until a connection attempt arrives (unless the socket is configured as non-blocking). When it happens, it initializes the given socket and returns. The socket can now be used to communicate with the new client, and the listener can go back to waiting for another connection attempt. After a successful call to connect (on client side) and accept (on server side), the communication is established and both sockets are ready to exchange data. Binding a UDP socket # UDP sockets need not be connected, however you need to bind them to a specific port if you want to be able to receive data on that port. A UDP socket cannot receive on multiple ports simultaneously. socket = SF :: UdpSocket . new # bind the socket to a port unless socket . bind ( 54000 ) == SF :: Socket :: Done # error... end After binding the socket to a port, it's ready to receive data on that port. If you want the operating system to bind the socket to a free port automatically, you can pass SF::Socket::AnyPort , and then retrieve the chosen port with socket.local_port . UDP sockets that send data don't need to do anything before sending. Sending and receiving data # Sending and receiving data is done in the same way for both types of sockets. The only difference is that UDP has two extra arguments: the address and port of the sender/recipient. There are two different methods for each operation: the low-level one, that sends/receives a raw array of bytes, and the higher-level one, which uses the SF::Packet class. See the tutorial on packets for more details about this class. In this tutorial, we'll only explain the low-level methods. To send data, you must call the send method with a pointer to the data that you want to send, and the number of bytes to send. data = Slice . new ( 77 ) { rand ( 256 ) . to_u8 } # TCP socket: unless socket . send ( data ) == SF :: Socket :: Done # error end # UDP socket: recipient = SF :: IpAddress . new ( \"192.168.0.5\" ) port = 54000 unless socket . send ( data , recipient , port ) == SF :: Socket :: Done # error end The send methods take a data slice, so you can pass the address of anything. However, it is generally a bad idea to send something other than an array of bytes because native types with a size larger than 1 byte are not guaranteed to be the same on every machine: Types such as int or long may have a different size, and/or a different endianness. Therefore, such types cannot be exchanged reliably across different systems. This problem is explained (and solved) in the tutorial on packets . With UDP you can broadcast a message to an entire sub-network in a single call: to do so you can use the special address SF::IpAddress::Broadcast . There's another thing to keep in mind with UDP: Since data is sent in datagrams and the size of these datagrams has a limit, you are not allowed to exceed it. Every call to send must send less that SF::UdpSocket.max_datagram_size bytes -- which is a little less than 2^16 (65536) bytes. To receive data, you must call the receive method: data = Slice ( UInt8 ) . new ( 100 ) # TCP socket: status , received = socket . receive ( data ) unless status == SF :: Socket :: Done # error end puts \"Received #{ received } bytes\" # UDP socket: status , received , sender , port = socket . receive ( data ) unless status == SF :: Socket :: Done # error... end puts \"Received #{ received } bytes from #{ sender } on port #{ port } \" It is important to keep in mind that if the socket is in blocking mode, receive will wait until something is received, blocking the thread that called it (and thus possibly the whole program). The first two arguments specify the buffer to which the received bytes are to be copied, along with its maximum size. The third argument is a variable that will contain the actual number of bytes received after the method returns. With UDP sockets, the last two arguments will contain the address and port of the sender after the method returns. They can be used later if you want to send a response. These methods are low-level, and you should use them only if you have a very good reason to do so. A more robust and flexible approach involves using packets . Blocking on a group of sockets # Blocking on a single socket can quickly become annoying, because you will most likely have to handle more than one client. You most likely don't want socket A to block your program while socket B has received something that could be processed. What you would like is to block on multiple sockets at once, i.e. waiting until any of them has received something. This is possible with socket selectors, represented by the SF::SocketSelector class. A selector can monitor all types of sockets: SF::TcpSocket , SF::UdpSocket , and SF::TcpListener . To add a socket to a selector, use its add method: socket = SF :: TcpSocket . new selector = SF :: SocketSelector . new selector . add socket A selector is not a socket container. It only references (points to) the sockets that you add, it doesn't store them. There is no way to retrieve or count the sockets that you put inside. Instead, it is up to you to have your own separate socket storage (like an Array ). Once you have filled the selector with all the sockets that you want to monitor, you must call its wait method to wait until any one of them has received something (or has triggered an error). You can also pass an optional time out value, so that the method will fail if nothing has been received after a certain period of time -- this avoids staying stuck forever if nothing happens. if selector . wait SF . seconds ( 10 ) # received something else # timeout reached, nothing was received... end If the wait method returns true , it means that one or more socket(s) have received something, and you can safely call receive on the socket(s) with pending data without having them block. If the socket is a SF::TcpListener , it means that an incoming connection is ready to be accepted and that you can call its accept method without having it block. Since the selector is not a socket container, it cannot return the sockets that are ready to receive. Instead, you must test each candidate socket with the ready? method: if selector . wait SF . seconds ( 10 ) my_sockets . each do | socket | if selector . ready? ( socket ) # this socket is ready, you can receive (or accept if it's a listener) socket . receive ( ... ) end end end You can have a look at the API documentation of the SF::SocketSelector class for a working example of how to use a selector to handle connections and messages from multiple clients. As a bonus, the timeout capability of Selector#wait allows you to implement a receive-with-timeout method, which is not directly available in the socket classes, very easily: def receive_with_timeout ( socket : SF :: TcpSocket , packet : SF :: Packet , timeout : SF :: Time ) selector = SF :: SocketSelector . new selector . add socket if selector . wait ( timeout ) socket . receive ( packet ) else SF :: Socket :: NotReady end end Non-blocking sockets # All sockets are blocking by default, but you can change this behaviour at any time with the setBlocking method. tcp_socket = SF :: TcpSocket . new tcp_socket . blocking = false listener_socket = SF :: TcpListener . new listener_socket . blocking = false udp_socket = SF :: UdpSocket . new udp_socket . blocking = false Once a socket is set as non-blocking, all of its methods always return immediately. For example, receive will return with status SF::Socket::NotReady if there's no data available. Or, accept will return immediately, with the same status, if there's no pending connection. Non-blocking sockets are the easiest solution if you already have a main loop that runs at a constant rate. You can simply check if something happened on your sockets in every iteration, without having to block program execution. When using SF::TcpSocket in non-blocking mode, calls to send are not guaranteed to actually send all the data you pass to it, whether it be as a SF::Packet or as raw data. Make sure to check one of the return values for how much data was actually sent. Regardless of whether you send SF::Packet s or raw data, if only a part of the data was sent in the call, the return status will be SF::Socket::Partial to indicate a partial send. If SF::Socket::Partial is returned, you must make sure to handle the partial send properly or else data corruption will occur. When sending raw data, you must reattempt sending the raw data at the byte offset where the previous send call stopped. When sending SF::Packet s, the byte offset is saved within the SF::Packet itself. In this case, you must make sure to keep attempting to send the exact same unmodified SF::Packet object over and over until a status other than SF::Socket::Partial is returned. Constructing a new SF::Packet object and filling it with the same data will not work, it must be the same object that was previously sent.","title":"Communication using sockets"},{"location":"tutorials/network/socket.html#communicating-with-sockets","text":"","title":"Communicating with sockets"},{"location":"tutorials/network/socket.html#sockets","text":"A socket is the interface between your application and the outside world: through a socket, you can send and receive data. Therefore, any network program will most likely have to deal with sockets, they are the central element of network communication. There are several kinds of sockets, each providing specific features. SFML implements the most common ones: TCP sockets and UDP sockets.","title":"Sockets"},{"location":"tutorials/network/socket.html#tcp-vs-udp","text":"It is important to know what TCP and UDP sockets can do, and what they can't do, so that you can choose the best socket type according to the requirements of your application. The main difference is that TCP sockets are connection-based. You can't send or receive anything until you are connected to another TCP socket on the remote machine. Once connected, a TCP socket can only send and receive to/from the remote machine. This means that you'll need one TCP socket for each client in your application. UDP is not connection-based, you can send and receive to/from anyone at any time with the same socket. The second difference is that TCP is reliable unlike UDP. It ensures that what you send is always received, without corruption and in the same order. UDP performs less checks, and doesn't provide any reliability: what you send might be received multiple times (duplication), or in a different order, or be lost and never reach the remote computer. However, UDP does guarantee that data which is received is always valid (not corrupted). UDP may seem scary, but keep in mind that almost all the time , data arrives correctly and in the right order. The third difference is a direct consequence of the second one: UDP is faster and more lightweight than TCP. Because it has less requirements, thus less overhead. The last difference is about the way data is transported. TCP is a stream protocol: there's no message boundary, if you send \"Hello\" and then \"SFML\", the remote machine might receive \"HelloSFML\", \"Hel\" + \"loSFML\", or even \"He\" + \"loS\" + \"FML\". UDP is a datagram protocol. Datagrams are packets that can't be mixed with each other. If you receive a datagram with UDP, it is guaranteed to be exactly the same as it was sent. Oh, and one last thing: since UDP is not connection-based, it allows broadcasting messages to multiple recipients, or even to an entire network. The one-to-one communication of TCP sockets doesn't allow that.","title":"TCP vs UDP"},{"location":"tutorials/network/socket.html#connecting-a-tcp-socket","text":"As you can guess, this part is specific to TCP sockets. There are two sides to a connection: the one that waits for the incoming connection (let's call it the server), and the one that triggers it (let's call it the client). On client side, things are simple: the user just needs to have a SF::TcpSocket and call its connect method to start the connection attempt. require \"crsfml/network\" socket = SF :: TcpSocket . new status = socket . connect ( SF :: IpAddress . new ( \"192.168.0.5\" ), 53000 ) unless status == SF :: Socket :: Done # error end The first argument is the address of the host to connect to. It is an SF::IpAddress , which can represent any valid address: a URL, an IP address, or a network host name. See its documentation for more details. The second argument is the port to connect to on the remote machine. The connection will succeed only if the server is accepting connections on that port. There's an optional third argument, a time out value. If set, and the connection attempt doesn't succeed before the time out is over, the method returns an error. If not specified, the default operating system time out is used. Once connected, you can retrieve the address and port of the remote computer if needed, with the remote_address and remote_port methods. All methods of socket classes are blocking by default. This means that your program (more specifically the thread that contains the method call) will be stuck until the operation is complete. This is important because some methods may take very long: For example, trying to connect to an unreachable host will only return after a few seconds, receiving will wait until there's data available, etc. You can change this behavior and make all methods non-blocking by using the blocking= method of the socket. See the next chapters for more details. On the server side, a few more things have to be done. Multiple sockets are required: One that listens for incoming connections, and one for each connected client. To listen for connections, you must use the special SF::TcpListener class. Its only role is to wait for incoming connection attempts on a given port, it can't send or receive data. listener = SF :: TcpListener . new # bind the listener to a port unless listener . listen ( 53000 ) == SF :: Socket :: Done # error... end # accept a new connection client = SF :: TcpSocket . new unless listener . accept ( client ) == SF :: Socket :: Done # error... end # use \"client\" to communicate with the connected client, # and continue to accept new connections with the listener The accept method blocks until a connection attempt arrives (unless the socket is configured as non-blocking). When it happens, it initializes the given socket and returns. The socket can now be used to communicate with the new client, and the listener can go back to waiting for another connection attempt. After a successful call to connect (on client side) and accept (on server side), the communication is established and both sockets are ready to exchange data.","title":"Connecting a TCP socket"},{"location":"tutorials/network/socket.html#binding-a-udp-socket","text":"UDP sockets need not be connected, however you need to bind them to a specific port if you want to be able to receive data on that port. A UDP socket cannot receive on multiple ports simultaneously. socket = SF :: UdpSocket . new # bind the socket to a port unless socket . bind ( 54000 ) == SF :: Socket :: Done # error... end After binding the socket to a port, it's ready to receive data on that port. If you want the operating system to bind the socket to a free port automatically, you can pass SF::Socket::AnyPort , and then retrieve the chosen port with socket.local_port . UDP sockets that send data don't need to do anything before sending.","title":"Binding a UDP socket"},{"location":"tutorials/network/socket.html#sending-and-receiving-data","text":"Sending and receiving data is done in the same way for both types of sockets. The only difference is that UDP has two extra arguments: the address and port of the sender/recipient. There are two different methods for each operation: the low-level one, that sends/receives a raw array of bytes, and the higher-level one, which uses the SF::Packet class. See the tutorial on packets for more details about this class. In this tutorial, we'll only explain the low-level methods. To send data, you must call the send method with a pointer to the data that you want to send, and the number of bytes to send. data = Slice . new ( 77 ) { rand ( 256 ) . to_u8 } # TCP socket: unless socket . send ( data ) == SF :: Socket :: Done # error end # UDP socket: recipient = SF :: IpAddress . new ( \"192.168.0.5\" ) port = 54000 unless socket . send ( data , recipient , port ) == SF :: Socket :: Done # error end The send methods take a data slice, so you can pass the address of anything. However, it is generally a bad idea to send something other than an array of bytes because native types with a size larger than 1 byte are not guaranteed to be the same on every machine: Types such as int or long may have a different size, and/or a different endianness. Therefore, such types cannot be exchanged reliably across different systems. This problem is explained (and solved) in the tutorial on packets . With UDP you can broadcast a message to an entire sub-network in a single call: to do so you can use the special address SF::IpAddress::Broadcast . There's another thing to keep in mind with UDP: Since data is sent in datagrams and the size of these datagrams has a limit, you are not allowed to exceed it. Every call to send must send less that SF::UdpSocket.max_datagram_size bytes -- which is a little less than 2^16 (65536) bytes. To receive data, you must call the receive method: data = Slice ( UInt8 ) . new ( 100 ) # TCP socket: status , received = socket . receive ( data ) unless status == SF :: Socket :: Done # error end puts \"Received #{ received } bytes\" # UDP socket: status , received , sender , port = socket . receive ( data ) unless status == SF :: Socket :: Done # error... end puts \"Received #{ received } bytes from #{ sender } on port #{ port } \" It is important to keep in mind that if the socket is in blocking mode, receive will wait until something is received, blocking the thread that called it (and thus possibly the whole program). The first two arguments specify the buffer to which the received bytes are to be copied, along with its maximum size. The third argument is a variable that will contain the actual number of bytes received after the method returns. With UDP sockets, the last two arguments will contain the address and port of the sender after the method returns. They can be used later if you want to send a response. These methods are low-level, and you should use them only if you have a very good reason to do so. A more robust and flexible approach involves using packets .","title":"Sending and receiving data"},{"location":"tutorials/network/socket.html#blocking-on-a-group-of-sockets","text":"Blocking on a single socket can quickly become annoying, because you will most likely have to handle more than one client. You most likely don't want socket A to block your program while socket B has received something that could be processed. What you would like is to block on multiple sockets at once, i.e. waiting until any of them has received something. This is possible with socket selectors, represented by the SF::SocketSelector class. A selector can monitor all types of sockets: SF::TcpSocket , SF::UdpSocket , and SF::TcpListener . To add a socket to a selector, use its add method: socket = SF :: TcpSocket . new selector = SF :: SocketSelector . new selector . add socket A selector is not a socket container. It only references (points to) the sockets that you add, it doesn't store them. There is no way to retrieve or count the sockets that you put inside. Instead, it is up to you to have your own separate socket storage (like an Array ). Once you have filled the selector with all the sockets that you want to monitor, you must call its wait method to wait until any one of them has received something (or has triggered an error). You can also pass an optional time out value, so that the method will fail if nothing has been received after a certain period of time -- this avoids staying stuck forever if nothing happens. if selector . wait SF . seconds ( 10 ) # received something else # timeout reached, nothing was received... end If the wait method returns true , it means that one or more socket(s) have received something, and you can safely call receive on the socket(s) with pending data without having them block. If the socket is a SF::TcpListener , it means that an incoming connection is ready to be accepted and that you can call its accept method without having it block. Since the selector is not a socket container, it cannot return the sockets that are ready to receive. Instead, you must test each candidate socket with the ready? method: if selector . wait SF . seconds ( 10 ) my_sockets . each do | socket | if selector . ready? ( socket ) # this socket is ready, you can receive (or accept if it's a listener) socket . receive ( ... ) end end end You can have a look at the API documentation of the SF::SocketSelector class for a working example of how to use a selector to handle connections and messages from multiple clients. As a bonus, the timeout capability of Selector#wait allows you to implement a receive-with-timeout method, which is not directly available in the socket classes, very easily: def receive_with_timeout ( socket : SF :: TcpSocket , packet : SF :: Packet , timeout : SF :: Time ) selector = SF :: SocketSelector . new selector . add socket if selector . wait ( timeout ) socket . receive ( packet ) else SF :: Socket :: NotReady end end","title":"Blocking on a group of sockets"},{"location":"tutorials/network/socket.html#non-blocking-sockets","text":"All sockets are blocking by default, but you can change this behaviour at any time with the setBlocking method. tcp_socket = SF :: TcpSocket . new tcp_socket . blocking = false listener_socket = SF :: TcpListener . new listener_socket . blocking = false udp_socket = SF :: UdpSocket . new udp_socket . blocking = false Once a socket is set as non-blocking, all of its methods always return immediately. For example, receive will return with status SF::Socket::NotReady if there's no data available. Or, accept will return immediately, with the same status, if there's no pending connection. Non-blocking sockets are the easiest solution if you already have a main loop that runs at a constant rate. You can simply check if something happened on your sockets in every iteration, without having to block program execution. When using SF::TcpSocket in non-blocking mode, calls to send are not guaranteed to actually send all the data you pass to it, whether it be as a SF::Packet or as raw data. Make sure to check one of the return values for how much data was actually sent. Regardless of whether you send SF::Packet s or raw data, if only a part of the data was sent in the call, the return status will be SF::Socket::Partial to indicate a partial send. If SF::Socket::Partial is returned, you must make sure to handle the partial send properly or else data corruption will occur. When sending raw data, you must reattempt sending the raw data at the byte offset where the previous send call stopped. When sending SF::Packet s, the byte offset is saved within the SF::Packet itself. In this case, you must make sure to keep attempting to send the exact same unmodified SF::Packet object over and over until a status other than SF::Socket::Partial is returned. Constructing a new SF::Packet object and filling it with the same data will not work, it must be the same object that was previously sent.","title":"Non-blocking sockets"},{"location":"tutorials/system/stream.html","text":"User data streams # Introduction # SFML has several resource classes: images, fonts, sounds, etc. In most programs, these resources will be loaded from files, with the help of their from_file class method. In a few other situations, resources will be packed directly into the executable or in a big data file, and loaded from memory with from_memory . These methods cover almost all the possible use cases -- but not all. Sometimes you want to load files from unusual places, such as a compressed/encrypted archive, or a remote network location for example. For these special situations, CrSFML provides a third loading method: from_stream . This method reads data using an abstract SF::InputStream interface, which allows you to provide your own implementation of a stream class that works with SFML. In this tutorial you'll learn how to write and use your own derived input stream. InputStream # The SF::InputStream class declares four virtual methods: abstract class InputStream abstract def read ( data : Slice ) : Int64 abstract def seek ( position : Int ) : Int64 abstract def tell () : Int64 abstract def size () : Int64 end read must extract buffer.size bytes of data from the stream, and copy them to the supplied buffer slice. It returns the number of bytes read, or -1 on error. seek must change the current reading position in the stream. Its position argument is the absolute byte offset to jump to (so it is relative to the beginning of the data, not to the current position). It returns the new position, or -1 on error. tell must return the current reading position (in bytes) in the stream, or -1 on error. size must return the total size (in bytes) of the data which is contained in the stream, or -1 on error. To create your own working stream, you must implement every one of these four methods according to their requirements. FileInputStream and MemoryInputStream # SF::FileInputStream provides the read-only data stream of a file, while SF::MemoryInputStream serves the read-only stream from memory. Both are derived from SF::InputStream . Using an InputStream # Using a custom stream class is straight-forward: instantiate it, and pass it to the from_stream class method of the object that you want to load. stream = SF :: FileInputStream . open ( \"image.png\" ) texture = SF :: Texture . from_stream ( stream ) stream = SF :: FileInputStream . open ( \"music.ogg\" ) music = SF :: Music . from_stream ( stream ) string = File . read ( \"image.png\" ) stream = SF :: MemoryInputStream . open ( string . to_slice ) texture = SF :: Texture . from_stream ( stream ) Note that the examples above are redundant, because from_file can be used instead. The real use cases are if you want to implement custom loading of resources. Option 1: read from file, extract into memory, use SF::MemoryInputStream . Option 2: implement a custom stream that reads and extracts on the fly. Examples # If you need a demonstration that helps you focus on how the code works, and not get lost in implementation details, you could take a look at the implementation of SF::FileInputStream or SF::MemoryInputStream . Common mistakes # Some resource classes are not loaded completely after from_stream has been called. Instead, they continue to read from their data source as long as they are used. This is the case for SF::Music , which streams audio samples as they are played, and for SF::Font , which loads glyphs on the fly depending on the text that is displayed. As a consequence, the stream instance that you used to load a music or a font, as well as its data source, must remain alive as long as the resource uses it. If it is destroyed while still being used, it results in undefined behavior (can be a crash, corrupt data, or nothing visible). Another common mistake is to return whatever the internal functions return directly, but sometimes it doesn't match what SFML expects. For example, some function may return 0 on success, but InputStream#seek expects the actual new position to be returned. Also keep in mind that in case of error -1 must be returned.","title":"User data streams"},{"location":"tutorials/system/stream.html#user-data-streams","text":"","title":"User data streams"},{"location":"tutorials/system/stream.html#introduction","text":"SFML has several resource classes: images, fonts, sounds, etc. In most programs, these resources will be loaded from files, with the help of their from_file class method. In a few other situations, resources will be packed directly into the executable or in a big data file, and loaded from memory with from_memory . These methods cover almost all the possible use cases -- but not all. Sometimes you want to load files from unusual places, such as a compressed/encrypted archive, or a remote network location for example. For these special situations, CrSFML provides a third loading method: from_stream . This method reads data using an abstract SF::InputStream interface, which allows you to provide your own implementation of a stream class that works with SFML. In this tutorial you'll learn how to write and use your own derived input stream.","title":"Introduction"},{"location":"tutorials/system/stream.html#inputstream","text":"The SF::InputStream class declares four virtual methods: abstract class InputStream abstract def read ( data : Slice ) : Int64 abstract def seek ( position : Int ) : Int64 abstract def tell () : Int64 abstract def size () : Int64 end read must extract buffer.size bytes of data from the stream, and copy them to the supplied buffer slice. It returns the number of bytes read, or -1 on error. seek must change the current reading position in the stream. Its position argument is the absolute byte offset to jump to (so it is relative to the beginning of the data, not to the current position). It returns the new position, or -1 on error. tell must return the current reading position (in bytes) in the stream, or -1 on error. size must return the total size (in bytes) of the data which is contained in the stream, or -1 on error. To create your own working stream, you must implement every one of these four methods according to their requirements.","title":"InputStream"},{"location":"tutorials/system/stream.html#fileinputstream-and-memoryinputstream","text":"SF::FileInputStream provides the read-only data stream of a file, while SF::MemoryInputStream serves the read-only stream from memory. Both are derived from SF::InputStream .","title":"FileInputStream and MemoryInputStream"},{"location":"tutorials/system/stream.html#using-an-inputstream","text":"Using a custom stream class is straight-forward: instantiate it, and pass it to the from_stream class method of the object that you want to load. stream = SF :: FileInputStream . open ( \"image.png\" ) texture = SF :: Texture . from_stream ( stream ) stream = SF :: FileInputStream . open ( \"music.ogg\" ) music = SF :: Music . from_stream ( stream ) string = File . read ( \"image.png\" ) stream = SF :: MemoryInputStream . open ( string . to_slice ) texture = SF :: Texture . from_stream ( stream ) Note that the examples above are redundant, because from_file can be used instead. The real use cases are if you want to implement custom loading of resources. Option 1: read from file, extract into memory, use SF::MemoryInputStream . Option 2: implement a custom stream that reads and extracts on the fly.","title":"Using an InputStream"},{"location":"tutorials/system/stream.html#examples","text":"If you need a demonstration that helps you focus on how the code works, and not get lost in implementation details, you could take a look at the implementation of SF::FileInputStream or SF::MemoryInputStream .","title":"Examples"},{"location":"tutorials/system/stream.html#common-mistakes","text":"Some resource classes are not loaded completely after from_stream has been called. Instead, they continue to read from their data source as long as they are used. This is the case for SF::Music , which streams audio samples as they are played, and for SF::Font , which loads glyphs on the fly depending on the text that is displayed. As a consequence, the stream instance that you used to load a music or a font, as well as its data source, must remain alive as long as the resource uses it. If it is destroyed while still being used, it results in undefined behavior (can be a crash, corrupt data, or nothing visible). Another common mistake is to return whatever the internal functions return directly, but sometimes it doesn't match what SFML expects. For example, some function may return 0 on success, but InputStream#seek expects the actual new position to be returned. Also keep in mind that in case of error -1 must be returned.","title":"Common mistakes"},{"location":"tutorials/system/thread.html","text":"Threads # What is a thread? # Most of you should already know what a thread is, however here is a little explanation for those who are really new to this concept. A thread is basically a sequence of instructions that run in parallel to other threads. Every program is made of at least one thread: the main one, which runs the top level code in your program. Programs that only use the main thread are single-threaded , if you add one or more threads they become multi-threaded . So, in short, threads are a way to do multiple things at the same time. This can be useful, for example, to display an animation and reacting to user input while loading images or sounds. Threads are also widely used in network programming, to wait for data to be received while continuing to update and draw the application. SFML threads or alternatives? # Multithreaded code is inherently unsafe. Crystal itself has a Thread class, but it is classified as internal, because better ways to do concurrency are being developed. Crystal's standard library is not intended to be used with raw threads. Garbage collection in additional threads causes crashes. Exceptions don't work either. Please make sure you know what you're doing before choosing SFML threads. Creating a thread with CrSFML # Enough talk, let's see some code. The class that makes it possible to create threads in CrSFML is SF::Thread , and here is what it looks like in action: require \"crsfml/system\" def func # this function is started when thread.launch() is called 7 . times do puts \"I'm thread number one\" SF . sleep SF . seconds ( 0.3 ) end end # create a thread with func() as entry point thread = SF :: Thread . new ( -> func ) # run it thread . launch () # the main thread continues to run... SF . sleep SF . seconds ( 0.15 ) 7 . times do puts \"I'm the main thread\" SF . sleep SF . seconds ( 0.3 ) end In this code, both main and func run in parallel after thread.launch() has been called. The result is that text from both functions should be mixed in the console: I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread The entry point of the thread, ie. the function that will be run when the thread is started, must be passed to the constructor of SF::Thread . SF::Thread can accept any kind of procs without parameters. Starting threads # Once you've created a SF::Thread instance, you must start it with the launch method. thread = SF :: Thread . new ( -> func ) thread . launch () launch calls the function that you passed to the constructor in a new thread, and returns immediately so that the calling thread can continue to run. Stopping threads # A thread automatically stops when its entry point function returns. If you want to wait for a thread to finish from another thread, you can call its wait method. thread = SF :: Thread ( -> func ) # start the thread thread . launch () ... # block execution until the thread is finished thread . wait () The wait method is also implicitly called by the destructor of SF::Thread , so that a thread cannot remain alive (and out of control) after its owner SF::Thread instance is destroyed. Keep this in mind when you manage your threads (see the last section of this tutorial). Pausing threads # There's no method in SF::Thread that allows another thread to pause it, the only way to pause a thread is to do it from the code that it runs. In other words, you can only pause the current thread. To do so, you can call the SF.sleep function, as demonstrated in the first example. SF.sleep has one argument, which is the time to sleep. This duration can be given with any unit/precision, as seen in the time tutorial . Note that you can make any thread sleep with this function, even the main one. SF.sleep is the most efficient way to pause a thread: as long as the thread sleeps, it requires zero CPU. Pauses based on active waiting, like empty while loops, would consume 100% CPU just to do... nothing. However, keep in mind that the sleep duration is just a hint, depending on the OS it will be more or less accurate. So don't rely on it for very precise timing. Protecting shared data # All the threads in a program share the same memory, they have access to all variables in the scope they are in. It is very convenient but also dangerous: since threads run in parallel, it means that a variable or function might be used concurrently from several threads at the same time. If the operation is not thread-safe , it can lead to undefined behavior (ie. it might crash or corrupt data). In the first example we had to make sure that the puts calls never happen at the same time, by applying appropriate timing. If the sleeps are gone, the program crashes. Crystal's standard library is not intended to be used with raw threads. Several programming tools exist to help you protect shared data and make your code thread-safe, these are called synchronization primitives. Common ones are mutexes, semaphores, condition variables and spin locks. They are all variants of the same concept: they protect a piece of code by allowing only certain threads to access it while blocking the others. The most basic (and used) primitive is the mutex. Mutex stands for \"MUTual EXclusion\": it ensures that only a single thread is able to run the code that it guards. Let's see how they can bring some order to the example above: require \"crsfml/system\" class Foo @mutex = SF :: Mutex . new def task @mutex . lock 7 . times { puts \"I'm thread number one\" } @mutex . unlock end def main thread = SF :: Thread . new ( -> task ) thread . launch @mutex . lock 7 . times { puts \"I'm the main thread\" } @mutex . unlock thread . wait # wait until function task has finished end end foo = Foo . new foo . main This code uses a shared resource (standard output). Inappropriate use of it causes the lines/letters to be randomly mixed or even crashes. To avoid this, we protect the corresponding region of the code with a mutex. The first thread that reaches its mutex.lock() line succeeds to lock the mutex, directly gains access to the code that follows and prints its text. When the other thread reaches its mutex.lock() line, the mutex is already locked and thus the thread is put to sleep (like SF.sleep , no CPU time is consumed by the sleeping thread). When the first thread finally unlocks the mutex, the second thread is awoken and is allowed to lock the mutex and print its text block as well. This leads to the lines of text appearing sequentially in the console instead of being mixed. I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one Mutexes are not the only primitive that you can use to protect your shared variables, but it should be enough for most cases. However, if your application does complicated things with threads, and you feel like it is not enough, don't hesitate to look for alternatives. Protecting mutexes # Don't worry: mutexes are already thread-safe, there's no need to protect them. But what if there is a failure in the code and the mutex never gets a chance to be unlocked? It remains locked forever. All threads that try to lock it in the future will block forever, and in some cases, your whole application could freeze. Pretty bad result. To make sure that mutexes are always unlocked in an environment where exceptions can be thrown, CrSFML provides a special method that receives a block: synchronize . The mutex is locked before the block and is unlocked after the block (even if an exception is raised). Thus, we can write previous code example in a simpler way, using synchronize like this: require \"crsfml/system\" class Foo @mutex = SF :: Mutex . new def task @mutex . synchronize do # lock mutex implicitly 7 . times { puts \"I'm thread number one\" } end # unlock mutex implicitly end def main thread = SF :: Thread . new ( -> task ) thread . launch @mutex . synchronize do # same as above 7 . times { puts \"I'm the main thread\" } end thread . wait end end foo = Foo . new foo . main Common mistakes # One thing that is often overlooked by programmers is that a thread cannot live without its corresponding SF::Thread instance. The following code is often seen: def func SF . sleep ( SF . seconds ( 10 )) end def start_thread SF :: Thread . new ( -> func ) . launch end start_thread () # ... Programmers who write this kind of code expect the start_thread function to start a thread that will live on its own and be destroyed when the threaded function ends. This is not what happens. The threaded function appears to block the main thread, as if the thread wasn't working. What is the cause of this? The SF::Thread instance is local to the start_thread() function and is therefore destroyed, when the function returns. The finalizer of SF::Thread is invoked, which calls wait() as we've learned above, and the result is that the main thread blocks and waits for the threaded function to be finished instead of continuing to run in parallel. So don't forget: You must manage your SF::Thread instance so that it lives as long as the threaded function is supposed to run.","title":"Threads"},{"location":"tutorials/system/thread.html#threads","text":"","title":"Threads"},{"location":"tutorials/system/thread.html#what-is-a-thread","text":"Most of you should already know what a thread is, however here is a little explanation for those who are really new to this concept. A thread is basically a sequence of instructions that run in parallel to other threads. Every program is made of at least one thread: the main one, which runs the top level code in your program. Programs that only use the main thread are single-threaded , if you add one or more threads they become multi-threaded . So, in short, threads are a way to do multiple things at the same time. This can be useful, for example, to display an animation and reacting to user input while loading images or sounds. Threads are also widely used in network programming, to wait for data to be received while continuing to update and draw the application.","title":"What is a thread?"},{"location":"tutorials/system/thread.html#sfml-threads-or-alternatives","text":"Multithreaded code is inherently unsafe. Crystal itself has a Thread class, but it is classified as internal, because better ways to do concurrency are being developed. Crystal's standard library is not intended to be used with raw threads. Garbage collection in additional threads causes crashes. Exceptions don't work either. Please make sure you know what you're doing before choosing SFML threads.","title":"SFML threads or alternatives?"},{"location":"tutorials/system/thread.html#creating-a-thread-with-crsfml","text":"Enough talk, let's see some code. The class that makes it possible to create threads in CrSFML is SF::Thread , and here is what it looks like in action: require \"crsfml/system\" def func # this function is started when thread.launch() is called 7 . times do puts \"I'm thread number one\" SF . sleep SF . seconds ( 0.3 ) end end # create a thread with func() as entry point thread = SF :: Thread . new ( -> func ) # run it thread . launch () # the main thread continues to run... SF . sleep SF . seconds ( 0.15 ) 7 . times do puts \"I'm the main thread\" SF . sleep SF . seconds ( 0.3 ) end In this code, both main and func run in parallel after thread.launch() has been called. The result is that text from both functions should be mixed in the console: I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread I'm thread number one I'm the main thread The entry point of the thread, ie. the function that will be run when the thread is started, must be passed to the constructor of SF::Thread . SF::Thread can accept any kind of procs without parameters.","title":"Creating a thread with CrSFML"},{"location":"tutorials/system/thread.html#starting-threads","text":"Once you've created a SF::Thread instance, you must start it with the launch method. thread = SF :: Thread . new ( -> func ) thread . launch () launch calls the function that you passed to the constructor in a new thread, and returns immediately so that the calling thread can continue to run.","title":"Starting threads"},{"location":"tutorials/system/thread.html#stopping-threads","text":"A thread automatically stops when its entry point function returns. If you want to wait for a thread to finish from another thread, you can call its wait method. thread = SF :: Thread ( -> func ) # start the thread thread . launch () ... # block execution until the thread is finished thread . wait () The wait method is also implicitly called by the destructor of SF::Thread , so that a thread cannot remain alive (and out of control) after its owner SF::Thread instance is destroyed. Keep this in mind when you manage your threads (see the last section of this tutorial).","title":"Stopping threads"},{"location":"tutorials/system/thread.html#pausing-threads","text":"There's no method in SF::Thread that allows another thread to pause it, the only way to pause a thread is to do it from the code that it runs. In other words, you can only pause the current thread. To do so, you can call the SF.sleep function, as demonstrated in the first example. SF.sleep has one argument, which is the time to sleep. This duration can be given with any unit/precision, as seen in the time tutorial . Note that you can make any thread sleep with this function, even the main one. SF.sleep is the most efficient way to pause a thread: as long as the thread sleeps, it requires zero CPU. Pauses based on active waiting, like empty while loops, would consume 100% CPU just to do... nothing. However, keep in mind that the sleep duration is just a hint, depending on the OS it will be more or less accurate. So don't rely on it for very precise timing.","title":"Pausing threads"},{"location":"tutorials/system/thread.html#protecting-shared-data","text":"All the threads in a program share the same memory, they have access to all variables in the scope they are in. It is very convenient but also dangerous: since threads run in parallel, it means that a variable or function might be used concurrently from several threads at the same time. If the operation is not thread-safe , it can lead to undefined behavior (ie. it might crash or corrupt data). In the first example we had to make sure that the puts calls never happen at the same time, by applying appropriate timing. If the sleeps are gone, the program crashes. Crystal's standard library is not intended to be used with raw threads. Several programming tools exist to help you protect shared data and make your code thread-safe, these are called synchronization primitives. Common ones are mutexes, semaphores, condition variables and spin locks. They are all variants of the same concept: they protect a piece of code by allowing only certain threads to access it while blocking the others. The most basic (and used) primitive is the mutex. Mutex stands for \"MUTual EXclusion\": it ensures that only a single thread is able to run the code that it guards. Let's see how they can bring some order to the example above: require \"crsfml/system\" class Foo @mutex = SF :: Mutex . new def task @mutex . lock 7 . times { puts \"I'm thread number one\" } @mutex . unlock end def main thread = SF :: Thread . new ( -> task ) thread . launch @mutex . lock 7 . times { puts \"I'm the main thread\" } @mutex . unlock thread . wait # wait until function task has finished end end foo = Foo . new foo . main This code uses a shared resource (standard output). Inappropriate use of it causes the lines/letters to be randomly mixed or even crashes. To avoid this, we protect the corresponding region of the code with a mutex. The first thread that reaches its mutex.lock() line succeeds to lock the mutex, directly gains access to the code that follows and prints its text. When the other thread reaches its mutex.lock() line, the mutex is already locked and thus the thread is put to sleep (like SF.sleep , no CPU time is consumed by the sleeping thread). When the first thread finally unlocks the mutex, the second thread is awoken and is allowed to lock the mutex and print its text block as well. This leads to the lines of text appearing sequentially in the console instead of being mixed. I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm the main thread I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one I'm thread number one Mutexes are not the only primitive that you can use to protect your shared variables, but it should be enough for most cases. However, if your application does complicated things with threads, and you feel like it is not enough, don't hesitate to look for alternatives.","title":"Protecting shared data"},{"location":"tutorials/system/thread.html#protecting-mutexes","text":"Don't worry: mutexes are already thread-safe, there's no need to protect them. But what if there is a failure in the code and the mutex never gets a chance to be unlocked? It remains locked forever. All threads that try to lock it in the future will block forever, and in some cases, your whole application could freeze. Pretty bad result. To make sure that mutexes are always unlocked in an environment where exceptions can be thrown, CrSFML provides a special method that receives a block: synchronize . The mutex is locked before the block and is unlocked after the block (even if an exception is raised). Thus, we can write previous code example in a simpler way, using synchronize like this: require \"crsfml/system\" class Foo @mutex = SF :: Mutex . new def task @mutex . synchronize do # lock mutex implicitly 7 . times { puts \"I'm thread number one\" } end # unlock mutex implicitly end def main thread = SF :: Thread . new ( -> task ) thread . launch @mutex . synchronize do # same as above 7 . times { puts \"I'm the main thread\" } end thread . wait end end foo = Foo . new foo . main","title":"Protecting mutexes"},{"location":"tutorials/system/thread.html#common-mistakes","text":"One thing that is often overlooked by programmers is that a thread cannot live without its corresponding SF::Thread instance. The following code is often seen: def func SF . sleep ( SF . seconds ( 10 )) end def start_thread SF :: Thread . new ( -> func ) . launch end start_thread () # ... Programmers who write this kind of code expect the start_thread function to start a thread that will live on its own and be destroyed when the threaded function ends. This is not what happens. The threaded function appears to block the main thread, as if the thread wasn't working. What is the cause of this? The SF::Thread instance is local to the start_thread() function and is therefore destroyed, when the function returns. The finalizer of SF::Thread is invoked, which calls wait() as we've learned above, and the result is that the main thread blocks and waits for the threaded function to be finished instead of continuing to run in parallel. So don't forget: You must manage your SF::Thread instance so that it lives as long as the threaded function is supposed to run.","title":"Common mistakes"},{"location":"tutorials/system/time.html","text":"Handling time # Time in SFML # Unlike many other libraries where time is a number of milliseconds, or a decimal number of seconds, SFML doesn't impose any specific unit or type for time values. Instead it leaves this choice to the user through a flexible class: SF::Time . All SFML classes and functions that manipulate time values use this class. SF::Time represents a time period (in other words, the time that elapses between two events). It is not a date-time class which would represent the current year/month/day/hour/minute/second as a timestamp, it's just a value that represents a certain amount of time, and how to interpret it depends on the context where it is used. Converting time # A SF::Time value can be constructed from different source units: seconds, milliseconds and microseconds. There is a (non-member) function to turn each of them into a SF::Time : t1 = SF . microseconds ( 10000 ) t2 = SF . milliseconds ( 10 ) t3 = SF . seconds ( 0.01 ) Note that these three times are all equal. Similarly, a SF::Time can be converted back to either seconds, milliseconds or microseconds: time = ... microseconds = time . as_microseconds milliseconds = time . as_milliseconds seconds = time . as_seconds Playing with time values # SF::Time is just an amount of time, so it supports arithmetic operations such as addition, subtraction, comparison, etc. Times can also be negative. t1 = ... t2 = t1 * 2 t3 = t1 + t2 t4 = - t3 b1 = ( t1 == t2 ) b2 = ( t3 > t4 ) Measuring time # Relevant example: transformable Now that we've seen how to manipulate time values with CrSFML, let's see how to do something that almost every program needs: measuring the time elapsed. CrSFML has a very simple class for measuring time: SF::Clock . It only has two methods: elapsed_time , to retrieve the time elapsed since the clock started, and restart , to restart the clock. clock = SF :: Clock . new # Starts the clock sleep ( 2 ) elapsed_1 = clock . elapsed_time p elapsed_1 . as_seconds clock . restart sleep ( 3 ) elapsed_2 = clock . elapsed_time p elapsed_2 . as_seconds Note that restart also returns the elapsed time, so that you can avoid the slight gap that would exist if you had to call elapsed_time explicitly before restart . Here is an example that uses the time elapsed at each iteration of the game loop to update the game logic: clock = SF :: Clock . new while window . open? elapsed = clock . restart update_game ( elapsed ) ... end","title":"Handling time"},{"location":"tutorials/system/time.html#handling-time","text":"","title":"Handling time"},{"location":"tutorials/system/time.html#time-in-sfml","text":"Unlike many other libraries where time is a number of milliseconds, or a decimal number of seconds, SFML doesn't impose any specific unit or type for time values. Instead it leaves this choice to the user through a flexible class: SF::Time . All SFML classes and functions that manipulate time values use this class. SF::Time represents a time period (in other words, the time that elapses between two events). It is not a date-time class which would represent the current year/month/day/hour/minute/second as a timestamp, it's just a value that represents a certain amount of time, and how to interpret it depends on the context where it is used.","title":"Time in SFML"},{"location":"tutorials/system/time.html#converting-time","text":"A SF::Time value can be constructed from different source units: seconds, milliseconds and microseconds. There is a (non-member) function to turn each of them into a SF::Time : t1 = SF . microseconds ( 10000 ) t2 = SF . milliseconds ( 10 ) t3 = SF . seconds ( 0.01 ) Note that these three times are all equal. Similarly, a SF::Time can be converted back to either seconds, milliseconds or microseconds: time = ... microseconds = time . as_microseconds milliseconds = time . as_milliseconds seconds = time . as_seconds","title":"Converting time"},{"location":"tutorials/system/time.html#playing-with-time-values","text":"SF::Time is just an amount of time, so it supports arithmetic operations such as addition, subtraction, comparison, etc. Times can also be negative. t1 = ... t2 = t1 * 2 t3 = t1 + t2 t4 = - t3 b1 = ( t1 == t2 ) b2 = ( t3 > t4 )","title":"Playing with time values"},{"location":"tutorials/system/time.html#measuring-time","text":"Relevant example: transformable Now that we've seen how to manipulate time values with CrSFML, let's see how to do something that almost every program needs: measuring the time elapsed. CrSFML has a very simple class for measuring time: SF::Clock . It only has two methods: elapsed_time , to retrieve the time elapsed since the clock started, and restart , to restart the clock. clock = SF :: Clock . new # Starts the clock sleep ( 2 ) elapsed_1 = clock . elapsed_time p elapsed_1 . as_seconds clock . restart sleep ( 3 ) elapsed_2 = clock . elapsed_time p elapsed_2 . as_seconds Note that restart also returns the elapsed time, so that you can avoid the slight gap that would exist if you had to call elapsed_time explicitly before restart . Here is an example that uses the time elapsed at each iteration of the game loop to update the game logic: clock = SF :: Clock . new while window . open? elapsed = clock . restart update_game ( elapsed ) ... end","title":"Measuring time"},{"location":"tutorials/window/events.html","text":"Events explained # Introduction # This tutorial is a detailed list of window events. It describes them, and shows how to (and how not to) use them. The SF::Event type # Before dealing with events, it is important to understand what the SF::Event type is, and how to correctly use it. SF::Event (unlike in SFML, where it is a union ) is just an abstract struct, and all the events are its subclasses. Many events have some data associated with them, so it is important to let the compiler know which exactly type of event is being inspected (using is_a? , as , case / when ), otherwise none of the members will be accessible. Here is the hierarchy: level 1 is the Event abstract struct itself, level 2 are abstract structs that add some members, and level 3 are concrete event types. The point of this is that that some events, while different (level 3), have exactly the same kind of information associated with them (level 2). Event \u251c\u2500\u2500\u2500\u2500\u2574Closed \u251c\u2500\u2574SizeEvent: height, width \u2502 \u2514\u2500\u2574Resized \u251c\u2500\u2500\u2500\u2500\u2574LostFocus \u251c\u2500\u2500\u2500\u2500\u2574GainedFocus \u251c\u2500\u2574TextEvent: unicode \u2502 \u2514\u2500\u2574TextEntered \u251c\u2500\u2574KeyEvent: code, alt, control, shift, system \u2502 \u251c\u2500\u2574KeyPressed \u2502 \u2514\u2500\u2574KeyReleased \u251c\u2500\u2574MouseWheelEvent: delta, x, y \u2502 \u2514\u2500\u2574MouseWheelMoved \u251c\u2500\u2574MouseWheelScrollEvent: wheel, delta, x, y \u2502 \u2514\u2500\u2574MouseWheelScrolled \u251c\u2500\u2574MouseButtonEvent: button, x, y \u2502 \u251c\u2500\u2574MouseButtonPressed \u2502 \u2514\u2500\u2574MouseButtonReleased \u251c\u2500\u2574MouseMoveEvent: x, y \u2502 \u2514\u2500\u2574MouseMoved \u251c\u2500\u2500\u2500\u2500\u2574MouseEntered \u251c\u2500\u2500\u2500\u2500\u2574MouseLeft \u251c\u2500\u2574JoystickButtonEvent: joystick_id, button \u2502 \u251c\u2500\u2574JoystickButtonPressed \u2502 \u2514\u2500\u2574JoystickButtonReleased \u251c\u2500\u2574JoystickMoveEvent: joystick_id, axis, position \u2502 \u2514\u2500\u2574JoystickMoved \u251c\u2500\u2574JoystickConnectEvent: joystick_id \u2502 \u251c\u2500\u2574JoystickConnected \u2502 \u2514\u2500\u2574JoystickDisconnected \u251c\u2500\u2574TouchEvent: finger, x, y \u2502 \u251c\u2500\u2574TouchBegan \u2502 \u251c\u2500\u2574TouchMoved \u2502 \u2514\u2500\u2574TouchEnded \u2514\u2500\u2574SensorEvent: type, x, y, z \u2514\u2500\u2574SensorChanged SF::Event instances are filled by the poll_event (or wait_event ) method of the SF::Window class. Only these two methods can produce valid events. To be clear, here is what a typical event loop looks like: # while there are pending events... while event = window . poll_event # check the type of the event... case event # window closed when SF :: Event :: Closed window . close # key pressed when SF :: Event :: KeyPressed ... # we don't process other types of events end end Alright, now we can see what events SFML supports, what they mean and how to use them properly. The Closed event # Relevant example: simple The SF::Event::Closed event is triggered when the user wants to close the window, through any of the possible methods the window manager provides (\"close\" button, keyboard shortcut, etc.). This event only represents a close request, the window is not yet closed when the event is received. Typical code will just call window.close in reaction to this event, to actually close the window. However, you may also want to do something else first, like saving the current application state or asking the user what to do. If you don't do anything, the window remains open. There's no member associated with this event in the SF::Event union. if event . is_a? SF :: Event :: Closed window . close end The Resized event # Relevant example: gl The SF::Event::Resized event is triggered when the window is resized, either through user action or programmatically by calling window.size= . You can use this event to adjust the rendering settings: the viewport if you use OpenGL directly, or the current view if you use sfml-graphics. The data associated with this event is the new size of the window. if event . is_a? SF :: Event :: Resized puts \"new width: #{ event . width } \" puts \"new height: #{ event . height } \" end The LostFocus and GainedFocus events # The SF::Event::LostFocus and SF::Event::GainedFocus events are triggered when the window loses/gains focus, which happens when the user switches the currently active window. When the window is out of focus, it doesn't receive keyboard events. This event can be used e.g. if you want to pause your game when the window is inactive. There's no member associated with these events in the SF::Event union. if event . is_a? SF :: Event :: LostFocus my_game . pause end if event . is_a? SF :: Event :: GainedFocus my_game . resume end The TextEntered event # Relevant example: typing The SF::Event::TextEntered event is triggered when a character is typed. This must not be confused with the KeyPressed event: TextEntered interprets the user input and produces the appropriate printable character. For example, pressing '^' then 'e' on a French keyboard will produce two KeyPressed events, but a single TextEntered event containing the '\u00ea' character. It works with all the input methods provided by the operating system, even the most specific or complex ones. This event is typically used to catch user input in a text field. The data associated with this event is the Unicode codepoint of the entered character (use .chr to convert it to a Char ). if event . is_a? SF :: Event :: TextEntered if event . unicode < 128 puts \"ASCII character typed: #{ event . unicode . chr } \" end end Note that, since they are part of the Unicode standard, some non-printable characters such as backspace are generated by this event. In most cases you'll need to filter them out. Many programmers use the KeyPressed event to get user input, and start to implement crazy algorithms that try to interpret all the possible key combinations to produce correct characters. Don't do that! The KeyPressed and KeyReleased events # Relevant example: snakes The SF::Event::KeyPressed and SF::Event::KeyReleased events are triggered when a keyboard key is pressed/released. If a key is held, multiple KeyPressed events will be generated, at the default operating system delay (i. e. the same delay that applies when you hold a letter in a text editor). To disable repeated KeyPressed events, you can set window.key_repeat_enabled = false . On the flip side, it is obvious that KeyReleased events can never be repeated. This event is the one to use if you want to trigger an action exactly once when a key is pressed or released, like making a character jump with space, or exiting something with escape. Sometimes, people try to react to KeyPressed events directly to implement smooth movement. Doing so will not produce the expected effect, because when you hold a key you only get a few events (remember, the repeat delay). To achieve smooth movement with events, you must use a boolean that you set on KeyPressed and clear on KeyReleased ; you can then move (independently of events) as long as the boolean is set. The other (easier) solution to produce smooth movement is to use real-time keyboard input with SF::Keyboard (see the dedicated tutorial ). The data associated with these events is the code of the pressed/released key, as well as the current state of the modifier keys (alt, control, shift, system). if event . is_a? SF :: Event :: KeyPressed if event . code == SF :: Keyboard :: Escape puts \"the escape key was pressed\" puts \"control: #{ event . control } \" puts \"alt: #{ event . alt } \" puts \"shift: #{ event . shift } \" puts \"system: #{ event . system } \" end end Note that some keys have a special meaning for the operating system, and will lead to unexpected behavior. An example is the F10 key on Windows, which \"steals\" the focus, or the F12 key which starts the debugger when using Visual Studio. This will probably be solved in a future version of SFML. The MouseWheelMoved event # The SF::Event::MouseWheelMoved event is deprecated since SFML 2.3, use the MouseWheelScrolled event instead. The MouseWheelScrolled event # Relevant example: diagnostics The SF::Event::MouseWheelScrolled event is triggered when a mouse wheel moves up or down, but also laterally if the mouse supports it. The data associated with this event contains the number of ticks the wheel has moved, what the orientation of the wheel is and the current position of the mouse cursor. if event . is_a? SF :: Event :: MouseWheelScrolled if event . wheel == SF :: Mouse :: VerticalWheel puts \"wheel type: vertical\" elsif event . wheel == SF :: Mouse :: HorizontalWheel puts \"wheel type: horizontal\" else puts \"wheel type: unknown\" end puts \"wheel movement: #{ event . delta } \" puts \"mouse x: #{ event . x } \" puts \"mouse y: #{ event . y } \" end The MouseButtonPressed and MouseButtonReleased events # Relevant example: diagnostics The SF::Event::MouseButtonPressed and SF::Event::MouseButtonReleased events are triggered when a mouse button is pressed/released. SFML supports 5 mouse buttons: left, right, middle (wheel), extra #1 and extra #2 (side buttons). The data associated with these events contains the code of the pressed/released button, as well as the current position of the mouse cursor. if event . is_a? SF :: Event :: MouseButtonPressed if event . button . right? puts \"the right button was pressed\" puts \"mouse x: #{ event . x } \" puts \"mouse y: #{ event . y } \" end end The MouseMoved event # The SF::Event::MouseMoved event is triggered when the mouse moves within the window. This event is triggered even if the window isn't focused. However, it is triggered only when the mouse moves within the inner area of the window, not when it moves over the title bar or borders. The data associated with this event contains the current position of the mouse cursor relative to the window. if event . is_a? SF :: Event :: MouseMoved puts \"new mouse x: #{ event . x } \" puts \"new mouse y: #{ event . y } \" end The MouseEntered and MouseLeft event # The SF::Event::MouseEntered and SF::Event::MouseLeft events are triggered when the mouse cursor enters/leaves the window. There is no data associated with these events. case event when SF :: Event :: MouseEntered puts \"the mouse cursor has entered the window\" when SF :: Event :: MouseLeft puts \"the mouse cursor has left the window\" end The JoystickButtonPressed and JoystickButtonReleased events # The SF::Event::JoystickButtonPressed and SF::Event::JoystickButtonReleased events are triggered when a joystick button is pressed/released. SFML supports up to 8 joysticks and 32 buttons. The data associated with these events contains the identifier of the joystick and the index of the pressed/released button. if event . is_a? SF :: Event :: JoystickButtonPressed puts \"joystick button pressed!\" puts \"joystick id: #{ event . joystick_id } \" puts \"button: #{ event . button } \" end The JoystickMoved event # The SF::Event::JoystickMoved event is triggered when a joystick axis moves. Joystick axes are typically very sensitive, that's why SFML uses a detection threshold to avoid spamming your event loop with tons of JoystickMoved events. This threshold can be changed with the Window#joystick_threshold= method, in case you want to receive more or less joystick move events. SFML supports 8 joystick axes: X, Y, Z, R, U, V, POV X and POV Y. How they map to your joystick depends on its driver. The member associated with this event contains the identifier of the joystick, the name of the axis, and its current position (in the range [-100, 100]). if event . is_a? SF :: Event :: JoystickMoved if event . axis == SF :: Joystick :: X puts \"X axis moved!\" puts \"joystick id: #{ event . joystick_id } \" puts \"new position: #{ event . position } \" end end The JoystickConnected and JoystickDisconnected events # The SF::Event::JoystickConnected and SF::Event::JoystickDisconnected events are triggered when a joystick is connected/disconnected. The data associated with this event is the identifier of the connected/disconnected joystick. case event when SF :: Event :: JoystickConnected puts \"joystick connected: #{ event . joystick_id } \" when SF :: Event :: JoystickDisconnected puts \"joystick disconnected: #{ event . joystick_id } \" end","title":"Events explained"},{"location":"tutorials/window/events.html#events-explained","text":"","title":"Events explained"},{"location":"tutorials/window/events.html#introduction","text":"This tutorial is a detailed list of window events. It describes them, and shows how to (and how not to) use them.","title":"Introduction"},{"location":"tutorials/window/events.html#the-sfevent-type","text":"Before dealing with events, it is important to understand what the SF::Event type is, and how to correctly use it. SF::Event (unlike in SFML, where it is a union ) is just an abstract struct, and all the events are its subclasses. Many events have some data associated with them, so it is important to let the compiler know which exactly type of event is being inspected (using is_a? , as , case / when ), otherwise none of the members will be accessible. Here is the hierarchy: level 1 is the Event abstract struct itself, level 2 are abstract structs that add some members, and level 3 are concrete event types. The point of this is that that some events, while different (level 3), have exactly the same kind of information associated with them (level 2). Event \u251c\u2500\u2500\u2500\u2500\u2574Closed \u251c\u2500\u2574SizeEvent: height, width \u2502 \u2514\u2500\u2574Resized \u251c\u2500\u2500\u2500\u2500\u2574LostFocus \u251c\u2500\u2500\u2500\u2500\u2574GainedFocus \u251c\u2500\u2574TextEvent: unicode \u2502 \u2514\u2500\u2574TextEntered \u251c\u2500\u2574KeyEvent: code, alt, control, shift, system \u2502 \u251c\u2500\u2574KeyPressed \u2502 \u2514\u2500\u2574KeyReleased \u251c\u2500\u2574MouseWheelEvent: delta, x, y \u2502 \u2514\u2500\u2574MouseWheelMoved \u251c\u2500\u2574MouseWheelScrollEvent: wheel, delta, x, y \u2502 \u2514\u2500\u2574MouseWheelScrolled \u251c\u2500\u2574MouseButtonEvent: button, x, y \u2502 \u251c\u2500\u2574MouseButtonPressed \u2502 \u2514\u2500\u2574MouseButtonReleased \u251c\u2500\u2574MouseMoveEvent: x, y \u2502 \u2514\u2500\u2574MouseMoved \u251c\u2500\u2500\u2500\u2500\u2574MouseEntered \u251c\u2500\u2500\u2500\u2500\u2574MouseLeft \u251c\u2500\u2574JoystickButtonEvent: joystick_id, button \u2502 \u251c\u2500\u2574JoystickButtonPressed \u2502 \u2514\u2500\u2574JoystickButtonReleased \u251c\u2500\u2574JoystickMoveEvent: joystick_id, axis, position \u2502 \u2514\u2500\u2574JoystickMoved \u251c\u2500\u2574JoystickConnectEvent: joystick_id \u2502 \u251c\u2500\u2574JoystickConnected \u2502 \u2514\u2500\u2574JoystickDisconnected \u251c\u2500\u2574TouchEvent: finger, x, y \u2502 \u251c\u2500\u2574TouchBegan \u2502 \u251c\u2500\u2574TouchMoved \u2502 \u2514\u2500\u2574TouchEnded \u2514\u2500\u2574SensorEvent: type, x, y, z \u2514\u2500\u2574SensorChanged SF::Event instances are filled by the poll_event (or wait_event ) method of the SF::Window class. Only these two methods can produce valid events. To be clear, here is what a typical event loop looks like: # while there are pending events... while event = window . poll_event # check the type of the event... case event # window closed when SF :: Event :: Closed window . close # key pressed when SF :: Event :: KeyPressed ... # we don't process other types of events end end Alright, now we can see what events SFML supports, what they mean and how to use them properly.","title":"The SF::Event type"},{"location":"tutorials/window/events.html#the-closed-event","text":"Relevant example: simple The SF::Event::Closed event is triggered when the user wants to close the window, through any of the possible methods the window manager provides (\"close\" button, keyboard shortcut, etc.). This event only represents a close request, the window is not yet closed when the event is received. Typical code will just call window.close in reaction to this event, to actually close the window. However, you may also want to do something else first, like saving the current application state or asking the user what to do. If you don't do anything, the window remains open. There's no member associated with this event in the SF::Event union. if event . is_a? SF :: Event :: Closed window . close end","title":"The Closed event"},{"location":"tutorials/window/events.html#the-resized-event","text":"Relevant example: gl The SF::Event::Resized event is triggered when the window is resized, either through user action or programmatically by calling window.size= . You can use this event to adjust the rendering settings: the viewport if you use OpenGL directly, or the current view if you use sfml-graphics. The data associated with this event is the new size of the window. if event . is_a? SF :: Event :: Resized puts \"new width: #{ event . width } \" puts \"new height: #{ event . height } \" end","title":"The Resized event"},{"location":"tutorials/window/events.html#the-lostfocus-and-gainedfocus-events","text":"The SF::Event::LostFocus and SF::Event::GainedFocus events are triggered when the window loses/gains focus, which happens when the user switches the currently active window. When the window is out of focus, it doesn't receive keyboard events. This event can be used e.g. if you want to pause your game when the window is inactive. There's no member associated with these events in the SF::Event union. if event . is_a? SF :: Event :: LostFocus my_game . pause end if event . is_a? SF :: Event :: GainedFocus my_game . resume end","title":"The LostFocus and GainedFocus events"},{"location":"tutorials/window/events.html#the-textentered-event","text":"Relevant example: typing The SF::Event::TextEntered event is triggered when a character is typed. This must not be confused with the KeyPressed event: TextEntered interprets the user input and produces the appropriate printable character. For example, pressing '^' then 'e' on a French keyboard will produce two KeyPressed events, but a single TextEntered event containing the '\u00ea' character. It works with all the input methods provided by the operating system, even the most specific or complex ones. This event is typically used to catch user input in a text field. The data associated with this event is the Unicode codepoint of the entered character (use .chr to convert it to a Char ). if event . is_a? SF :: Event :: TextEntered if event . unicode < 128 puts \"ASCII character typed: #{ event . unicode . chr } \" end end Note that, since they are part of the Unicode standard, some non-printable characters such as backspace are generated by this event. In most cases you'll need to filter them out. Many programmers use the KeyPressed event to get user input, and start to implement crazy algorithms that try to interpret all the possible key combinations to produce correct characters. Don't do that!","title":"The TextEntered event"},{"location":"tutorials/window/events.html#the-keypressed-and-keyreleased-events","text":"Relevant example: snakes The SF::Event::KeyPressed and SF::Event::KeyReleased events are triggered when a keyboard key is pressed/released. If a key is held, multiple KeyPressed events will be generated, at the default operating system delay (i. e. the same delay that applies when you hold a letter in a text editor). To disable repeated KeyPressed events, you can set window.key_repeat_enabled = false . On the flip side, it is obvious that KeyReleased events can never be repeated. This event is the one to use if you want to trigger an action exactly once when a key is pressed or released, like making a character jump with space, or exiting something with escape. Sometimes, people try to react to KeyPressed events directly to implement smooth movement. Doing so will not produce the expected effect, because when you hold a key you only get a few events (remember, the repeat delay). To achieve smooth movement with events, you must use a boolean that you set on KeyPressed and clear on KeyReleased ; you can then move (independently of events) as long as the boolean is set. The other (easier) solution to produce smooth movement is to use real-time keyboard input with SF::Keyboard (see the dedicated tutorial ). The data associated with these events is the code of the pressed/released key, as well as the current state of the modifier keys (alt, control, shift, system). if event . is_a? SF :: Event :: KeyPressed if event . code == SF :: Keyboard :: Escape puts \"the escape key was pressed\" puts \"control: #{ event . control } \" puts \"alt: #{ event . alt } \" puts \"shift: #{ event . shift } \" puts \"system: #{ event . system } \" end end Note that some keys have a special meaning for the operating system, and will lead to unexpected behavior. An example is the F10 key on Windows, which \"steals\" the focus, or the F12 key which starts the debugger when using Visual Studio. This will probably be solved in a future version of SFML.","title":"The KeyPressed and KeyReleased events"},{"location":"tutorials/window/events.html#the-mousewheelmoved-event","text":"The SF::Event::MouseWheelMoved event is deprecated since SFML 2.3, use the MouseWheelScrolled event instead.","title":"The MouseWheelMoved event"},{"location":"tutorials/window/events.html#the-mousewheelscrolled-event","text":"Relevant example: diagnostics The SF::Event::MouseWheelScrolled event is triggered when a mouse wheel moves up or down, but also laterally if the mouse supports it. The data associated with this event contains the number of ticks the wheel has moved, what the orientation of the wheel is and the current position of the mouse cursor. if event . is_a? SF :: Event :: MouseWheelScrolled if event . wheel == SF :: Mouse :: VerticalWheel puts \"wheel type: vertical\" elsif event . wheel == SF :: Mouse :: HorizontalWheel puts \"wheel type: horizontal\" else puts \"wheel type: unknown\" end puts \"wheel movement: #{ event . delta } \" puts \"mouse x: #{ event . x } \" puts \"mouse y: #{ event . y } \" end","title":"The MouseWheelScrolled event"},{"location":"tutorials/window/events.html#the-mousebuttonpressed-and-mousebuttonreleased-events","text":"Relevant example: diagnostics The SF::Event::MouseButtonPressed and SF::Event::MouseButtonReleased events are triggered when a mouse button is pressed/released. SFML supports 5 mouse buttons: left, right, middle (wheel), extra #1 and extra #2 (side buttons). The data associated with these events contains the code of the pressed/released button, as well as the current position of the mouse cursor. if event . is_a? SF :: Event :: MouseButtonPressed if event . button . right? puts \"the right button was pressed\" puts \"mouse x: #{ event . x } \" puts \"mouse y: #{ event . y } \" end end","title":"The MouseButtonPressed and MouseButtonReleased events"},{"location":"tutorials/window/events.html#the-mousemoved-event","text":"The SF::Event::MouseMoved event is triggered when the mouse moves within the window. This event is triggered even if the window isn't focused. However, it is triggered only when the mouse moves within the inner area of the window, not when it moves over the title bar or borders. The data associated with this event contains the current position of the mouse cursor relative to the window. if event . is_a? SF :: Event :: MouseMoved puts \"new mouse x: #{ event . x } \" puts \"new mouse y: #{ event . y } \" end","title":"The MouseMoved event"},{"location":"tutorials/window/events.html#the-mouseentered-and-mouseleft-event","text":"The SF::Event::MouseEntered and SF::Event::MouseLeft events are triggered when the mouse cursor enters/leaves the window. There is no data associated with these events. case event when SF :: Event :: MouseEntered puts \"the mouse cursor has entered the window\" when SF :: Event :: MouseLeft puts \"the mouse cursor has left the window\" end","title":"The MouseEntered and MouseLeft event"},{"location":"tutorials/window/events.html#the-joystickbuttonpressed-and-joystickbuttonreleased-events","text":"The SF::Event::JoystickButtonPressed and SF::Event::JoystickButtonReleased events are triggered when a joystick button is pressed/released. SFML supports up to 8 joysticks and 32 buttons. The data associated with these events contains the identifier of the joystick and the index of the pressed/released button. if event . is_a? SF :: Event :: JoystickButtonPressed puts \"joystick button pressed!\" puts \"joystick id: #{ event . joystick_id } \" puts \"button: #{ event . button } \" end","title":"The JoystickButtonPressed and JoystickButtonReleased events"},{"location":"tutorials/window/events.html#the-joystickmoved-event","text":"The SF::Event::JoystickMoved event is triggered when a joystick axis moves. Joystick axes are typically very sensitive, that's why SFML uses a detection threshold to avoid spamming your event loop with tons of JoystickMoved events. This threshold can be changed with the Window#joystick_threshold= method, in case you want to receive more or less joystick move events. SFML supports 8 joystick axes: X, Y, Z, R, U, V, POV X and POV Y. How they map to your joystick depends on its driver. The member associated with this event contains the identifier of the joystick, the name of the axis, and its current position (in the range [-100, 100]). if event . is_a? SF :: Event :: JoystickMoved if event . axis == SF :: Joystick :: X puts \"X axis moved!\" puts \"joystick id: #{ event . joystick_id } \" puts \"new position: #{ event . position } \" end end","title":"The JoystickMoved event"},{"location":"tutorials/window/events.html#the-joystickconnected-and-joystickdisconnected-events","text":"The SF::Event::JoystickConnected and SF::Event::JoystickDisconnected events are triggered when a joystick is connected/disconnected. The data associated with this event is the identifier of the connected/disconnected joystick. case event when SF :: Event :: JoystickConnected puts \"joystick connected: #{ event . joystick_id } \" when SF :: Event :: JoystickDisconnected puts \"joystick disconnected: #{ event . joystick_id } \" end","title":"The JoystickConnected and JoystickDisconnected events"},{"location":"tutorials/window/inputs.html","text":"Keyboard, mouse and joystick # Relevant example: diagnostics Introduction # This tutorial explains how to access global input devices: keyboard, mouse and joysticks. This must not be confused with events. Real-time input allows you to query the global state of keyboard, mouse and joysticks at any time (\" is this button currently pressed? \", \" where is the mouse currently? \") while events notify you when something happens (\" this button was pressed \", \" the mouse has moved \"). Keyboard # The class that provides access to the keyboard state is SF::Keyboard . It only contains one class method, key_pressed? , which checks the current state of a key (pressed or released). It is a class method, so you don't need to instantiate SF::Keyboard to use it. This class method directly reads the keyboard state, ignoring the focus state of your window. This means that key_pressed? may return true even if your window is inactive. if SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Left ) # left key is pressed: move our character character . move ( 1 , 0 ) end Key codes are defined in the SF::Keyboard::Key enum. Depending on your operating system and keyboard layout, some key codes might be missing or interpreted incorrectly. This is something that will be improved in a future version of SFML. Mouse # The class that provides access to the mouse state is SF::Mouse . Like its friend SF::Keyboard , SF::Mouse only contains class methods and is not meant to be instantiated (SFML only handles a single mouse for the time being). You can check if buttons are pressed: if SF :: Mouse . button_pressed? ( SF :: Mouse :: Left ) # left mouse button is pressed: shoot gun . fire end Mouse button codes are defined in the SF::Mouse::Button enum. SFML supports up to 5 buttons: left, right, middle (wheel), and two additional buttons whatever they may be. You can also get and set the current position of the mouse, either relative to the desktop or to a window: # get the global mouse position (relative to the desktop) global_position = SF :: Mouse . position # get the local mouse position (relative to a window) local_position = SF :: Mouse . get_position ( window ) # window is a SF::Window # set the mouse position globally (relative to the desktop) SF :: Mouse . position = SF . vector2 ( 10 , 50 ) # set the mouse position locally (relative to a window) SF :: Mouse . set_position ( SF . vector2 ( 10 , 50 ), window ) # window is a SF::Window There is no function for reading the current state of the mouse wheel. Since the wheel can only be moved relatively, it has no absolute state that can be queried. By looking at a key you can tell whether it's pressed or released. By looking at the mouse cursor you can tell where it is located on the screen. However, looking at the mouse wheel doesn't tell you which \"tick\" it is on. You can only be notified when it moves ( MouseWheelMoved event). Joystick # The class that provides access to the joysticks' states is SF::Joystick . Like the other classes in this tutorial, it only contains class methods. Joysticks are identified by their index (0 to 7, since SFML supports up to 8 joysticks). Therefore, the first argument of every class method of SF::Joystick is the index of the joystick that you want to query. You can check whether a joystick is connected or not: if SF :: Joystick . connected? ( 0 ) # joystick number 0 is connected ... end You can also get the capabilities of a connected joystick: # check how many buttons joystick number 0 has button_count = SF :: Joystick . get_button_count ( 0 ) # check if joystick number 0 has a Z axis has_z = SF :: Joystick . axis? ( 0 , SF :: Joystick :: Z ) Joystick axes are defined in the SF::Joystick::Axis enum. Since buttons have no special meaning, they are simply numbered from 0 to 31. Finally, you can query the state of a joystick's axes and buttons as well: # is button 1 of joystick number 0 pressed? if SF :: Joystick . button_pressed? ( 0 , 1 ) # yes: shoot! gun . fire end # what's the current position of the X and Y axes of joystick number 0? x = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: X ) y = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: Y ) character . move ( x , y ) Joystick states are automatically updated when you check for events. If you don't check for events, or need to query a joystick state (for example, checking which joysticks are connected) before starting your game loop, you'll have to manually call the SF::Joystick.update class method yourself to make sure that the joystick states are up to date.","title":"Keyboard, mouse and joysticks"},{"location":"tutorials/window/inputs.html#keyboard-mouse-and-joystick","text":"Relevant example: diagnostics","title":"Keyboard, mouse and joystick"},{"location":"tutorials/window/inputs.html#introduction","text":"This tutorial explains how to access global input devices: keyboard, mouse and joysticks. This must not be confused with events. Real-time input allows you to query the global state of keyboard, mouse and joysticks at any time (\" is this button currently pressed? \", \" where is the mouse currently? \") while events notify you when something happens (\" this button was pressed \", \" the mouse has moved \").","title":"Introduction"},{"location":"tutorials/window/inputs.html#keyboard","text":"The class that provides access to the keyboard state is SF::Keyboard . It only contains one class method, key_pressed? , which checks the current state of a key (pressed or released). It is a class method, so you don't need to instantiate SF::Keyboard to use it. This class method directly reads the keyboard state, ignoring the focus state of your window. This means that key_pressed? may return true even if your window is inactive. if SF :: Keyboard . key_pressed? ( SF :: Keyboard :: Left ) # left key is pressed: move our character character . move ( 1 , 0 ) end Key codes are defined in the SF::Keyboard::Key enum. Depending on your operating system and keyboard layout, some key codes might be missing or interpreted incorrectly. This is something that will be improved in a future version of SFML.","title":"Keyboard"},{"location":"tutorials/window/inputs.html#mouse","text":"The class that provides access to the mouse state is SF::Mouse . Like its friend SF::Keyboard , SF::Mouse only contains class methods and is not meant to be instantiated (SFML only handles a single mouse for the time being). You can check if buttons are pressed: if SF :: Mouse . button_pressed? ( SF :: Mouse :: Left ) # left mouse button is pressed: shoot gun . fire end Mouse button codes are defined in the SF::Mouse::Button enum. SFML supports up to 5 buttons: left, right, middle (wheel), and two additional buttons whatever they may be. You can also get and set the current position of the mouse, either relative to the desktop or to a window: # get the global mouse position (relative to the desktop) global_position = SF :: Mouse . position # get the local mouse position (relative to a window) local_position = SF :: Mouse . get_position ( window ) # window is a SF::Window # set the mouse position globally (relative to the desktop) SF :: Mouse . position = SF . vector2 ( 10 , 50 ) # set the mouse position locally (relative to a window) SF :: Mouse . set_position ( SF . vector2 ( 10 , 50 ), window ) # window is a SF::Window There is no function for reading the current state of the mouse wheel. Since the wheel can only be moved relatively, it has no absolute state that can be queried. By looking at a key you can tell whether it's pressed or released. By looking at the mouse cursor you can tell where it is located on the screen. However, looking at the mouse wheel doesn't tell you which \"tick\" it is on. You can only be notified when it moves ( MouseWheelMoved event).","title":"Mouse"},{"location":"tutorials/window/inputs.html#joystick","text":"The class that provides access to the joysticks' states is SF::Joystick . Like the other classes in this tutorial, it only contains class methods. Joysticks are identified by their index (0 to 7, since SFML supports up to 8 joysticks). Therefore, the first argument of every class method of SF::Joystick is the index of the joystick that you want to query. You can check whether a joystick is connected or not: if SF :: Joystick . connected? ( 0 ) # joystick number 0 is connected ... end You can also get the capabilities of a connected joystick: # check how many buttons joystick number 0 has button_count = SF :: Joystick . get_button_count ( 0 ) # check if joystick number 0 has a Z axis has_z = SF :: Joystick . axis? ( 0 , SF :: Joystick :: Z ) Joystick axes are defined in the SF::Joystick::Axis enum. Since buttons have no special meaning, they are simply numbered from 0 to 31. Finally, you can query the state of a joystick's axes and buttons as well: # is button 1 of joystick number 0 pressed? if SF :: Joystick . button_pressed? ( 0 , 1 ) # yes: shoot! gun . fire end # what's the current position of the X and Y axes of joystick number 0? x = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: X ) y = SF :: Joystick . get_axis_position ( 0 , SF :: Joystick :: Y ) character . move ( x , y ) Joystick states are automatically updated when you check for events. If you don't check for events, or need to query a joystick state (for example, checking which joysticks are connected) before starting your game loop, you'll have to manually call the SF::Joystick.update class method yourself to make sure that the joystick states are up to date.","title":"Joystick"},{"location":"tutorials/window/opengl.html","text":"Using OpenGL in an SFML window # Relevant examples: gl , cube Introduction # This tutorial is not about OpenGL itself, but rather how to use CrSFML as an environment for OpenGL, and how to mix them together. As you know, one of the most important features of OpenGL is portability. But OpenGL alone won't be enough to create complete programs: you need a window, a rendering context, user input, etc. You would have no choice but to write OS-specific code to handle this stuff on your own. That's where the sfml-window module comes into play. Let's see how it allows you to play with OpenGL. OpenGL? # To use OpenGL, you'll need to find a library that implements Crystal bindings to it. This tutorial also contains small bits of OpenGL bindings. Creating an OpenGL window # Since SFML is based on OpenGL, its windows are ready for OpenGL calls without any extra effort. @[ Link ( \"GL\" ) ] # Use @[Link(framework: \"OpenGL\")] on Mac OSX lib GL fun enable = glEnable ( cap : Int32 ) TEXTURE_2D = 3553 end window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" ) # it works out of the box GL . enable ( GL :: TEXTURE_2D ) ... In case you think it is too automatic, SF::Window 's constructor has an extra argument that allows you to change the settings of the underlying OpenGL context. This argument is an instance of the structure, it provides access to the following settings: depth_bits is the number of bits per pixel to use for the depth buffer (0 to disable it) stencil_bits is the number of bits per pixel to use for the stencil buffer (0 to disable it) antialiasing_level is the multisampling level major_version and minor_version comprise the requested version of OpenGL settings = SF :: ContextSettings . new ( depth : 24 , stencil : 8 , antialiasing : 4 , major : 3 , minor : 0 ) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" , settings : settings ) If any of these settings is not supported by the graphics card, SFML tries to find the closest valid match. For example, if 4x anti-aliasing is too high, it tries 2x and then falls back to 0. In any case, you can check what settings SFML actually used with the settings method: settings = window . settings puts \"depth bits: #{ settings . depth_bits } \" puts \"stencil bits: #{ settings . stencil_bits } \" puts \"antialiasing level: #{ settings . antialiasing_level } \" puts \"version: #{ settings . major_version } . #{ settings . minor_version } \" OpenGL versions above 3.0 are supported by SFML (as long as your graphics driver can handle them). Support for selecting the profile of 3.2+ contexts and whether the context debug flag is set was added in SFML 2.3. The forward compatibility flag is not supported. By default, SFML creates 3.2+ contexts using the compatibility profile because the graphics module makes use of legacy OpenGL functionality. If you intend on using the graphics module, make sure to create your context without the core profile setting or the graphics module will not function correctly. On OS X, SFML supports creating OpenGL 3.2+ contexts using the core profile only. If you want to use the graphics module on OS X, you are limited to using a legacy context which implies OpenGL version 2.1. A typical OpenGL-with-CrSFML program # Here is what a complete OpenGL program would look like with CrSFML: require \"crsfml\" # create bindings @[ Link ( \"GL\" ) ] lib GL fun enable = glEnable ( cap : Int32 ) fun viewport = glViewport ( x : Int32 , y : Int32 , width : Int32 , height : Int32 ) fun clear = glClear ( mask : Int32 ) TEXTURE_2D = 3553 COLOR_BUFFER_BIT = 16384 DEPTH_BUFFER_BIT = 256 end GL . enable ( GL :: TEXTURE_2D ) # create the window settings = SF :: ContextSettings . new ( 32 ) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" , settings : settings ) window . vertical_sync_enabled = true # load resources, initialize the OpenGL states, ... # run the main loop running = true while running # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed # end the program running = false elsif event . is_a? SF :: Event :: Resized # adjust the viewport when the window is resized GL . viewport ( 0 , 0 , event . width , event . height ) end end # clear the buffers GL . clear ( GL :: COLOR_BUFFER_BIT | GL :: DEPTH_BUFFER_BIT ) # draw... # end the current frame (internally swaps the front and back buffers) window . display end Here we don't use window.open? as the condition of the main loop, because we need the window to remain open until the program ends, so that we still have a valid OpenGL context for the last iteration of the loop and the cleanup code. Don't hesitate to have a look at the \"OpenGL\" and \"Window\" examples in the SFML SDK if you have further problems, they are more complete and most likely contain solutions to your problems. Managing multiple OpenGL windows # Managing multiple OpenGL windows is not more complicated than managing one, there are just a few things to keep in mind. OpenGL calls are made on the active context (thus the active window). Therefore if you want to draw to two different windows within the same program, you have to select which window is active before drawing something. This can be done with the active= method: # activate the first window window1 . active = true # draw to the first window... # activate the second window window2 . active = true # draw to the second window... Only one context (window) can be active in a thread, so you don't need to deactivate a window before activating another one, it is deactivated automatically. This is how OpenGL works. Another thing to know is that all the OpenGL contexts created by SFML share their resources. This means that you can create a texture or vertex buffer with any context active, and use it with any other. This also means that you don't have to reload all your OpenGL resources when you recreate your window. Only shareable OpenGL resources can be shared among contexts. An example of an unshareable resource is a vertex array object. Using OpenGL together with the graphics module # This tutorial was about mixing OpenGL with sfml-window, which is fairly easy since it's the only purpose of this module. Mixing with the graphics module is a little more complicated: sfml-graphics uses OpenGL too, so extra care must be taken so that SFML and user states don't conflict with each other. If you don't know the graphics module yet, all you have to know is that the SF::Window class is replaced with SF::RenderWindow , which inherits all its methods and adds features to draw SFML specific entities. The only way to avoid conflicts between SFML and your own OpenGL states, is to save/restore them every time you switch from OpenGL to SFML. draw with OpenGL save OpenGL states draw with SFML restore OpenGL states draw with OpenGL ... The easiest solution is to let CrSFML do it for you, with the push_gl_states / pop_gl_states methods: glDraw ... window . push_gl_states window . draw ( ... ) window . pop_gl_states glDraw ... Since it has no knowledge about your OpenGL code, SFML can't optimize these steps and as a result it saves/restores all available OpenGL states and matrices. This may be acceptable for small projects, but it might also be too slow for bigger programs that require maximum performance. In this case, you can handle saving and restoring the OpenGL states yourself, with glPushAttrib / glPopAttrib , glPushMatrix / glPopMatrix , etc. If you do this, you'll still need to restore SFML's own states before drawing. This is done with the reset_gl_states method. glDraw ... glPush ... window . reset_gl_states window . draw ( ... ) glPop ... glDraw ... By saving and restoring OpenGL states yourself, you can manage only the ones that you really need which leads to reducing the number of unnecessary driver calls.","title":"Using OpenGL in an SFML window"},{"location":"tutorials/window/opengl.html#using-opengl-in-an-sfml-window","text":"Relevant examples: gl , cube","title":"Using OpenGL in an SFML window"},{"location":"tutorials/window/opengl.html#introduction","text":"This tutorial is not about OpenGL itself, but rather how to use CrSFML as an environment for OpenGL, and how to mix them together. As you know, one of the most important features of OpenGL is portability. But OpenGL alone won't be enough to create complete programs: you need a window, a rendering context, user input, etc. You would have no choice but to write OS-specific code to handle this stuff on your own. That's where the sfml-window module comes into play. Let's see how it allows you to play with OpenGL.","title":"Introduction"},{"location":"tutorials/window/opengl.html#opengl","text":"To use OpenGL, you'll need to find a library that implements Crystal bindings to it. This tutorial also contains small bits of OpenGL bindings.","title":"OpenGL?"},{"location":"tutorials/window/opengl.html#creating-an-opengl-window","text":"Since SFML is based on OpenGL, its windows are ready for OpenGL calls without any extra effort. @[ Link ( \"GL\" ) ] # Use @[Link(framework: \"OpenGL\")] on Mac OSX lib GL fun enable = glEnable ( cap : Int32 ) TEXTURE_2D = 3553 end window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" ) # it works out of the box GL . enable ( GL :: TEXTURE_2D ) ... In case you think it is too automatic, SF::Window 's constructor has an extra argument that allows you to change the settings of the underlying OpenGL context. This argument is an instance of the structure, it provides access to the following settings: depth_bits is the number of bits per pixel to use for the depth buffer (0 to disable it) stencil_bits is the number of bits per pixel to use for the stencil buffer (0 to disable it) antialiasing_level is the multisampling level major_version and minor_version comprise the requested version of OpenGL settings = SF :: ContextSettings . new ( depth : 24 , stencil : 8 , antialiasing : 4 , major : 3 , minor : 0 ) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" , settings : settings ) If any of these settings is not supported by the graphics card, SFML tries to find the closest valid match. For example, if 4x anti-aliasing is too high, it tries 2x and then falls back to 0. In any case, you can check what settings SFML actually used with the settings method: settings = window . settings puts \"depth bits: #{ settings . depth_bits } \" puts \"stencil bits: #{ settings . stencil_bits } \" puts \"antialiasing level: #{ settings . antialiasing_level } \" puts \"version: #{ settings . major_version } . #{ settings . minor_version } \" OpenGL versions above 3.0 are supported by SFML (as long as your graphics driver can handle them). Support for selecting the profile of 3.2+ contexts and whether the context debug flag is set was added in SFML 2.3. The forward compatibility flag is not supported. By default, SFML creates 3.2+ contexts using the compatibility profile because the graphics module makes use of legacy OpenGL functionality. If you intend on using the graphics module, make sure to create your context without the core profile setting or the graphics module will not function correctly. On OS X, SFML supports creating OpenGL 3.2+ contexts using the core profile only. If you want to use the graphics module on OS X, you are limited to using a legacy context which implies OpenGL version 2.1.","title":"Creating an OpenGL window"},{"location":"tutorials/window/opengl.html#a-typical-opengl-with-crsfml-program","text":"Here is what a complete OpenGL program would look like with CrSFML: require \"crsfml\" # create bindings @[ Link ( \"GL\" ) ] lib GL fun enable = glEnable ( cap : Int32 ) fun viewport = glViewport ( x : Int32 , y : Int32 , width : Int32 , height : Int32 ) fun clear = glClear ( mask : Int32 ) TEXTURE_2D = 3553 COLOR_BUFFER_BIT = 16384 DEPTH_BUFFER_BIT = 256 end GL . enable ( GL :: TEXTURE_2D ) # create the window settings = SF :: ContextSettings . new ( 32 ) window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"OpenGL\" , settings : settings ) window . vertical_sync_enabled = true # load resources, initialize the OpenGL states, ... # run the main loop running = true while running # handle events while event = window . poll_event if event . is_a? SF :: Event :: Closed # end the program running = false elsif event . is_a? SF :: Event :: Resized # adjust the viewport when the window is resized GL . viewport ( 0 , 0 , event . width , event . height ) end end # clear the buffers GL . clear ( GL :: COLOR_BUFFER_BIT | GL :: DEPTH_BUFFER_BIT ) # draw... # end the current frame (internally swaps the front and back buffers) window . display end Here we don't use window.open? as the condition of the main loop, because we need the window to remain open until the program ends, so that we still have a valid OpenGL context for the last iteration of the loop and the cleanup code. Don't hesitate to have a look at the \"OpenGL\" and \"Window\" examples in the SFML SDK if you have further problems, they are more complete and most likely contain solutions to your problems.","title":"A typical OpenGL-with-CrSFML program"},{"location":"tutorials/window/opengl.html#managing-multiple-opengl-windows","text":"Managing multiple OpenGL windows is not more complicated than managing one, there are just a few things to keep in mind. OpenGL calls are made on the active context (thus the active window). Therefore if you want to draw to two different windows within the same program, you have to select which window is active before drawing something. This can be done with the active= method: # activate the first window window1 . active = true # draw to the first window... # activate the second window window2 . active = true # draw to the second window... Only one context (window) can be active in a thread, so you don't need to deactivate a window before activating another one, it is deactivated automatically. This is how OpenGL works. Another thing to know is that all the OpenGL contexts created by SFML share their resources. This means that you can create a texture or vertex buffer with any context active, and use it with any other. This also means that you don't have to reload all your OpenGL resources when you recreate your window. Only shareable OpenGL resources can be shared among contexts. An example of an unshareable resource is a vertex array object.","title":"Managing multiple OpenGL windows"},{"location":"tutorials/window/opengl.html#using-opengl-together-with-the-graphics-module","text":"This tutorial was about mixing OpenGL with sfml-window, which is fairly easy since it's the only purpose of this module. Mixing with the graphics module is a little more complicated: sfml-graphics uses OpenGL too, so extra care must be taken so that SFML and user states don't conflict with each other. If you don't know the graphics module yet, all you have to know is that the SF::Window class is replaced with SF::RenderWindow , which inherits all its methods and adds features to draw SFML specific entities. The only way to avoid conflicts between SFML and your own OpenGL states, is to save/restore them every time you switch from OpenGL to SFML. draw with OpenGL save OpenGL states draw with SFML restore OpenGL states draw with OpenGL ... The easiest solution is to let CrSFML do it for you, with the push_gl_states / pop_gl_states methods: glDraw ... window . push_gl_states window . draw ( ... ) window . pop_gl_states glDraw ... Since it has no knowledge about your OpenGL code, SFML can't optimize these steps and as a result it saves/restores all available OpenGL states and matrices. This may be acceptable for small projects, but it might also be too slow for bigger programs that require maximum performance. In this case, you can handle saving and restoring the OpenGL states yourself, with glPushAttrib / glPopAttrib , glPushMatrix / glPopMatrix , etc. If you do this, you'll still need to restore SFML's own states before drawing. This is done with the reset_gl_states method. glDraw ... glPush ... window . reset_gl_states window . draw ( ... ) glPop ... glDraw ... By saving and restoring OpenGL states yourself, you can manage only the ones that you really need which leads to reducing the number of unnecessary driver calls.","title":"Using OpenGL together with the graphics module"},{"location":"tutorials/window/window.html","text":"Opening and managing an SFML window # Relevant example: simple Introduction # This tutorial only explains how to open and manage a window. Drawing stuff is beyond the scope of the sfml-window module: it is handled by the sfml-graphics module. However, the window management remains exactly the same so reading this tutorial is important in any case. Opening a window # Windows in CrSFML are defined by the SF::Window class. A window can be created and opened directly upon construction: require \"crsfml\" window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) ... The first argument, the video mode , defines the size of the window (the inner size, without the title bar and borders). Here, we create a window with a size of 800x600 pixels. The SF::VideoMode class has some interesting class methods to get the desktop resolution, or the list of valid video modes for fullscreen mode. Don't hesitate to have a look at its documentation. The second argument is simply the title of the window. This constructor accepts a third optional argument: a style, which allows you to choose which decorations and features you want. You can use any combination of the following styles: SF::Style::None No decoration at all (useful for splash screens, for example); this style cannot be combined with others SF::Style::Titlebar The window has a titlebar SF::Style::Resize The window can be resized and has a maximize button SF::Style::Close The window has a close button SF::Style::Fullscreen The window is shown in fullscreen mode; this style cannot be combined with others, and requires a valid video mode SF::Style::Default The default style, which is a shortcut for Titlebar | Resize | Close There's also a fourth optional argument, which defines OpenGL specific options which are explained in the dedicated OpenGL tutorial . Bringing the window to life # If you try to execute the code above with nothing in place of the \"...\", you will hardly see anything. First, because the program ends immediately. Second, because there's no event handling -- so even if you added an endless loop to this code, you would see a dead window, unable to be resized or closed. Let's add some code to make this program a bit more interesting: require \"crsfml\" window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) # run the program as long as the window is open while window . open? # check all the window's events that were triggered since the last iteration of the loop while event = window . poll_event # \"close requested\" event: we close the window if event . is_a? SF :: Event :: Closed window . close end end end The above code will open a window, and terminate when the user closes it. Let's see how it works in detail. First, we added a loop that ensures that the application will be refreshed/updated until the window is closed. Most (if not all) CrSFML programs will have this kind of loop, sometimes called the main loop or game loop . Then, the first thing that we want to do inside our game loop is check for any events that occurred. Note that we use a while loop so that all pending events are processed in case there were several. The poll_event method returns an event if there was one pending, or nil otherwise. Whenever we get an event, we must check its type (window closed? key pressed? mouse moved? joystick connected? ...), and react accordingly if we are interested in it. In this case, we only care about the Event::Closed event, which is triggered when the user wants to close the window. At this point, the window is still open and we have to close it explicitly with the close method. This enables you to do something before the window is closed, such as saving the current state of the application, or displaying a message. A mistake that people often make is to forget the event loop, simply because they don't yet care about handling events (they use real-time inputs instead). Without an event loop, the window will become unresponsive. It is important to note that the event loop has two roles: in addition to providing events to the user, it gives the window a chance to process its internal events too, which is required so that it can react to move or resize user actions. After the window has been closed, the main loop exits and the program terminates. At this point, you probably noticed that we haven't talked about drawing something to the window yet. As stated in the introduction, this is not the job of the sfml-window module, and you'll have to jump to the sfml-graphics tutorials if you want to draw things such as sprites, text or shapes. To draw stuff, you can also use OpenGL directly and totally ignore the sfml-graphics module. SF::Window internally creates an OpenGL context and is ready to accept your OpenGL calls. You can learn more about that in the corresponding tutorial . Don't expect to see anything interesting in this window: you may see a uniform color (black or white), or the last contents of the previous application that used OpenGL, or... something else. Playing with the window # Of course, CrSFML allows you to play with your windows a bit. Basic window operations such as changing the size, position, title or icon are supported, but unlike dedicated GUI libraries, SFML doesn't provide advanced features. SFML windows are only meant to provide an environment for OpenGL or SFML drawing. # change the position of the window (relatively to the desktop) window . position = SF . vector2 ( 10 , 50 ) # change the size of the window window . size = SF . vector2 ( 640 , 480 ) # change the title of the window window . title = \"SFML window\" # get the size of the window size = window . size width = size . x height = size . y ... You can refer to the API documentation for a complete list of SF::Window 's methods. In case you really need advanced features for your window, you can create one (or even a full GUI) with another library, and embed SFML into it. To do so, you can use the other constructor of SF::Window which takes the OS-specific handle of an existing window. In this case, SFML will create a drawing context inside the given window and catch all its events without interfering with the parent window management. handle = ... # specific to what you're doing and the library you're using SF :: Window . from_handle ( handle ) If you just want an additional, very specific feature, you can also do it the other way round: create an SFML window and get its OS-specific handle to implement things that SFML itself doesn't support. window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) handle = window . system_handle # you can now use the handle with OS specific functions Integrating SFML with other libraries requires some work and won't be described here, but you can refer to the dedicated tutorials, examples or forum posts. Controlling the framerate # Sometimes, when your application runs fast, you may notice visual artifacts such as tearing. The reason is that your application's refresh rate is not synchronized with the vertical frequency of the monitor, and as a result, the bottom of the previous frame is mixed with the top of the next one. The solution to this problem is to activate vertical synchronization . It is automatically handled by the graphics card, and can easily be switched on and off with the vertical_sync_enabled= method: window . vertical_sync_enabled = true # call it once, after creating the window After this call, your application will run at the same frequency as the monitor's refresh rate. Sometimes vertical_sync_enabled= will have no effect: this is most likely because vertical synchronization is forced to \"off\" in your graphics driver's settings. It should be set to \"controlled by application\" instead. In other situations, you may also want your application to run at a given framerate, instead of the monitor's frequency. This can be done by calling framerate_limit= : window . framerate_limit = 60 # call it once, after creating the window Unlike vertical_sync_enabled= , this feature is implemented by SFML itself, using a combination of SF::Clock and SF.sleep . An important consequence is that it is not 100% reliable, especially for high framerates: SF.sleep 's resolution depends on the underlying operating system and hardware, and can be as high as 10 or 15 milliseconds. Don't rely on this feature to implement precise timing. Never use both vertical_sync_enabled and framerate_limit at the same time! They would badly mix and make things worse. Things to know about windows # Here is a brief list of what you can and cannot do with SFML windows. You can create multiple windows # SFML allows you to create multiple windows, and to handle them either all in the main thread, or each one in its own thread (but... see below). In this case, don't forget to have an event loop for each window. Multiple monitors are not correctly supported yet # SFML doesn't explicitly manage multiple monitors. As a consequence, you won't be able to choose which monitor a window appears on, and you won't be able to create more than one fullscreen window. This should be improved in a future version. Events must be polled in the window's thread # This is an important limitation of most operating systems: the event loop (more precisely, the poll_event or wait_event method) must be called in the same thread that created the window. This means that if you want to create a dedicated thread for event handling, you'll have to make sure that the window is created in this thread too. If you really want to split things between threads, it is more convenient to keep event handling in the main thread and move the rest (rendering, physics, logic, ...) to a separate thread instead. This configuration will also be compatible with the other limitation described below. On OS X, windows and events must be managed in the main thread # Yep, that's true. Mac OS X just won't agree if you try to create a window or handle events in a thread other than the main one. On Windows, a window which is bigger than the desktop will not behave correctly # For some reason, Windows doesn't like windows that are bigger than the desktop. This includes windows created with VideoMode.get_desktop_mode : with the window decorations (borders and titlebar) added, you end up with a window which is slightly bigger than the desktop.","title":"Opening and managing an SFML window"},{"location":"tutorials/window/window.html#opening-and-managing-an-sfml-window","text":"Relevant example: simple","title":"Opening and managing an SFML window"},{"location":"tutorials/window/window.html#introduction","text":"This tutorial only explains how to open and manage a window. Drawing stuff is beyond the scope of the sfml-window module: it is handled by the sfml-graphics module. However, the window management remains exactly the same so reading this tutorial is important in any case.","title":"Introduction"},{"location":"tutorials/window/window.html#opening-a-window","text":"Windows in CrSFML are defined by the SF::Window class. A window can be created and opened directly upon construction: require \"crsfml\" window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) ... The first argument, the video mode , defines the size of the window (the inner size, without the title bar and borders). Here, we create a window with a size of 800x600 pixels. The SF::VideoMode class has some interesting class methods to get the desktop resolution, or the list of valid video modes for fullscreen mode. Don't hesitate to have a look at its documentation. The second argument is simply the title of the window. This constructor accepts a third optional argument: a style, which allows you to choose which decorations and features you want. You can use any combination of the following styles: SF::Style::None No decoration at all (useful for splash screens, for example); this style cannot be combined with others SF::Style::Titlebar The window has a titlebar SF::Style::Resize The window can be resized and has a maximize button SF::Style::Close The window has a close button SF::Style::Fullscreen The window is shown in fullscreen mode; this style cannot be combined with others, and requires a valid video mode SF::Style::Default The default style, which is a shortcut for Titlebar | Resize | Close There's also a fourth optional argument, which defines OpenGL specific options which are explained in the dedicated OpenGL tutorial .","title":"Opening a window"},{"location":"tutorials/window/window.html#bringing-the-window-to-life","text":"If you try to execute the code above with nothing in place of the \"...\", you will hardly see anything. First, because the program ends immediately. Second, because there's no event handling -- so even if you added an endless loop to this code, you would see a dead window, unable to be resized or closed. Let's add some code to make this program a bit more interesting: require \"crsfml\" window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"My window\" ) # run the program as long as the window is open while window . open? # check all the window's events that were triggered since the last iteration of the loop while event = window . poll_event # \"close requested\" event: we close the window if event . is_a? SF :: Event :: Closed window . close end end end The above code will open a window, and terminate when the user closes it. Let's see how it works in detail. First, we added a loop that ensures that the application will be refreshed/updated until the window is closed. Most (if not all) CrSFML programs will have this kind of loop, sometimes called the main loop or game loop . Then, the first thing that we want to do inside our game loop is check for any events that occurred. Note that we use a while loop so that all pending events are processed in case there were several. The poll_event method returns an event if there was one pending, or nil otherwise. Whenever we get an event, we must check its type (window closed? key pressed? mouse moved? joystick connected? ...), and react accordingly if we are interested in it. In this case, we only care about the Event::Closed event, which is triggered when the user wants to close the window. At this point, the window is still open and we have to close it explicitly with the close method. This enables you to do something before the window is closed, such as saving the current state of the application, or displaying a message. A mistake that people often make is to forget the event loop, simply because they don't yet care about handling events (they use real-time inputs instead). Without an event loop, the window will become unresponsive. It is important to note that the event loop has two roles: in addition to providing events to the user, it gives the window a chance to process its internal events too, which is required so that it can react to move or resize user actions. After the window has been closed, the main loop exits and the program terminates. At this point, you probably noticed that we haven't talked about drawing something to the window yet. As stated in the introduction, this is not the job of the sfml-window module, and you'll have to jump to the sfml-graphics tutorials if you want to draw things such as sprites, text or shapes. To draw stuff, you can also use OpenGL directly and totally ignore the sfml-graphics module. SF::Window internally creates an OpenGL context and is ready to accept your OpenGL calls. You can learn more about that in the corresponding tutorial . Don't expect to see anything interesting in this window: you may see a uniform color (black or white), or the last contents of the previous application that used OpenGL, or... something else.","title":"Bringing the window to life"},{"location":"tutorials/window/window.html#playing-with-the-window","text":"Of course, CrSFML allows you to play with your windows a bit. Basic window operations such as changing the size, position, title or icon are supported, but unlike dedicated GUI libraries, SFML doesn't provide advanced features. SFML windows are only meant to provide an environment for OpenGL or SFML drawing. # change the position of the window (relatively to the desktop) window . position = SF . vector2 ( 10 , 50 ) # change the size of the window window . size = SF . vector2 ( 640 , 480 ) # change the title of the window window . title = \"SFML window\" # get the size of the window size = window . size width = size . x height = size . y ... You can refer to the API documentation for a complete list of SF::Window 's methods. In case you really need advanced features for your window, you can create one (or even a full GUI) with another library, and embed SFML into it. To do so, you can use the other constructor of SF::Window which takes the OS-specific handle of an existing window. In this case, SFML will create a drawing context inside the given window and catch all its events without interfering with the parent window management. handle = ... # specific to what you're doing and the library you're using SF :: Window . from_handle ( handle ) If you just want an additional, very specific feature, you can also do it the other way round: create an SFML window and get its OS-specific handle to implement things that SFML itself doesn't support. window = SF :: RenderWindow . new ( SF :: VideoMode . new ( 800 , 600 ), \"SFML window\" ) handle = window . system_handle # you can now use the handle with OS specific functions Integrating SFML with other libraries requires some work and won't be described here, but you can refer to the dedicated tutorials, examples or forum posts.","title":"Playing with the window"},{"location":"tutorials/window/window.html#controlling-the-framerate","text":"Sometimes, when your application runs fast, you may notice visual artifacts such as tearing. The reason is that your application's refresh rate is not synchronized with the vertical frequency of the monitor, and as a result, the bottom of the previous frame is mixed with the top of the next one. The solution to this problem is to activate vertical synchronization . It is automatically handled by the graphics card, and can easily be switched on and off with the vertical_sync_enabled= method: window . vertical_sync_enabled = true # call it once, after creating the window After this call, your application will run at the same frequency as the monitor's refresh rate. Sometimes vertical_sync_enabled= will have no effect: this is most likely because vertical synchronization is forced to \"off\" in your graphics driver's settings. It should be set to \"controlled by application\" instead. In other situations, you may also want your application to run at a given framerate, instead of the monitor's frequency. This can be done by calling framerate_limit= : window . framerate_limit = 60 # call it once, after creating the window Unlike vertical_sync_enabled= , this feature is implemented by SFML itself, using a combination of SF::Clock and SF.sleep . An important consequence is that it is not 100% reliable, especially for high framerates: SF.sleep 's resolution depends on the underlying operating system and hardware, and can be as high as 10 or 15 milliseconds. Don't rely on this feature to implement precise timing. Never use both vertical_sync_enabled and framerate_limit at the same time! They would badly mix and make things worse.","title":"Controlling the framerate"},{"location":"tutorials/window/window.html#things-to-know-about-windows","text":"Here is a brief list of what you can and cannot do with SFML windows.","title":"Things to know about windows"},{"location":"tutorials/window/window.html#you-can-create-multiple-windows","text":"SFML allows you to create multiple windows, and to handle them either all in the main thread, or each one in its own thread (but... see below). In this case, don't forget to have an event loop for each window.","title":"You can create multiple windows"},{"location":"tutorials/window/window.html#multiple-monitors-are-not-correctly-supported-yet","text":"SFML doesn't explicitly manage multiple monitors. As a consequence, you won't be able to choose which monitor a window appears on, and you won't be able to create more than one fullscreen window. This should be improved in a future version.","title":"Multiple monitors are not correctly supported yet"},{"location":"tutorials/window/window.html#events-must-be-polled-in-the-windows-thread","text":"This is an important limitation of most operating systems: the event loop (more precisely, the poll_event or wait_event method) must be called in the same thread that created the window. This means that if you want to create a dedicated thread for event handling, you'll have to make sure that the window is created in this thread too. If you really want to split things between threads, it is more convenient to keep event handling in the main thread and move the rest (rendering, physics, logic, ...) to a separate thread instead. This configuration will also be compatible with the other limitation described below.","title":"Events must be polled in the window's thread"},{"location":"tutorials/window/window.html#on-os-x-windows-and-events-must-be-managed-in-the-main-thread","text":"Yep, that's true. Mac OS X just won't agree if you try to create a window or handle events in a thread other than the main one.","title":"On OS X, windows and events must be managed in the main thread"},{"location":"tutorials/window/window.html#on-windows-a-window-which-is-bigger-than-the-desktop-will-not-behave-correctly","text":"For some reason, Windows doesn't like windows that are bigger than the desktop. This includes windows created with VideoMode.get_desktop_mode : with the window decorations (borders and titlebar) added, you end up with a window which is slightly bigger than the desktop.","title":"On Windows, a window which is bigger than the desktop will not behave correctly"}]}